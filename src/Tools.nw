\documentclass{article}

\usepackage{noweb}
\noweboptions{smallcode,longchunks}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{colortbl}
\usepackage[colorlinks=true]{hyperref}
\usepackage{tikz}

\newcommand{\hi}[1]{\noindent {\bf #1}}     % Define a handy paragraph opener

\def\nwendcode{\endtrivlist \endgroup}      % Remove noweb page break penalty
\let\nwdocspar=\par

\title{Jargo Distance Utilities\footnote{
  \url{https://github.com/jargors/Tools}}}
\author{James J. Pan\\
  \small{\href{mailto:pan-j16@mails.tsinghua.edu.cn}{pan-j16@mails.tsinghua.edu.cn}}}

\begin{document}
\maketitle
\pagestyle{noweb}

\tableofcontents

\section{Introduction}
\label{sec:introduction}
We supply a Tools class that provides some common procedures for developing
ridesharing algorithms.  The Tools class is developed using the
Noweb\footnote{\url{https://www.cs.tufts.edu/~nr/noweb/}} literate
programming\footnote{\url{http://literateprogramming.com/}} tool.  This file
([[src/Tools.nw]]) is the source for both the documentation ([[doc/Tools.tex]])
and the Java code (Tools.java)\footnote{See the [[Makefile]] for build
details.}.

\section{Implementation Overview}
<<Tools.java>>=
<<Tools.java preamble>>
<<[[Tools]] definition>>
@

\subsection{Preamble}
The preamble declares the package and imports dependencies.
<<Tools.java preamble>>=
package com.github.jargors;
import com.github.jargors.gtreeJNI.*;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
@

\subsection{Class Definition}
<<[[Tools]] definition>>=
public class Tools {
  <<Member variables>>
  <<Public methods>>
}
@

\subsection{Member Variables}
<<Member variables>>=
private G_Tree gtree;
private boolean flag_gtree_loaded = false;
private Map<Integer, int[]> lu_vertices = new HashMap<>();
private Map<Integer, Map<Integer, int[]>> lu_edges = new HashMap<>();
private Map<Integer, int[]> lu_users = new HashMap<>();
private final double CSHIFT = 10000000.0;
@ %def gtree flag_gtree_loaded lu_vertices lu_edges lu_users CSHIFT

\section{Public Methods}
<<Public methods>>=
  <<Load GTree>>
  <<Register vertices>>
  <<Register edges>>
  <<Register users>>
  <<Compute haversine>>
  <<Compute duration>>
  <<Compute shortest path>>
  <<Compute shortest path distance>>
  <<Compute route>>
  <<Filter locs by haversine distance>>
  <<Print user>>
  <<Print path>>
  <<Print route>>
  <<Print schedule>>
@

\subsection{[[loadGTree]](1)}
The [[gtreeJNI.load]](1) method can do strange things if [[f_gtree]] is empty,
so we do some basic validation here before proceeding.
<<Load GTree>>=
public void loadGTree(String p) {
  try {
    System.loadLibrary("gtree");
  } catch (UnsatisfiedLinkError e) {
    System.err.println("Native code library failed to load: "+e);
    System.exit(1);
  }
  if (p.length() > 0) {
    gtreeJNI.load(p);
    gtree = gtreeJNI.get();
    flag_gtree_loaded = true;
  } else {
    System.out.println("Bad path to gtree");
  }
}
@ %def loadGTree

\subsection{[[registerVertices]](1)}
Be mindful, any change to [[src]] will appear in [[lu_vertices]].
<<Register vertices>>=
public void registerVertices(Map<Integer, int[]> src) {
  lu_vertices = src;
}
@ %def registerVertices

\subsection{[[registerEdges]](1)}
Be mindful, any change to [[src]] will appear in [[lu_edges]].
<<Register edges>>=
public void registerEdges(Map<Integer, Map<Integer, int[]>> src) {
  lu_edges = src;
}
@ %def registerEdges

\subsection{[[registerUsers]](1)}
Be mindful, any change to [[src]] will appear in [[lu_users]].
<<Register users>>=
public void registerUsers(Map<Integer, int[]> src) {
  lu_users = src;
}
@ %def registerUsers

\subsection{[[computeHaversine]](4)}
Most of this code is Copyright 2017 Juliano Macedo and is licensed under the
MIT License. It has been modified from its original form.
<<Compute haversine>>=
public int computeHaversine(double lng1, double lat1, double lng2, double lat2) {
  double dlat = Math.toRadians(lat2 - lat1);
  double dlng = Math.toRadians(lng2 - lng1);
  double rlat1 = Math.toRadians(lat1);
  double rlat2 = Math.toRadians(lat2);
  double a = Math.pow(Math.sin(dlat / 2), 2)
    + Math.pow(Math.sin(dlng / 2), 2)
    * Math.cos(rlat1) * Math.cos(rlat2);
  double c = 2 * Math.asin(Math.sqrt(a));
  int d = (int) Math.round(c * 6371000);
  <<..round to nearest meter>>
  return d;
}
@ %def computeHaversine
If the nearest meter is 0 and the two points are not equal, then the distance
is rounded up to 1 meter.
<<..round to nearest meter>>=
if (d == 0 && (lng1 != lng2 || lat1 != lat2)) {
  d = 1;
}
@

\subsection{[[computeHaversine]](2)}
Beware, the coordinates in [[lu_vertices]] have their decimal places shifted by
[[CSHIFT]]. This function is the reason why we register [[lu_vertices]].
By registering it, we save making a couple of database calls.
<<Compute haversine>>=
public int computeHaversine(int u, int v) {
  return computeHaversine(
    lu_vertices.get(u)[0]/CSHIFT, lu_vertices.get(u)[1]/CSHIFT,
    lu_vertices.get(v)[0]/CSHIFT, lu_vertices.get(v)[1]/CSHIFT);
}
@

\subsection{[[computeDuration]](2)}
<<Compute duration>>=
public int computeDuration(int dd, int nu) {
  int d = (int) Math.ceil(dd/(float) nu);
  return (d == 0 ? 1 : d);
}
@


\subsection{[[computeShortestPath]](2)}
Beware, two important notes:
\begin{itemize}
\item The vertices in G-tree are 0-indexed while they are 1-indexed in Jargo.  To
compensate, at location [[L1]] we subtract 1 from [[u]] and [[v]], and at
location [[L2]] we add 1 to the vertices returned in the path.
\item We consider vertex 0 to be a dummy vertex. The path to this vertex
from any other vertex $v$ is always $\{v, 0\}$. The path from 0 to any other
vertex is undefined and throws a [[RuntimeException]].
\end{itemize}
<<Compute shortest path>>=
public int[] computeShortestPath(int u, int v) {
  int[] output = null;
  if (!flag_gtree_loaded) {
    throw new RuntimeException("GTree not loaded!");
  } else if (u == 0) {
    throw new RuntimeException(
        "Attempted to find shortest path originating from dummy vertex!");
  } else if (v == 0) {
    output = new int[] { u, v };
  } else if (u == v) {
    output = new int[] { u };
  } else {
    IntVector path = new IntVector();
    gtree.find_path((u - 1), (v - 1), path);        // L1
    if (path != null) {
      output = new int[path.size()];
      for (int i = 0; i < path.size(); i++) {
        output[i] = path.get(i) + 1;                // L2
      }
    }
  }
  return output;
}
@ %def computeShortestPath

\subsection{[[computeShortestPathDistance]](2)}
Beware, two important notes:
\begin{itemize}
\item The vertices in G-tree are 0-indexed while they are 1-indexed in Jargo.
To compensate, at we subtract 1 from [[u]] and [[v]] when calling
[[gtree.search]](2).
\item We consider vertex 0 to be a dummy vertex. The distance to this vertex
is always 0.
\end{itemize}
<<Compute shortest path distance>>=
public int computeShortestPathDistance(int u, int v) {
  int d = 0;
  if (!flag_gtree_loaded) {
    throw new RuntimeException("GTree not loaded!");
  } else if (u == 0) {
    throw new RuntimeException(
        "Attempted to find shortest distance originating from dummy vertex!");
  } else if (u != v && v != 0) {
    d = gtree.search((u - 1), (v - 1));
  }
  return d;
}
@ %def computeShortestPathDistance

\subsection{[[computeRoute]](3)}
<<Compute route>>=
public int[] computeRoute(int source, int target, int starttime) {
  int[] output = null;
  if (source == 0) {
    throw new RuntimeException("ERROR computeRoute(3): source cannot be 0!");
  } else if (target == 0) {
    output = new int[] { starttime, source, starttime + 1, target };
  } else {
    int[] path = null;
    int[] edge = null;
    int u, v, t;
    path = computeShortestPath(source, target);
    if (path == null) {
      throw new RuntimeException("ERROR computeRoute(3): null path!");
    } else {
      output = new int[(path.length*2)];
      output[0] = t = starttime;
      output[1] = source;
      int j = 2;
      for (int i = 0; i < path.length - 1; i++) {
        u = path[(i + 0)];
        v = path[(i + 1)];
        edge = lu_edges.get(u).get(v);
        output[(j + 0)] = (t += computeDuration(edge[0], edge[1]));
        output[(j + 1)] = v;
        j += 2;
      }
    }
  }
  return output;
}
@ %def computeRoute

\subsection{[[filterByHaversine]](3)}
This function takes a request origin [[ro]], a locations array [[locs]], and
a distance threshold [[threshold]] as input, and returns a copy of [[locs]]
that keeps only those location triplets where the haversine distance between
the location in the triplet and [[ro]] is within [[threshold]].

Locations array [[locs]] =

\noindent
\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\texttt{sid}\textrm{ of server }s_1$};
 &\node[draw] {$1:\pi_t(w_{|w_{\leq t}|})\textrm{ of server }s_1$};
 &\node[draw] {$2:\pi_v(w_{|w_{\leq t}|})\textrm{ of server }s_1$};\\
  \node[draw] {$3:\texttt{sid}\textrm{ of server }s_2$};
 &\node[draw] {$4:\pi_t(w_{|w_{\leq t}|})\textrm{ of server }s_2$};
 &\node[draw] {$5:\pi_v(w_{|w_{\leq t}|})\textrm{ of server }s_2$};\\
  \node {$...$ and so on,};\\
};
\end{tikzpicture}

\noindent
where $\pi_t(w_{|w_{\leq t}|})$ gives the time component of a server's
last-visited waypoint, and $\pi_v(w_{|w_{\leq t}|})$ gives the vertex
component.

<<Filter locs by haversine distance>>=
public int[] filterByHaversine(int ro, int[] locs, int threshold) {
  int n = (locs.length/3);
  int[] temp = new int[n];
  int i = 0;
  for (int k = 0; k < n; k++) {
    if (computeHaversine(ro, locs[((3*k) + 2)]) < threshold) {
      temp[i++] = 3*k;
    }
  }
  return Arrays.copyOf(temp, i);
}
@ %def filterByHaversine

\subsection{[[printUser]](1)}
The [[printUser]](1) method can be used to print properties of a ridesharing
user.
<<Print user>>=
public void printUser(int[] u) {
  System.out.println("User {uid="+u[0]+", q="+u[1]+", e="+u[2]+", l="+u[3]
    +", o="+u[4]+", d="+u[5]+", b="+u[6]+"}");
}
@ %def printUser

\subsection{[[printPath]](1)}
The [[printPath]](1) method can be used to print a path.
<<Print path>>=
public void printPath(int[] p) {
  for (Integer i : p) {
    System.out.print(i+" ");
  }
  System.out.println();
}
@ %def printPath

\subsection{[[printRoute]](1)}
The [[printRoute]](1) method can be used to print a route.
<<Print route>>=
public void printRoute(int[] w) {
  for (int i = 0; i < (w.length - 1); i += 2) {
    System.out.print("("+w[i]+", "+w[(i + 1)]+") ");
  }
  System.out.println();
}
@ %def printRoute

\subsection{[[printSchedule]](1)}
The [[printSchedule]](1) method can be used to print a schedule.
<<Print schedule>>=
public void printSchedule(int[] b) {
  for (int i = 0; i < (b.length - 3); i += 4) {
    System.out.print("("+b[i]+", "+b[(i + 1)]
      + ", "+b[(i + 2)]+", "+b[(i + 3)]+") ");
  }
  System.out.println();
}
@ %def printSchedule


\appendix

\section{Appendix: List of Chunks}
\label{ap:list-of-chunks}
\nowebchunks

\section{Appendix: List of Identifiers}
\label{ap:list-of-identifiers}
\nowebindex

\end{document}

