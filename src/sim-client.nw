\chapter{Class: Client}
\label{sim-client}

<<Client.java>>=
<<Package: [[core]]>>
<<Client.java preamble>>
public abstract class Client {
  <<[[Client]] member variables>>
  <<[[Client]] constructor>>
  <<[[Client]] methods>>
}
@

\section{Preamble}

<<Client.java preamble>>=
import com.github.jargors.core.Communicator;
import com.github.jargors.core.Tools;
import com.github.jargors.core.ClientException;
import com.github.jargors.core.ClientFatalException;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.io.FileNotFoundException;
@

<<Client.java preamble>>=
<<Import JMX dependencies>>
@

\section{Member Variables}
<<[[Client]] member variables>>=
protected ConcurrentLinkedQueue<int[]> queue = new ConcurrentLinkedQueue<int[]>();
protected Communicator communicator;
protected Tools tools = new Tools();
protected final boolean DEBUG =
    "true".equals(System.getProperty("jargors.client.debug"));
@
\section{Constructor}
<<[[Client]] constructor>>=
public Client() {
  <<[[Client]] register JMX monitor>>
  if (DEBUG) {
    System.out.printf("create Client\n");
  }
}
@

\section{Methods}

\subsection{\texttt{notifyNew}(0)}
<<notifyNew(0)>>=
void notifyNew() throws ClientException, ClientFatalException {
  while (!this.queue.isEmpty()) {
    long A0 = System.currentTimeMillis();
    this.handleRequest(this.queue.remove());
    if (DEBUG) {
      System.out.printf("handleRequest(1), arg1=[#]\n");
    }
    <<Stats: clientHandleRequest>>
  }
}
@ %def notifyNew

\subsection{\texttt{addRequest}(1)}
<<addRequest(1)>>=
void addRequest(final int[] r) {
  this.queue.add(r);
}
@ %def addRequest

\subsection{\texttt{dropRequests}(1)}
<<dropRequests(1)>>=
int dropRequests(final int deadline) {
  final int temp = this.queue.size();
  this.queue.removeIf((r) -> { return r[2] < deadline; });
  return Math.max(0, temp - this.queue.size());
}
@ %def dropRequests

\subsection{\texttt{collectServerLocations}(1)}
Array [[src]] =

\noindent
\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server }s$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};
 &\node[minimum width=12mm] {...};\\
};
\end{tikzpicture}

\noindent If locations are polled for and stored into [[src]] at $t'$ world
time, then formally the last location for server $s$ is defined as waypoint
$(t,v)$ that satisfies $t=\textrm{argmin}_{(t,v)\in w_{\leq t'}} (t-t')$, where
$w_{\leq t'}$ is the server's traveled route.  In other words the last location
is the waypoint in the server's traveled route that is nearest $t'$.  After
copying [[src]] into [[locations]], the [[endCollectServerLocations]](0) method
is executed.
<<collectServerLocations(1)>>=
void collectServerLocations(final int[] src) {
  this.endCollectServerLocations(src.clone());
}
@ %def collectServerLocations


\subsection{\texttt{endCollectServerLocations}(1)}
<<endCollectServerLocations(1)>>=
void endCollectServerLocations(final int[] locations) {
  for (int i = 0; i < (locations.length - 2); i += 3) {
    this.handleServerLocation(new int[] {
      locations[i],
      locations[(i + 1)],
      locations[(i + 2)]
    });
  }
}
@ %def endCollectServerLocations

\subsection{\texttt{end}(0)}
<<end(0)>>=
void end() { }
@ %def end

\subsection{\texttt{handleRequest}(1)}
Array [[r]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[rid]] of request $r$}$};
 &\node {$1:r_q$}; & \node {$2:r_e$}; & \node {$3:r_l$};
 &\node {$4:r_o$}; & \node {$5:r_d$}; & \node {$6:d_r$};\\
};
\end{tikzpicture}

<<handleRequest(1)>>=
void handleRequest(final int[] r) throws ClientException, ClientFatalException { }
@ %def handleRequest

\subsection{\texttt{handleServerLocation}(1)}
Array [[loc]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server $s$}$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};\\
};
\end{tikzpicture}

<<handleServerLocation(1)>>=
void handleServerLocation(final int[] loc) { }
@ %def handleServerLocation

\section{Exceptions}

\subsection{\texttt{ClientException}}
<<ClientException.java>>=
<<Package: [[core]]>>
public class ClientException extends Exception {
  public ClientException() { }
  public ClientException(String message) {
    super(message);
  }
  public ClientException(Throwable cause) {
    super(cause);
  }
  public ClientException(String message, Throwable cause) {
    super(message, cause);
  }
}
@

\subsection{\texttt{ClientFatalException}}
<<ClientFatalException.java>>=
<<Package: [[core]]>>
public class ClientFatalException extends Exception {
  public ClientFatalException() { }
  public ClientFatalException(String message) {
    super(message);
  }
  public ClientFatalException(Throwable cause) {
    super(cause);
  }
  public ClientFatalException(String message, Throwable cause) {
    super(message, cause);
  }
}
@

