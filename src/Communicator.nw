\documentclass{article}

\usepackage{noweb}
\noweboptions{smallcode,longchunks}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{colortbl}
\usepackage[colorlinks=true]{hyperref}
\usepackage{graphicx}

\newcommand{\hi}[1]{\noindent {\bf #1}}     % Define a handy paragraph opener

\def\nwendcode{\endtrivlist \endgroup}      % Remove noweb page break penalty
\let\nwdocspar=\par

\title{Jargo Communicator\footnote{
  \url{https://github.com/jargors/Communicator}}}
\author{James J. Pan\\
  \small{\href{mailto:pan-j16@mails.tsinghua.edu.cn}{pan-j16@mails.tsinghua.edu.cn}}}

\begin{document}
\maketitle
\pagestyle{noweb}

\tableofcontents

\section{Introduction}
\label{sec:introduction}
Jargo's communicator intends to be the sole way for Jargo clients to interact
with the Jargo simulated world (Figure~\ref{fig:interface-fig}). The

communicator exposes only the subset of Jargo's storage interface API that a
client would possibly have access to in the real world, including querying and
submitting server routes and schedules.  The communicator is developed using
the Noweb\footnote{\url{https://www.cs.tufts.edu/~nr/noweb/}} literate
programming\footnote{\url{http://literateprogramming.com/}} tool.  This file
([[src/Communicator.nw]]) is the source for the documentation
([[doc/Communicator.tex]]) and the Java code
([[Communicator.java]])\footnote{See the [[Makefile]] for build details.}.

\begin{figure}[h]
\centering
\includegraphics[width=150mm]{src/fig/interface-fig}
\caption{Communicator within the Jargo stack.}
\label{fig:interface-fig}
\end{figure}

\section{Implementation Overview}
\label{sec:implementation-overview}
<<Communicator.java>>=
<<Communicator.java preamble>>
<<[[Communicator]] definition>>
@

\subsection{Preamble}
\label{sec:preamble}
The preamble declares the package and imports dependencies.
<<Communicator.java preamble>>=
package com.github.jargors;
@
<<Communicator.java preamble>>=
import com.github.jargors.Storage;
import com.github.jargors.Controller;
import java.util.function.Supplier;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
@

\subsection{Class Definition}
\label{sec:class-definition}
<<[[Communicator]] definition>>=
public class Communicator {
  <<[[Communicator]] member variables>>
  <<[[Communicator]] constructor>>
  <<[[Communicator]] public methods>>
  <<[[Communicator]] private methods>>
}
@

\subsection{Member Variables}
\label{sec:member-variables}
We define a [[Storage]] and a container for the simulation world time.
<<[[Communicator]] member variables>>=
private Storage storage;
private Controller controller;
private int world_time = 0;
private boolean DEBUG = false;
@ %def storage world_time DEBUG

\subsection{Constructor}
\label{sec:constructor}
<<[[Communicator]] constructor>>=
public Communicator() { }
@

\section{Public Methods}
\label{sec:public-methods}
\hi{General Methods.}
<<[[Communicator]] public methods>>=
<<Set debug>>
<<Set storage>>
<<Set controller>>
<<Set/get simulation world time>>
<<Get reference to vertices cache>>
<<Get reference to edges cache>>
<<Get reference to users cache>>
<<Return request to queue>>
@
\hi{Write Methods.}
<<[[Communicator]] public methods>>=
<<Update server route>>
<<Update server add to schedule>>
<<Update server remove from schedule>>
@
\hi{Read Methods.}
<<[[Communicator]] public methods>>=
<<Query vertex>>
<<Query edge>>
<<Query ridesharing user>>
<<Query active server locations>>
<<Query routes>>
<<Query schedules>>
<<Query remaining distance>>
<<Query remaining duration>>
<<Query max load>>
@

\subsection{General Methods}
\label{sec:general-methods}

\subsubsection{[[setDebug]](1)}
<<Set debug>>=
public void setDebug(boolean flag) {
  DEBUG = flag;
}
@ %def setDebug

\subsubsection{[[setStorage]](1)}
<<Set storage>>=
public void setStorage(Storage src) {
  storage = src;
}
@ %def setStorage

\subsubsection{[[setController]](1)}
<<Set controller>>=
public void setController(Controller src) {
  controller = src;
}
@ %def setController

\subsubsection{[[setSimulationWorldTime]](1)}
We depend on the controller to tell the simulation interface about the current
world time.
<<Set/get simulation world time>>=
public void setSimulationWorldTime(int t) {
  world_time = t;
}
@ %def setSimulationWorldTime

\subsubsection{[[getSimulationWorldTime]](0)}
<<Set/get simulation world time>>=
public int getSimulationWorldTime() {
  return world_time;
}
@ %def getSimulationWorldTime

\subsubsection{[[getReferenceVerticesCache]](0)}
<<Get reference to vertices cache>>=
public final ConcurrentHashMap<Integer, int[]> getReferenceVerticesCache() {
  return storage.getReferenceVerticesCache();
}
@ %def getReferenceVerticesCache

\subsubsection{[[getReferenceEdgesCache]](0)}
<<Get reference to edges cache>>=
public final ConcurrentHashMap<Integer,
    ConcurrentHashMap<Integer, int[]>> getReferenceEdgesCache() {
  return storage.getReferenceEdgesCache();
}
@ %def getReferenceEdgesCache

\subsubsection{[[getReferenceUsersCache]](0)}
<<Get reference to users cache>>=
public final ConcurrentHashMap<Integer, int[]> getReferenceUsersCache() {
  return storage.getReferenceUsersCache();
}
@ %def getReferenceUsersCache

\subsubsection{[[returnRequest]](1)}
<<Return request to queue>>=
public void returnRequest(int rid) {
  controller.returnRequest(rid);
}
@ %def returnRequest

\subsection{Write Methods}
\label{sec:write-methods}

If the submitted route results in overwriting waypoints that a server has
already visited, in other words if [[route[0]]] is less than [[world_time]],
then Communicator rejects the write. The client should be aware and handle
appropriately. To reduce rejections, ensure any submitted route does not
overwrite traveled waypoints.

\subsubsection{[[updateServerRoute]](3)}
<<Update server route>>=
public boolean updateServerRoute(int sid, int[] route, int[] sched) {
  boolean success = false;
  if (route[0] >= world_time) {
    storage.DBUpdateServerRoute(sid, route, sched);
    success = true;
  }
  return success;
}
@ %def updateServerRoute

\subsubsection{[[updateServerAddToSchedule]](4)}
Beware, [[sched]] is 3-element per stop, not 4-element like returned from the query
methods. Maybe should make consistent in the future.
<<Update server add to schedule>>=
public boolean updateServerAddToSchedule(
    int sid, int[] route, int[] sched, int[] rid) {
  final int t = world_time;
  final int[] current = storage.DBQueryServerRoute(sid);
  int i = 0;
  Print("Set i=0");
  Print("Set current <length>="+current.length);
  for (int q = 0; q < (current.length - 1); q += 2) {
    System.out.print("("+current[q]+", "+current[(q + 1)]+") ");
  }
  System.out.println();
  while (i < current.length && current[i] != route[0]) {
    Print("Detected current["+i+"]!=route[0] ("+current[i]+"!="+route[0]+")");
    i += 2;
  }
  Print("Got i="+i);
  if (i == current.length) {
    // branch point not found
    Print("Branch point not found");
    return false;
  } else {
    Print("Found branch point at i="+i);
  }
  int j = 0;
  while (i < current.length && (current[i] <= t && current[(i + 1)] != 0)) {
    if (current[i] != route[j] || current[(i + 1)] != route[(j + 1)]) {
      // overwrite history occurred
      Print("Overwrite history detected, i="+i+", j="+j+" ("+current[i]+"!="+route[j]+", "
        +current[(i + 1)]+"!="+route[(j + 1)]+")");
      return false;
    } else {
      Print("Detected matching history, i="+i+", j="+j+" ("+current[i]+"="+route[j]+", "
        +current[(i + 1)]+"="+route[(j + 1)]+")");
    }
    i += 2;
    j += 2;
  }
  storage.DBUpdateServerAddToSchedule(sid, route, sched, rid);
  return true;
}
@ %def updateServerAddToSchedule

\subsubsection{[[updateServerRemoveFromSchedule]](4)}
<<Update server remove from schedule>>=
public boolean updateServerRemoveFromSchedule(
    int sid, int[] route, int[] sched, int[] rid) {
  boolean success = false;
  if (route[0] >= world_time) {
    storage.DBUpdateServerRemoveFromSchedule(sid, route, sched, rid);
  }
  return success;
}
@ %def updateServerRemoveFromSchedule

\subsection{Read Methods}
\label{sec:read-methods}

\subsubsection{[[queryVertex]](1)}
<<Query vertex>>=
public int[] queryVertex(int v) throws RuntimeException {
  return storage.DBQueryVertex(v);
}
@ %def queryVertex

\subsubsection{[[queryEdge]](2)}
<<Query edge>>=
public int[] queryEdge(int v1, int v2) throws RuntimeException {
  return storage.DBQueryEdge(v1, v2);
}
@ %def queryEdge

\subsubsection{[[queryUser]](1)}
<<Query ridesharing user>>=
public int[] queryUser(int uid) throws RuntimeException {
  return storage.DBQueryUser(uid);
}
@ %def queryUser

\subsubsection{[[queryServerLocationsActive]](1)}
<<Query active server locations>>=
public int[] queryServerLocationsActive(int t) throws RuntimeException {
  return storage.DBQueryServerLocationsActive(t);
}
@ %def queryServerLocationsActive

\subsubsection{[[queryServerRemainingRoute]](2)}
<<Query routes>>=
public int[] queryServerRemainingRoute(int sid, int t) throws RuntimeException {
  return storage.DBQueryServerRemainingRoute(sid, t);
}
@ %def queryServerRemainingRoute

\subsubsection{[[queryServerRemainingSchedule]](2)}
<<Query schedules>>=
public int[] queryServerRemainingSchedule(int sid, int t) throws RuntimeException {
  return storage.DBQueryServerRemainingSchedule(sid, t);
}
@ %def queryServerRemainingSchedule

<<Query remaining distance>>=
public int[] queryServerRemainingDistance(int sid, int t) throws RuntimeException {
  return storage.DBQueryServerRemainingDistance(sid, t);
}
@ %def queryServerRemainingDistance

<<Query remaining duration>>=
public int[] queryServerRemainingDuration(int sid, int t) throws RuntimeException {
  return storage.DBQueryServerRemainingDuration(sid, t);
}
@ %def queryServerRemainingDuration

\subsubsection{[[queryServerMaxLoad]](2)}
<<Query max load>>=
public int[] queryServerMaxLoad(int sid, int t) throws RuntimeException {
  return storage.DBQueryServerMaxLoad(sid, t);
}
@ %def queryServerMaxLoad

\section{Private Methods}
\label{sec:private-methods}

\subsection{[[Print]](1)}
<<[[Communicator]] private methods>>=
private void Print(String msg) {
  if (DEBUG) {
    System.out.println("[Jargo][Communicator]["+LocalDateTime.now()+"] "+msg);
  }
}
@ %def Print

\appendix

\section{Appendix: List of Chunks}
\label{ap:list-of-chunks}
\nowebchunks

\section{Appendix: List of Identifiers}
\label{ap:list-of-identifiers}
\nowebindex

\end{document}

