\documentclass{article}

\usepackage{noweb}
\noweboptions{smallcode,longchunks}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{colortbl}
\usepackage[colorlinks=true]{hyperref}
\usepackage{graphicx}

\newcommand{\hi}[1]{\noindent {\bf #1}}     % Define a handy paragraph opener

\def\nwendcode{\endtrivlist \endgroup}      % Remove noweb page break penalty
\let\nwdocspar=\par

\title{Jargo Communicator\footnote{
  \url{https://github.com/jargors/Communicator}}}
\author{James J. Pan\\
  \small{\href{mailto:pan-j16@mails.tsinghua.edu.cn}{pan-j16@mails.tsinghua.edu.cn}}}

\begin{document}
\maketitle
\pagestyle{noweb}

\tableofcontents

\section{Introduction}
\label{sec:introduction}
Jargo's communicator intends to be the sole way for Jargo clients to interact
with the Jargo simulated world (Figure~\ref{fig:interface-fig}). The
communicator exposes only the subset of Jargo's storage interface API that a
client would possibly have access to in the real world, including querying and
submitting server routes and schedules.  The communicator is developed using
the Noweb\footnote{\url{https://www.cs.tufts.edu/~nr/noweb/}} literate
programming\footnote{\url{http://literateprogramming.com/}} tool.  This file
([[src/Communicator.nw]]) is the source for the documentation
([[doc/Communicator.tex]]) and the Java code
([[Communicator.java]])\footnote{See the [[Makefile]] for build details.}.

\begin{figure}[h]
\centering
\includegraphics[width=150mm]{src/fig/interface-fig}
\caption{Communicator within the Jargo stack.}
\label{fig:interface-fig}
\end{figure}

\section{Implementation Overview}
\label{sec:implementation-overview}
<<Communicator.java>>=
  <<Communicator.java preamble>>
  <<[[Communicator]] definition>>
@

\subsection{Preamble}
\label{sec:preamble}
The preamble declares the package and imports dependencies.
<<Communicator.java preamble>>=
package com.github.jargors;
@
<<Communicator.java preamble>>=
import com.github.jargors.Storage;
import java.util.function.Supplier;
import java.time.LocalDateTime;
@

\subsection{Class Definition}
\label{sec:class-definition}
<<[[Communicator]] definition>>=
public class Communicator {
  <<[[Communicator]] member variables>>
  <<[[Communicator]] constructor>>
  <<[[Communicator]] public methods>>
  <<[[Communicator]] private methods>>
}
@

\subsection{Member Variables}
\label{sec:member-variables}
We define a [[Storage]] and a container for the simulation world time.
<<[[Communicator]] member variables>>=
private Storage storage;
private int world_time = 0;
@ %def storage world_time

\subsection{Constructor}
\label{sec:constructor}
<<[[Communicator]] constructor>>=
public Communicator() { }
@

\section{Public Methods}
\label{sec:public-methods}
\hi{General Methods.}
<<[[Communicator]] public methods>>=
<<Set storage>>
<<Set/get simulation world time>>
@
\hi{Write Methods.}
<<[[Communicator]] public methods>>=
<<Update server route>>
<<Update server add to schedule>>
<<Update server remove from schedule>>
@
\hi{Read Methods.}
<<[[Communicator]] public methods>>=
<<Query vertex>>
<<Query edge>>
<<Query ridesharing user>>
<<Query active server locations>>
<<Query routes>>
<<Query schedules>>
<<Query current load>>
@

\subsection{General Methods}
\label{sec:general-methods}

\subsubsection{[[setStorage]](1)}
<<Set storage>>=
public void setStorage(Storage src) {
  storage = src;
}
@ %def setStorage

\subsubsection{[[setSimulationWorldTime]](1)}
We depend on the controller to tell the simulation interface about the current
world time.
<<Set/get simulation world time>>=
public void setSimulationWorldTime(int t) {
  world_time = t;
}
@ %def setSimulationWorldTime

\subsubsection{[[getSimulationWorldTime]](0)}
<<Set/get simulation world time>>=
public int getSimulationWorldTime() {
  return world_time;
}
@ %def getSimulationWorldTime

\subsection{Write Methods}
\label{sec:write-methods}

\subsubsection{[[updateServerRoute]](3)}
<<Update server route>>=
public void updateServerRoute(int sid, int[] route, int[] sched) {
  storage.DBUpdateServerRoute(sid, route, sched);
}
@ %def updateServerRoute

\subsubsection{[[updateServerAddToSchedule]](4)}
<<Update server add to schedule>>=
public void updateServerAddToSchedule(
    int sid, int[] route, int[] sched, int[] rid) {
  storage.DBUpdateServerAddToSchedule(sid, route, sched, rid);
}
@ %def updateServerAddToSchedule

\subsubsection{[[updateServerRemoveFromSchedule]](4)}
<<Update server remove from schedule>>=
public void updateServerRemoveFromSchedule(
    int sid, int[] route, int[] sched, int[] rid) {
  storage.DBUpdateServerRemoveFromSchedule(sid, route, sched, rid);
}
@ %def updateServerRemoveFromSchedule

\subsection{Read Methods}
\label{sec:read-methods}

\subsubsection{[[queryVertex]](1)}
<<Query vertex>>=
public int[] queryVertex(int v) throws RuntimeException {
  return storage.DBQueryVertex(v);
}
@ %def queryVertex

\subsubsection{[[queryEdge]](2)}
<<Query edge>>=
public int[] queryEdge(int v1, int v2) throws RuntimeException {
  return storage.DBQueryEdge(v1, v2);
}
@ %def queryEdge

\subsubsection{[[queryServer]](1)}
<<Query ridesharing user>>=
public int[] queryServer(int sid) throws RuntimeException {
  return storage.DBQueryServer(sid);
}
@ %def queryServer

\subsubsection{[[queryRequest]](1)}
<<Query ridesharing user>>=
public int[] queryRequest(int rid) throws RuntimeException {
  return storage.DBQueryRequest(rid);
}
@ %def queryRequest

\subsubsection{[[queryServerLocationsActive]](1)}
<<Query active server locations>>=
public int[] queryServerLocationsActive(int t) throws RuntimeException {
  return storage.DBQueryServerLocationsActive(t);
}
@ %def queryServerLocationsActive

\subsubsection{[[queryRouteRemaining]](2)}
<<Query routes>>=
public int[] queryRouteRemaining(int sid, int t) throws RuntimeException {
  return storage.DBQueryRouteRemaining(sid, t);
}
@ %def queryRouteRemaining

\subsubsection{[[queryScheduleRemaining]](2)}
<<Query schedules>>=
public int[] queryScheduleRemaining(int sid, int t) throws RuntimeException {
  return storage.DBQueryScheduleRemaining(sid, t);
}
@ %def queryScheduleRemaining

\subsubsection{[[queryCurrentLoad]](2)}
<<Query current load>>=
public int[] queryCurrentLoad(int sid, int t) throws RuntimeException {
  return storage.DBQueryCurrentLoad(sid, t);
}
@ %def queryCurrentLoad

\section{Private Methods}
\label{sec:private-methods}

\subsection{[[Print]](1)}
<<[[Communicator]] private methods>>=
private void Print(String msg) {
  System.out.println("[Jargo][Communicator]["+LocalDateTime.now()+"] "+msg);
}
@ %def Print

\appendix

\section{Appendix: List of Chunks}
\label{ap:list-of-chunks}
\nowebchunks

\section{Appendix: List of Identifiers}
\label{ap:list-of-identifiers}
\nowebindex

\end{document}

