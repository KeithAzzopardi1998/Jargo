\chapter{Class: Communicator}
\label{communicator}

<<Communicator.java>>=
<<Communicator.java preamble>>
public class Communicator {
  <<[[Communicator]] member variables>>
  <<[[Communicator]] constructor>>
  <<[[Communicator]] methods>>
}
@

Jargo's communicator intends to be the sole way for Jargo clients to interact
with the Jargo simulated world. The communicator exposes only the subset of
Jargo's storage interface API that a client would possibly have access to in
the real world, including querying and submitting server routes and schedules.
The communicator also performs some \emph{input validation} on submitted routes
to prevent clients from overwriting historical traveled routes depending on
time of submission.

\begin{figure}
\adjustbox{scale=.8}{
\begin{minipage}[t]{0.6\textwidth}
\hi{Read Methods}
<<[[Communicator]] methods>>=
public <<Read: queryVertex(1)>>
public <<Read: queryEdge(2)>>
public <<Read: queryUser(1)>>
public <<Read: queryServerLocationsActive(1)>>
public <<Read: queryServerRemainingRoute(2)>>
public <<Read: queryServerRemainingSchedule(2)>>
public <<Read: queryServerRemainingDistance(2)>>
public <<Read: queryServerRemainingDuration(2)>>
public <<Read: queryServerMaxLoad(2)>>
@
\end{minipage}
\begin{minipage}[t]{0.6\textwidth}
\hi{Write Methods}
<<[[Communicator]] methods>>=
public <<Write: updateServerRoute(3)>>
public <<Write: updateServerAddToSchedule(4)>>
public <<Write: updateServerRemoveFromSchedule(4)>>
@
\hi{Utilities}
<<[[Communicator]] methods>>=
public <<registerStorage(1)>>
public <<registerController(1)>>
public <<forwardSimulationWorldTime(0)>>
public <<forwardReferenceVerticesCache(0)>>
public <<forwardReferenceEdgesCache(0)>>
public <<forwardReferenceUsersCache(0)>>
public <<forwardReturnRequest(1)>>
@
\end{minipage}
}
\caption{Communicator methods.}
\label{communicator:fig:methods}
\end{figure}

\section{Preamble}
The preamble declares the package and imports dependencies.
<<Communicator.java preamble>>=
package com.github.jargors;
@
<<Communicator.java preamble>>=
import com.github.jargors.Storage;
import com.github.jargors.Controller;
import com.github.jargors.exceptions.ClientException;
import com.github.jargors.exceptions.ClientFatalException;
import com.github.jargors.exceptions.DuplicateVertexException;
import com.github.jargors.exceptions.DuplicateEdgeException;
import com.github.jargors.exceptions.DuplicateUserException;
import com.github.jargors.exceptions.EdgeNotFoundException;
import com.github.jargors.exceptions.UserNotFoundException;
import com.github.jargors.exceptions.VertexNotFoundException;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.sql.SQLException;
@

\section{Member Variables}
<<[[Communicator]] member variables>>=
private Storage storage;
private Controller controller;
private final boolean DEBUG = "true".equals(System.getProperty("jargors.communicator.debug"));
@

\section{Constructor}
<<[[Communicator]] constructor>>=
public Communicator() { }
@

\section{Methods}

\subsection{\texttt{registerStorage}(1)}
<<registerStorage(1)>>=
void registerStorage(final Storage src) {
  this.storage = src;
}
@ %def setStorage

\subsection{\texttt{registerController}(1)}
<<registerController(1)>>=
void registerController(final Controller src) {
  this.controller = src;
}
@ %def setController


\subsection{\texttt{forwardSimulationWorldTime}(0)}
<<forwardSimulationWorldTime(0)>>=
int forwardSimulationWorldTime() {
  return this.controller.getSimulationWorldTime();
}
@ %def forwardSimulationWorldTime

\subsection{\texttt{forwardReferenceVerticesCache}(0)}
<<forwardReferenceVerticesCache(0)>>=
final ConcurrentHashMap<Integer, int[]> forwardReferenceVerticesCache() {
  return this.storage.getReferenceVerticesCache();
}
@ %def fowardReferenceVerticesCache

\subsection{\texttt{forwardReferenceEdgesCache}(0)}
<<forwardReferenceEdgesCache(0)>>=
final ConcurrentHashMap<Integer,
    ConcurrentHashMap<Integer, int[]>> forwardReferenceEdgesCache() {
  return this.storage.getReferenceEdgesCache();
}
@ %def forwardReferenceEdgesCache

\subsection{\texttt{forwardReferenceUsersCache}(0)}
<<forwardReferenceUsersCache(0)>>=
final ConcurrentHashMap<Integer, int[]> forwardReferenceUsersCache() {
  return this.storage.getReferenceUsersCache();
}
@ %def forwardReferenceUsersCache

\subsection{\texttt{forwardReturnRequest}(1)}
<<forwardReturnRequest(1)>>=
void forwardReturnRequest(final int rid) {
  this.controller.returnRequest(rid);
}
@ %def forwardReturnRequest




