\chapter{Class: Controller}
\label{controller}

<<Controller.java>>=
<<Controller.java preamble>>
public class Controller {
  <<[[Controller]] member variables>>
  <<[[Controller]] constructor>>
  <<[[Controller]] methods>>
}
@

The simulation controller is intended to be the sole interface for an
evaluation program to control Jargo's simulation environment. The controller
advances the simulation world time, ``pushes'' server locations and new
requests to the client, perturbs server routes stored in the data layer in
order to mimic traffic and other stochastic vehicle processes, and can be used
to report evaluation metrics to the program.  A listing of the methods is shown
in Figure~\ref{controller:fig:methods}.

\section{Preamble}
<<Controller.java preamble>>=
package com.github.jargors;
@
We import:
\begin{itemize}
\item all parts of the Jargo stack;
<<Controller.java preamble>>=
import com.github.jargors.Storage;
import com.github.jargors.Communicator;
import com.github.jargors.Client;
import com.github.jargors.Tools;
import com.github.jargors.exceptions.ClientException;
import com.github.jargors.exceptions.ClientFatalException;
import com.github.jargors.exceptions.DuplicateVertexException;
import com.github.jargors.exceptions.DuplicateEdgeException;
import com.github.jargors.exceptions.DuplicateUserException;
import com.github.jargors.exceptions.EdgeNotFoundException;
import com.github.jargors.exceptions.UserNotFoundException;
import com.github.jargors.exceptions.VertexNotFoundException;
import com.github.jargors.exceptions.GtreeNotLoadedException;
import com.github.jargors.exceptions.GtreeIllegalSourceException;
import com.github.jargors.exceptions.GtreeIllegalTargetException;
@ \item standard utilities for concurrent execution;
<<Controller.java preamble>>=
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
@ \item standard classes for file operations;
<<Controller.java preamble>>=
import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
@ \item standard map classes for caching various items.
<<Controller.java preamble>>=
import java.util.Map;
import java.util.HashMap;
@
<<Controller.java preamble>>=
import java.sql.SQLException;
@
\end{itemize}

\section{Member Variables}
Member variables are grouped into \emph{containers}, \emph{settings}, and
\emph{loops}.
<<[[Controller]] member variables>>=
<<Container objects>>
<<Settings objects>>
<<Loop objects>>
@
\hi{Containers.}
<<Container objects>>=
private Storage storage;
private Communicator communicator;
private Tools tools = new Tools();
private Client client;
private Map<Integer, Boolean> lu_seen = new HashMap<Integer, Boolean>();
@

\hi{Settings.} Settings objects configure various aspects of the simulation.
<<Settings objects>>=
private int CLOCK_START =
    Integer.parseInt(System.getProperty("jargors.controller.clock_start", "0"));
private int CLOCK_END =
    Integer.parseInt(System.getProperty("jargors.controller.clock_end", "1800"));
private int REQUEST_TIMEOUT =
    Integer.parseInt(System.getProperty("jargors.controller.request_timeout", "30"));
private int QUEUE_TIMEOUT =
    Integer.parseInt(System.getProperty("jargors.controller.queue_timeout", "30"));
private int REQUEST_COLLECTION_PERIOD =
    Integer.parseInt(System.getProperty("jargors.controller.request_collection_period", "1"));
private int REQUEST_HANDLING_PERIOD =
    Integer.parseInt(System.getProperty("jargors.controller.request_handling_period", "1"));
private int SERVER_COLLECTION_PERIOD =
    Integer.parseInt(System.getProperty("jargors.controller.server_collection_period", "1"));
@
The simulation world time is stored in [[clock_now]] and is upated by the
clock loop. The time advances in increments of 1 from [[CLOCK_START]]
to [[CLOCK_END]].
<<Settings objects>>=
private int clock_now = 0;
@
The [[loop_delay]] configures how many seconds to wait until the controller
loops start. The update periods configure how often particular loops should
execute, in seconds.
<<Settings objects>>=
private int loop_delay = 0;
// private int deviation_rate = 0.02;
// private int breakdown_rate = 0.005;
@
The [[CSHIFT]] setting configures the precision for longitude and latitude
coordiates (see [[Storage.DBInsertVertex]](3))\footnote{Beware, if [[CSHIFT]]
is changed here, it should also be changed in Tools.}.
<<Settings objects>>=
private final double CSHIFT = 10000000.0;
private boolean kill = false;
private boolean working = false;
private ScheduledExecutorService exe = null;
private ScheduledFuture<?> cb1 = null;
private ScheduledFuture<?> cb2 = null;
private ScheduledFuture<?> cb3 = null;
private ScheduledFuture<?> cb4 = null;
private ScheduledFuture<?> cb5 = null;
@
The [[DEBUG]] setting controls whether certain messages are print to screen.
Pass [[-Djargors.controller.debug=true]] to the [[java]] command to set
[[DEBUG]] to [[true]].
<<Settings objects>>=
private final boolean DEBUG =
    "true".equals(System.getProperty("jargors.controller.debug"));
@

\hi{Loops.} Jargo's simulation environment comprises four ``loops'', defined
here, running in parallel. They are executed using Java's
[[ScheduledExecutorService]] to control timing.
<<Loop objects>>=
<<Definition of clock loop>>
<<Definition of request collection loop>>
<<Definition of request handling loop>>
<<Definition of server collection loop>>
@

\subsection{Clock Loop}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Member \textcolor{blue}{[[ClockLoop]]} is a [[Runnable]] that does two things.
First it advances the simulation world time, and then it tells [[communicator]]
about the new time.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} increments [[clock_now]] by 1, may modify
[[communicator]] by changing [[Communicator.clock_now]], may print to
standard error if [[DEBUG]] is [[true]].\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Definition of clock loop>>=
private Runnable ClockLoop = () -> {
  // TODO: The speed of the updateServer.. methods is about 50ms, meaning we
  // can do ~20 updates per second. If a problem instance has more than 20
  // requests per second and an algo is fast enough to do more than 20 updates
  // per second, the updates will become the bottleneck. It might be unfair
  // to the algo if we advance the clock while waiting for updates to finish.
  // So in this case we only advance the clock after the updates finish.
  // How to implement? We just measure the time it takes to do an update and
  // add that duration onto the clock. We can output a "clock rate" to show
  // the user the current simulation rate, i.e. clock_rate=1x means real-time,
  // clock_rate=0.5x means 1 simulated second takes 2 real seconds, etc.
  ++(this.clock_now);
  if (DEBUG) {
    System.err.printf("[t=%d] Controller.ClockLoop says: %s!\n",
        this.clock_now, (this.clock_now % 2 == 0 ? "ping" : "pong"));
  }
};
@

\subsection{Request Collection Loop}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Member \textcolor{blue}{[[RequestCollectionLoop]]} is a [[Runnable]] that
collects requests eligible for assignment at the current world time.  A request
$r$ is ``eligible'' if it is not assigned at the current world time, and if the
world time is between the request's early time $r_\texttt{e}$ and
$(r_\texttt{e}+\texttt{REQUEST\_TIMEOUT})$ (see
[[Storage.DBQueryRequestsQueued]](1)). If the eligible requests cannot be
collected, we consider this failure to be fatal and exit immediately. A possible
reason may be database failure in [[storage]]. \\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} may modify [[client]] by adding objects into
[[Client.queue]], may put new entries or modify existing entries in
[[lu_seen]], may print to standard error if [[DEBUG]] is [[true]], or exits the JVM if
failure occurs.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Definition of request collection loop>>=
private Runnable RequestCollectionLoop = () -> {
  long A0 = 0;
  int  A1 = 0;
  if (DEBUG) {
    A0 = System.currentTimeMillis();
  }
  try {
    int[] output = this.storage.DBQueryRequestsQueued(this.clock_now);
    for (int i = 0; i < (output.length - 6); i += 7) {
      if (!this.lu_seen.containsKey(output[i]) || this.lu_seen.get(output[i]) == false) {
        this.client.addRequest(new int[] {
          output[(i + 0)],
          output[(i + 1)],
          output[(i + 2)],
          output[(i + 3)],
          output[(i + 4)],
          output[(i + 5)],
          output[(i + 6)] });
        this.lu_seen.put(output[i], true);
        if (DEBUG) {
          A1++;
        }
      }
    }
  } catch (SQLException e) {
    if (e.getErrorCode() == 40000) {
      System.err.println("Warning: database connection interrupted");
    } else {
      System.err.println("Encountered fatal error");
      System.err.println(e.toString());
      System.err.println(e.getErrorCode());
      e.printStackTrace();
      System.exit(1);
    }
  }
  if (DEBUG) {
    System.err.printf("Controller.RequestCollectionLoop collected %d requests in %d ms\n",
        A1, (System.currentTimeMillis() - A0));
  }
};
@

\subsection{Request Handling Loop}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Member \textcolor{blue}{[[RequestHandlingLoop]]} is a [[Runnable]] that
notifies the client algorithm to check for and process new requests.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} may indirectly modify the database underlying
[[storage]] depending on the body of [[Client.notifyNew]](0). May print to
standard error if a [[ClientException]] occurs or [[ClientFatalException]]
occurs or [[DEBUG]] is [[true]], or exits the JVM if [[ClientFatalException]]
occurs.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Definition of request handling loop>>=
private Runnable RequestHandlingLoop = () -> {
  long A0 = 0;
  int  A1 = 0;
  if (DEBUG) {
    A0 = System.currentTimeMillis();
    A1 = this.client.getQueueSize();
  }
  try {
    this.client.notifyNew();  // blocks this thread until queue is empty
  } catch (ClientException e) {
    System.err.printf("[t=%d] Controller.RequestHandlingLoop caught a ClientException: %s\n",
        this.clock_now, e.toString());
    e.printStackTrace();
  } catch (ClientFatalException e) {
    System.err.printf("[t=%d] Controller.RequestHandlingLoop caught a ClientFatalException: %s\n",
        this.clock_now, e.toString());
    e.printStackTrace();
    System.exit(1);
  }
  if (DEBUG) {
    System.err.printf("Controller.RequestHandlingLoop handled %d requests in %d ms\n",
        A1, (System.currentTimeMillis() - A0));
  }
};
@

\subsection{Server Loop}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Member \textcolor{blue}{[[ServerLoop]]} is a [[Runnable]] that collects
last-known locations of all active servers at the current word time.  A server
is ``active'' if its service has not ended, in other words it has not arrived
at its own destination.  The ``last-known location'' is the waypoint in the
server's route $w$ with a time component closest to but not exceeding the given
time, in other words ${w_{\leq t}}_{|w_{\leq t}|}$ (see
[[Storage.DBQueryServersLocationsActive]](1)).  If the last-known locations
cannot be collected, we consider this failure to be fatal and exit immediately.
A possible reason may be database failure in [[storage]]. \\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} may indirectly modify the database underlying
[[storage]] depending on the body of [[Client.collectServerLocations]](1).
May print to standard error if [[DEBUG]] is [[true]], or
exits the JVM if failure occurs.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Definition of server collection loop>>=
private Runnable ServerLoop = () -> {
  long A0 = 0;
  int  A1 = 0;
  if (DEBUG) {
    A0 = System.currentTimeMillis();
  }
  try {
    int[] output = this.storage.DBQueryServersLocationsActive(this.clock_now);
    if (DEBUG) {
      A1 = (output.length/3);
    }
    this.client.collectServerLocations(output);
  } catch (SQLException e) {
    if (e.getErrorCode() == 40000) {
      System.err.println("Warning: database connection interrupted");
    } else {
      System.err.println("Encountered fatal error");
      System.err.println(e.toString());
      System.err.println(e.getErrorCode());
      e.printStackTrace();
      System.exit(1);
    }
  }
  if (DEBUG) {
    System.err.printf("Controller.ServerLoop collected/handled %d in %d ms\n",
        A1, (System.currentTimeMillis() - A0));
  }
};
@

\section{Constructor}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Constructor \textcolor{blue}{[[Controller]]}(0) registers a new [[Storage]] to
the [[storage]] member variable. It also registers a new [[Communicator]] to
the [[communicator]] member variable. It then registers itself and the new
[[Storage]] to [[communicator]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} creates a new [[Storage]] and [[Communicator]] on the
memory heap, modifies [[storage]] and [[communicator]].\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<[[Controller]] constructor>>=
public Controller() {
  this.storage = new Storage();
  this.communicator = new Communicator();
  this.communicator.setRefStorage(this.storage);
  this.communicator.setRefController(this);
}
@

\section{Methods}

\subsection{\texttt{loadRoadNetworkFromFile}(1)}
<<loadRoadNetworkFromFile(1)>>=
void loadRoadNetworkFromFile(final String f_rnet) throws FileNotFoundException, SQLException {
  Scanner sc = new Scanner(new File(f_rnet));
  while (sc.hasNext()) {
@ %def loadRoadNetworkFromFile
{\small If a vertex identifier is $0$, then we store its coordinates as $(0,0)$. We
still call [[Scanner.nextDouble]](0) because we need to advance to the next
token.}
<<loadRoadNetworkFromFile(1)>>=
final int col0 = sc.nextInt();
final int col1 = sc.nextInt();
final int col2 = sc.nextInt();
final int col3 = (col1 == 0 ? (int) (0*sc.nextDouble()) : (int) Math.round(sc.nextDouble()*CSHIFT));
final int col4 = (col1 == 0 ? (int) (0*sc.nextDouble()) : (int) Math.round(sc.nextDouble()*CSHIFT));
final int col5 = (col2 == 0 ? (int) (0*sc.nextDouble()) : (int) Math.round(sc.nextDouble()*CSHIFT));
final int col6 = (col2 == 0 ? (int) (0*sc.nextDouble()) : (int) Math.round(sc.nextDouble()*CSHIFT));
@
{\small Now we insert the vertices into the database.}
<<loadRoadNetworkFromFile(1)>>=
try {
  this.storage.DBInsertVertex(col1, col3, col4);
} catch (DuplicateVertexException e) {
  if (DEBUG) {
    // System.err.println("Warning! Duplicate vertex ignored.");
  }
}
try {
  this.storage.DBInsertVertex(col2, col5, col6);
} catch (DuplicateVertexException e) {
  if (DEBUG) {
    // System.err.println("Warning! Duplicate vertex ignored.");
  }
}
@
{\small We use haversine to compute edge weights\footnote{If the distance between two
vertices is 0 due to rounding, then we round it up to 1.}.  If one of the
vertices in the edge is a dummy vertex, we set the weight to 0\footnote{The
dummy vertex should only terminate and never begin an edge in the road network,
otherwise a shortest path could take a shortcut through the dummy vertex to
reach any other vertex with 0 weight!}.}
<<loadRoadNetworkFromFile(1)>>=
final int dist = ((col1 != 0 && col2 != 0)
  ? this.tools.computeHaversine(
        col3/CSHIFT, col4/CSHIFT,
        col5/CSHIFT, col6/CSHIFT) : 0);
@
{\small The fifth parameter is the \textit{initial speed} on all the edges
\footnote{In the future, the speed on each edge may be recorded directly in the
road network file instead of hardcoded here.}.}
<<loadRoadNetworkFromFile(1)>>=
try {
  this.storage.DBInsertEdge(col1, col2, dist, 10);
} catch (DuplicateEdgeException e) {
  if (DEBUG) {
    // System.err.println("Warning! Duplicate edge ignored.");
  }
}
@
{\small Now we close the [[while]] loop and register the caches to Tools.}
<<loadRoadNetworkFromFile(1)>>=
  }
  this.tools.setRefCacheVertices(this.storage.getRefCacheVertices());
  this.tools.setRefCacheEdges(this.storage.getRefCacheEdges());
}
@

\subsection{\texttt{loadProblem(1)}}
<<loadProblem(1)>>=
void loadProblem(String p)
throws FileNotFoundException, DuplicateUserException, EdgeNotFoundException, SQLException,
       GtreeNotLoadedException, GtreeIllegalSourceException, GtreeIllegalTargetException {
  Scanner sc = new Scanner(new File(p));
  <<..skip header rows>>
  while (sc.hasNext()) {
    final int uid = sc.nextInt();
    final int  uo = sc.nextInt();
    final int  ud = sc.nextInt();
    final int  uq = sc.nextInt();
    final int  ue = sc.nextInt();
    final int  ul = sc.nextInt();
    final int  ub = this.tools.computeShortestPathDistance(uo, ud);
    if (uq < 0) {
      this.insertServer(new int[] { uid, uq, ue, ul, uo, ud, ub });
    } else {
      this.insertRequest(new int[] { uid, uq, ue, ul, uo, ud, ub });
    }
  }
}
@ %def loadProblem
<<..skip header rows>>=
for (int i = 0; i < 6; i++) {
  sc.nextLine();
}
@

\subsection{\texttt{startRealtime}(1)}
<<startRealtime(1)>>=
void startRealtime(final Consumer<Boolean> app_cb) {
  this.storage.setRequestTimeout(REQUEST_TIMEOUT);
  this.clock_now = CLOCK_START;

  int simulation_duration = (CLOCK_END - CLOCK_START);

  this.exe = Executors.newScheduledThreadPool(5);

  this.cb1 = exe.scheduleAtFixedRate(
    this.ClockLoop, 0, 1, TimeUnit.SECONDS);

  this.cb2 = exe.scheduleAtFixedRate(
    this.RequestCollectionLoop, this.loop_delay, REQUEST_COLLECTION_PERIOD, TimeUnit.SECONDS);

  this.cb3 = exe.scheduleAtFixedRate(
    this.RequestHandlingLoop, this.loop_delay, REQUEST_HANDLING_PERIOD, TimeUnit.MILLISECONDS);

  this.cb4 = exe.scheduleAtFixedRate(
    this.ServerLoop, this.loop_delay, SERVER_COLLECTION_PERIOD, TimeUnit.SECONDS);

  this.exe.schedule(() -> {
    this.stop(app_cb);
  }, simulation_duration, TimeUnit.SECONDS);
}
@ %def startRealtime

\subsection{\texttt{startSequential}(1)}
<<startSequential(1)>>=
void startSequential(final Consumer<Boolean> app_cb) {
  this.storage.setRequestTimeout(REQUEST_TIMEOUT);
  this.clock_now = CLOCK_START;
  while (!kill && this.clock_now < CLOCK_END) {
    this.working = true;
    this.ClockLoop.run();  // this.clock_now gets incremented here!
    this.ServerLoop.run();
    this.RequestCollectionLoop.run();
    this.RequestHandlingLoop.run();
    this.working = false;
  }
  this.stop(app_cb);
}
@ %def startSequential

\subsection{\texttt{stop}(1)}
<<stop(1)>>=
void stop(final Consumer<Boolean> app_cb) {
  if (this.exe == null) {  // sequential mode
    this.kill = true;
    while (this.working) {
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        // ...
      }
    }
  } else {  // realtime mode
    this.cb1.cancel(true);
    this.cb2.cancel(true);
    this.cb3.cancel(true);
    this.cb4.cancel(true);
    this.exe.shutdown();
  }
  try {
    if (this.client != null) {
      this.client.end();
    }
    app_cb.accept(true);
  } catch (Exception e) {
    System.err.println("Error in ending callback");
    System.err.println(e.toString());
    e.printStackTrace();
    return;
  }
}
@ %def stop

\subsection{\texttt{returnRequest}(1)}
<<returnRequest(1)>>=
void returnRequest(final int[] r) {
  if (this.clock_now - r[2] < QUEUE_TIMEOUT) {
    this.lu_seen.put(r[0], false);
  }
}
@ %def returnRequest

\subsection{\texttt{isKilled}(0)}
<<isKilled(0)>>=
final boolean isKilled() {
  return this.kill;
}
@ %def isKilled

