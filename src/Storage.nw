\chapter{Class: Storage}
\label{storage}

<<Storage.java>>=
<<Storage.java preamble>>
public class Storage {
  <<[[Storage]] member variables>>
  <<[[Storage]] constructor>>
  <<[[Storage]] methods>>
}
@

Jargo's storage interface is a data access layer for Jargo to record the
ground-truth state of ridesharing users (customers and vehicles) as they evolve
over time, and to query analytical metrics about the state.  The storage engine
is Apache Derby\footnote{\url{https://db.apache.org/derby}}, chosen for its
ability to defer table and column constraints until the end of a transaction.
This ability is needed during some write operations that may temporarily cause
the simulation to be in an invalid state. At all other times, Jargo's data
model guarantees the integrity of the simulation. The storage interface is
written in Java so it can communicate with Derby using JDBC. A listing of the
methods is shown in Figure~\ref{storage:fig:methods}.

\section{Preamble}
<<Storage.java preamble>>=
package com.github.jargors;
@
We import:
\begin{itemize}
\item various Jargo exceptions for exception handling;
<<Storage.java preamble>>=
import com.github.jargors.exceptions.DuplicateVertexException;
import com.github.jargors.exceptions.DuplicateEdgeException;
import com.github.jargors.exceptions.DuplicateUserException;
import com.github.jargors.exceptions.EdgeNotFoundException;
import com.github.jargors.exceptions.UserNotFoundException;
import com.github.jargors.exceptions.VertexNotFoundException;
import com.github.jargors.exceptions.TimeWindowException;
@ \item parts of the JDBC~API from [[java.sql]], for communication with Derby;
<<Storage.java preamble>>=
import java.sql.CallableStatement;   import java.sql.Connection;
import java.sql.DriverManager;       import java.sql.PreparedStatement;
import java.sql.ResultSet;           import java.sql.SQLException;
import java.sql.Statement;           import java.sql.Types;
@ \item Apache DBCP2 and Pool2, for connection pooling;
<<Storage.java preamble>>=
import org.apache.commons.dbcp2.ConnectionFactory;
import org.apache.commons.dbcp2.DriverManagerConnectionFactory;
import org.apache.commons.dbcp2.PoolableConnection;
import org.apache.commons.dbcp2.PoolableConnectionFactory;
import org.apache.commons.dbcp2.PoolingDriver;
import org.apache.commons.pool2.ObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
@ \item standard map classes for caching various items.
<<Storage.java preamble>>=
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
@ \item Management classes
<<Storage.java preamble>>=
import com.github.jargors.jmx.StorageMonitor;
import java.lang.management.*;
import javax.management.*;
@
\end{itemize}

\section{Member Variables}
The storage interface caches static data to avoid unnecessary database queries.
\begin{itemize}
\item The [[lu_rstatus]] map stores a boolean flag for each request indicating
whether the request is assigned or not. While the map elements are not static,
the elements do not change often. Guaranteeing consistency of the map is easy
because only [[Storage]] can update assignment changes to the database.
Whenever it successfully does an update, we simply update the map at the same
time.
<<[[Storage]] member variables>>=
private Map<Integer, Boolean> lu_rstatus = new HashMap<>();  //*
@
\item The other maps store static data values. References to these maps may be
held by other threads. To avoid accidental corruption due to concurrent access,
we use [[ConcurrentHashMap]].
<<[[Storage]] member variables>>=
private ConcurrentHashMap<String, String> lu_pstr     = new ConcurrentHashMap<String, String>();
private ConcurrentHashMap<Integer, int[]> lu_vertices = new ConcurrentHashMap<Integer, int[]>();
private ConcurrentHashMap<Integer,
    ConcurrentHashMap<Integer, int[]>>    lu_edges    = new ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>>();
private ConcurrentHashMap<Integer, int[]> lu_users    = new ConcurrentHashMap<Integer, int[]>();
private Map<Integer, Integer>             lu_lvt      = new HashMap<Integer, Integer>();
@
\end{itemize}

Cache some stats for metrics:
<<[[Storage]] member variables>>=
private int count_requests = 0;
private int count_assigned = 0;
private int sum_distance_unassigned = 0;
private int sum_distance_base_requests = 0;
private int sum_distance_base_servers = 0;
private Map<Integer, Integer> distance_servers = new HashMap<Integer, Integer>();
private Map<Integer, Integer> distance_servers_cruising = new HashMap<Integer, Integer>();
private Map<Integer, Integer> distance_requests_transit = new HashMap<Integer, Integer>();
private Map<Integer, Integer> duration_servers = new HashMap<Integer, Integer>();
private Map<Integer, Integer> duration_servers_cruising = new HashMap<Integer, Integer>();
private Map<Integer, Integer> duration_requests_transit = new HashMap<Integer, Integer>();
@

The storage interface also contains configuration settings and JDBC objects.
\begin{itemize}
\item Parameter
[[STATEMENTS_MAX_COUNT]] gives maximum number of simultaneous prepared
statements. Parameter [[REQUEST_TIMEOUT]] sets how long a client is allowed to
try to match a request, in other words if request $r$ is not assigned within
$\pi_\texttt{e}(r)+\texttt{REQUEST\_TIMEOUT}$, then it is not tried again.
The remaining parameters configure the Derby database connection.
<<[[Storage]] member variables>>=
private final int    STATEMENTS_MAX_COUNT   = 20;
private       int    REQUEST_TIMEOUT        = 30;
private       String CONNECTIONS_URL        = "jdbc:derby:memory:jargo;create=true";
private final String CONNECTIONS_DRIVER_URL = "jdbc:apache:commons:dbcp:";
private final String CONNECTIONS_POOL_NAME  = "jargo";
private final String CONNECTIONS_POOL_URL   = (CONNECTIONS_DRIVER_URL + CONNECTIONS_POOL_NAME);
public static final double CSHIFT           = 10000000.0;
@
\item The [[connection_factory]] is an object that returns new connections. The
[[poolableconnection_factory]] registers [[connection_factory]] and then can
return new poolable connections.  The [[pool]] is an object containing the
available poolable connections, and it is registered by the
[[poolableconnection_factory]]. The [[driver]] is the JDBC [[DriverManager]].
We get a reference to [[DriverManager]] in order to register the pool.
<<[[Storage]] member variables>>=
private ConnectionFactory               connection_factory;
private PoolableConnectionFactory       poolableconnection_factory;
private ObjectPool<PoolableConnection>  pool;
private PoolingDriver                   driver;
@
\end{itemize}

\section{Constructor}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Constructor \textcolor{blue}{[[Storage]]}(0) simply initializes the
prepared statement strings into [[lu_pstr]] by using [[JargoSetupPreparedStatements]](0).\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} adds entries into [[lu_pstr]].\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<[[Storage]] constructor>>=
public Storage() {
  this.JargoSetupPreparedStatements();
  <<[[Storage]] register JMX monitor>>
}
@

