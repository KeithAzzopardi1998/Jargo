\section{Administration}
\label{sim-administration}

These methods manage the classes, the simulation, and the database connections.

\etocsettocstyle{}{}
\localtableofcontents

\subsection{Packages}

The Jargo library has two packages:
\begin{itemize}
\item The [[sim]] package is for core classes.
<<Package: [[sim]]>>=
package com.github.jargors.sim;
@ \item The [[ui]] package is for the evaluators.
<<Package: [[ui]]>>=
package com.github.jargors.ui;
@
\end{itemize}

\subsection{Chunks}

These chunks perform some common ``atomic'' tasks used in multiple methods.

\subsubsection{Open \texttt{conn}}
<<Open [[conn]]>>=
Connection conn = DriverManager.getConnection(CONNECTIONS_POOL_URL)
@

\subsubsection{Set statement values}
<<Set statement values>>=
for (int i = 0; i < values.length; i++) {
  if (values[i] == null) {
    p.setNull((i + 1), java.sql.Types.INTEGER);
  } else {
    p.setInt ((i + 1), values[i]);
  }
}
@

\subsubsection{Cache server distance}
<<Cache server distance>>=
try (<<Open [[conn]]>>) {
  this.distance_servers.put(sid, this.PSQuery(conn, "S104", 1, sid)[0]);
} catch (SQLException e) {
  throw e;
}
@

\subsubsection{Cache cruising distance and duration}
<<Cache cruising distance and duration>>=
try (<<Open [[conn]]>>) {
  int sum = 0;
  int dur = 0;
  int[] output = this.PSQuery(conn, "S153", 2, sid);
  if (output.length > 0) {
    int ts = output[0];
    for (int i = 0; i < output.length - 1; i++) {
      final int t1 = output[(i + 0)];
      final int t2 = output[(i + 1)];
      sum += this.PSQuery(conn, "S154", 1, sid, t1, t2)[0];
      dur += (t2 - t1);
    }
    final int tt = this.PSQuery(conn, "S155", 1, sid)[0];
    final int te = this.PSQuery(conn, "S145", 2, sid)[0];
    sum += this.DBQueryServerDistanceRemaining(sid, tt)[0];
    dur += (te - tt);
    this.distance_servers_cruising.put(sid, sum);
    this.duration_servers_cruising.put(sid, dur);
    this.duration_servers.put(sid, (te - ts));
  } else {
    final int te = this.PSQuery(conn, "S145", 2, sid)[0];
    final int ts = this.PSQuery(conn, "S156", 2, sid)[0];
    sum = this.DBQueryServerDistanceRemaining(sid, ts)[0];
    this.distance_servers_cruising.put(sid, sum);
    this.duration_servers_cruising.put(sid, (te - ts));
    this.duration_servers.put(sid, (te - ts));
  }
} catch (SQLException e) {
  throw e;
}
@

\subsubsection{Cache request transit distance and duration}
<<Cache request transit distance and duration>>=
try (<<Open [[conn]]>>) {
  this.distance_requests_transit.put(r, this.DBQueryRequestDistanceTransit(r, false)[0]);
  this.duration_requests_transit.put(r, this.DBQueryRequestDurationTransit(r, false)[0]);
  this.duration_requests_travel .put(r, this.DBQueryRequestDurationTravel (r, false)[0]);
  this.duration_requests_pickup .put(r, this.DBQueryRequestDurationPickup (r, false)[0]);
} catch (SQLException e) {
  throw e;
}
@

\subsubsection{Construct exception}
<<Construct empty exception>>=
() { }
@

<<Construct message exception>>=
(String message) { super(message); }
@

<<Construct cause exception>>=
(Throwable cause) { super(cause); }
@

<<Construct message and cause exception>>=
(String message, Throwable cause) { super(message, cause); }
@

\subsection{Methods: Administration}

\subsubsection{\jsMethodName{JargoInstanceNew}{0}}
\begin{jsMethod}{Creates a new database instance.}
{None.}
{Nothing.}
{Assigns new objects to [[connection_factory]], [[poolableconnection_factory]],
[[pool]], [[driver]].}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
    \jsErr{ClassNotFoundException}{if Derby driver cannot be loaded}
  \end{itemize}
}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsWrap{instanceNew}{0}
  \end{itemize}
}
\end{jsMethod}

<<Admin: JargoInstanceNew(0)>>=
void JargoInstanceNew() throws SQLException {
  try {
    this.JargoSetupDriver();
  } catch (SQLException e) {
    throw e;
  } catch (ClassNotFoundException e) {
    System.err.println("Fatal exception");
    e.printStackTrace();
    System.exit(1);
  }
}
@ %def JargoInstanceNew

<<Admin: instanceNew(0)>>=
void instanceNew() throws SQLException {
  this.storage.JargoInstanceNew();
}
@ %def instanceNew

$\square$

\subsubsection{\jsMethodName{JargoInstanceInitialize}{0}}
\begin{jsMethod}{Creates the Jargo schema into the existing instance.}
{None.}
{Nothing.}
{Modifies the database.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsWrap{instanceInitialize}{0}
  \end{itemize}
}
\end{jsMethod}

<<Admin: JargoInstanceInitialize(0)>>=
void JargoInstanceInitialize() {
  try (<<Open [[conn]]>>) {
    Statement stmt = conn.createStatement();
    stmt.clearBatch();
    stmt.addBatch(<<Create Table V statement>>);
    stmt.addBatch(<<Create Table E statement>>);
    stmt.addBatch(<<Create Table UQ statement>>);
    stmt.addBatch(<<Create Table UE statement>>);
    stmt.addBatch(<<Create Table UL statement>>);
    stmt.addBatch(<<Create Table UO statement>>);
    stmt.addBatch(<<Create Table UD statement>>);
    stmt.addBatch(<<Create Table UB statement>>);
    stmt.addBatch(<<Create Table S statement>>);
    stmt.addBatch(<<Create Table R statement>>);
    stmt.addBatch(<<Create Table W statement>>);
    stmt.addBatch(<<Create Table PD statement>>);
    stmt.addBatch(<<Create Table CW statement>>);
    stmt.addBatch(<<Create Table CPD statement>>);
    stmt.addBatch(<<Create Table CQ statement>>);
    stmt.addBatch(<<Create View r\_user statement>>);
    stmt.addBatch(<<Create View r\_server statement>>);
    stmt.addBatch(<<Create View f\_distance\_blocks statement>>);
    stmt.addBatch(<<Create View f\_status statement (Eq.~\ref{eq:status})>>);
    stmt.addBatch(<<Create View assignments statement (Eq.~\ref{eq:assignments})>>);
    stmt.addBatch(<<Create View assignments\_r statement (Eq.~\ref{eq:assigned-requests})>>);
    stmt.addBatch(<<Create View service\_rate statement (Eq.~\ref{eq:service-rate})>>);
    stmt.addBatch(<<Create View dist\_base statement (Eq.~\ref{eq:base-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_travel statement>>);
    stmt.addBatch(<<Create View dist\_s\_cruising statement (Eq.~\ref{eq:cruising-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_service statement (Eq.~\ref{eq:service-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_base statement>>);
    stmt.addBatch(<<Create View dist\_r\_base statement>>);
    stmt.addBatch(<<Create View dist\_r\_unassigned statement>>);
    stmt.addBatch(<<Create View dist\_r\_transit statement (Eq.~\ref{eq:transit-distance})>>);
    stmt.addBatch(<<Create View dist\_r\_detour statement (Eq.~\ref{eq:detour-distance})>>);
    stmt.addBatch(<<Create View dur\_s\_travel statement>>);
    stmt.addBatch(<<Create View dur\_s\_service statement>>);
    stmt.addBatch(<<Create View dur\_r\_pickup statement (Eq.~\ref{eq:pick-up delay})>>);
    stmt.addBatch(<<Create View dur\_r\_transit statement (Eq.~\ref{eq:transit-duration})>>);
    stmt.addBatch(<<Create View dur\_r\_travel statement (Eq.~\ref{eq:travel-duration})>>);
    stmt.addBatch(<<Create View t\_r\_depart statement (Eq.~\ref{eq:departure-time})>>);
    stmt.addBatch(<<Create View t\_s\_depart statement (Eq.~\ref{eq:departure-time})>>);
    stmt.addBatch(<<Create View t\_r\_arrive statement (Eq.~\ref{eq:arrival-time})>>);
    stmt.addBatch(<<Create View t\_s\_arrive statement (Eq.~\ref{eq:arrival-time})>>);
    stmt.addBatch(<<Create View violations\_t\_s>>);
    stmt.addBatch(<<Create View violations\_t\_r>>);
    stmt.addBatch("CREATE INDEX R_re ON R (re)");
    stmt.addBatch("CREATE INDEX W_sid_t1 ON W (sid, t1)");
    stmt.addBatch("CREATE INDEX W_sid_t2 ON W (sid, t2)");
    stmt.addBatch("CREATE INDEX W_sid_v2 ON W (sid, v2)");
    stmt.addBatch("CREATE INDEX W_sid_t1_t2 ON W (sid, t1, t2)");
    stmt.addBatch("CREATE INDEX CQ_sid_t2_o2 ON CQ (sid, t2, o2)");
    stmt.addBatch("CREATE INDEX CQ_sid_t2_q2 ON CQ (sid, t2 DESC, q2 DESC)");
    stmt.executeBatch();
    conn.commit();
  } catch (SQLException e) {
    System.err.println("Fatal error.");
    if (e.getErrorCode() == 0) {
      System.err.println("(did you forget to call Storage.JargoInstanceNew()?)");
    } else if (e.getErrorCode() == 20000) {
      System.err.println("(data model already exists from Storage.JargoInstanceLoad()?)");
    }
    e.printStackTrace(System.err);
    System.exit(1);
  }
}
@ %def JargoInstanceInitialize

<<Admin: instanceInitialize(0)>>=
void instanceInitialize() {
  this.storage.JargoInstanceInitialize();
}
@ %def instanceInitialize

$\square$

\subsubsection{\jsMethodName{JargoInstanceLoad}{1}}
\begin{jsMethod}{Loads an on-disk database into memory.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsArg{String}{p}{Path to database.}
  \end{itemize}
}
{Nothing.}
{Modifies the in-memory database.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
    \jsErr{ClassNotFoundException}{if Derby driver cannot be loaded}
  \end{itemize}
}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsWrap{instanceLoad}{1}
  \end{itemize}
}
\end{jsMethod}

<<Admin: JargoInstanceLoad(1)>>=
void JargoInstanceLoad(final String p) throws SQLException {
  this.CONNECTIONS_URL = "jdbc:derby:memory:jargo;createFrom="+p;
  try {
    this.JargoSetupDriver();
  } catch (ClassNotFoundException e) {
    System.out.println("Fatal error.");
    e.printStackTrace();
    System.exit(1);
  }
}
@ %def JargoInstanceLoad

<<Admin: instanceLoad(1)>>=
void instanceLoad(final String p) throws SQLException {
  this.storage.JargoInstanceLoad(p);
}
@ %def instanceLoad

\subsubsection{\jsMethodName{JargoInstanceExport}{1}}
\begin{jsMethod}{Exports the in-memory database to disk.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsArg{String}{p}{path to the export.}
  \end{itemize}
}
{Nothing.}
{Modifies the disk.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsWrap{instanceExport}{1}
  \end{itemize}
}
\end{jsMethod}

<<Admin: JargoInstanceExport(1)>>=
void JargoInstanceExport(final String p) throws SQLException {
  try (<<Open [[conn]]>>) {
    CallableStatement cs = conn.prepareCall("CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE('"+p+"')");
    cs.execute();
  } catch (SQLException e) {
    throw e;
  }
}
@ %def JargoInstanceExport

<<Admin: instanceExport(1)>>=
void instanceExport(final String p) throws SQLException {
  this.storage.JargoInstanceExport(p);
}
@ %def instanceExport

\subsubsection{\jsMethodName{JargoInstanceClose}{0}}
\begin{jsMethod}{Closes the database instance.}
{None.}
{Nothing.}
{Drops the database connection and clears many data structures (see source).}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{code 45000 on success, some other error code otherwise}
  \end{itemize}
}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsWrap{instanceClose}{0}
  \end{itemize}
}
\end{jsMethod}

<<Admin: JargoInstanceClose(0)>>=
void JargoInstanceClose() throws SQLException {
  try {
    DriverManager.getConnection("jdbc:derby:memory:jargo;drop=true");
  } catch (SQLException e) {
    if (e.getErrorCode() != 45000) {
      throw e;
    } else {
      this.lu_rstatus.clear();
      this.lu_vertices.clear();
      this.lu_edges.clear();
      this.lu_users.clear();
      this.lu_lvt.clear();
      this.count_requests = 0;
      this.count_assigned = 0;
      this.sum_distance_unassigned = 0;
      this.sum_distance_base_requests = 0;
      this.sum_distance_base_servers = 0;
      this.distance_servers.clear();
      this.distance_servers_cruising.clear();
      this.distance_requests_transit.clear();
      this.duration_servers.clear();
      this.duration_servers_cruising.clear();
      this.duration_requests_transit.clear();
      this.duration_requests_travel.clear();
      this.duration_requests_pickup.clear();
      this.connection_factory = null;
      this.poolableconnection_factory = null;
      this.pool = null;
      this.driver = null;
    }
  }
}
@ %def JargoInstanceClose

<<Admin: instanceClose(0)>>=
void instanceClose() throws SQLException {
  this.storage.JargoInstanceClose();
}
@ %def instanceClose

\subsubsection{\jsMethodName{JargoCacheRoadNetworkFromDB}{0}}
\begin{jsMethod}{Loads in-memory vertex and edge caches from the V and E
database tables.}
{None.}
{Nothing.}
{Modifies [[lu_vertices]] and [[lu_edges]].}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsWrap{cacheRoadNetworkFromDB}{0}
  \end{itemize}
}
\end{jsMethod}

<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
void JargoCacheRoadNetworkFromDB() throws SQLException {
@ %def JargoCacheRoadNetworkFromDB
{\small Our approach is to create two temporary maps on the heap, populate the
temporary maps, then assign [[lu_vertices]] and [[lu_edges]] to reference the
temporary maps if all succeeds. This way we don't corrupt [[lu_vertices]] and
[[lu_edges]] in case of failure. (The approach might be overly cautious as it's
hard to imagine why this method would ever be called if the caches are already
populated.)}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
  ConcurrentHashMap<Integer, int[]>    lu1 =
      new ConcurrentHashMap<Integer, int[]>();
  ConcurrentHashMap<Integer,
    ConcurrentHashMap<Integer, int[]>> lu2 =
      new ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>>();
@
{\small We start by querying the vertices.}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
  try {
    final int[] output = this.DBQueryVertices();
    for (int i = 0; i < (output.length - 2); i += 3) {
      final int   v = output[(i + 0)];
      final int lng = output[(i + 1)];
      final int lat = output[(i + 2)];
      lu1.put(v, new int[] { lng, lat });
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Then we go on to query the edges.}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
  try {
    final int[] output = this.DBQueryEdges();
    for (int i = 0; i < (output.length - 3); i += 4) {
      final int v1 = output[(i + 0)];
      final int v2 = output[(i + 1)];
      final int dd = output[(i + 2)];
      final int nu = output[(i + 3)];
      if (!lu2.containsKey(v1)) {
        lu2.put(v1, new ConcurrentHashMap<Integer, int[]>());
      }
      lu2.get(v1).put(v2, new int[] { dd, nu });
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Finally we do the assignment.}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
  this.lu_vertices = lu1;
  this.lu_edges    = lu2;
}
@

<<Admin: cacheRoadNetworkFromDB(0)>>=
void cacheRoadNetworkFromDB() throws SQLException {
  this.storage.JargoCacheRoadNetworkFromDB();
}
@ %def cacheRoadNetworkFromDB

\subsubsection{\jsMethodName{JargoCacheUsersFromDB}{0}}
\begin{jsMethod}{Load in-memory user caches from the S and R database tables.}
{None.}
{Nothing.}
{Modifies [[lu_users]] and [[lu_rstatus]].}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsWrap{cacheUsersFromDB}{0}
  \end{itemize}
}
\end{jsMethod}

<<Admin: JargoCacheUsersFromDB(0)>>=
void JargoCacheUsersFromDB() throws SQLException {
@ %def JargoCacheUsersFromDB
{\small Our approach follows the approach for [[JargoCacheRoadNetworkFromDB]](0).
We start by creating two temporary maps on the heap.}
<<Admin: JargoCacheUsersFromDB(0)>>=
  ConcurrentHashMap<Integer, int[]> lu1 = new ConcurrentHashMap<Integer, int[]>();
  Map<Integer, Boolean>             lu2 = new HashMap<Integer, Boolean>();
  Map<Integer, Integer>             lu3 = new HashMap<Integer, Integer>();
@
{\small Then we query the users.}
<<Admin: JargoCacheUsersFromDB(0)>>=
  try {
    final int[] output = this.DBQueryUsers();
    for (int i = 0; i < (output.length - 6); i += 7) {
      final int uid = output[(i + 0)];
      final int  uq = output[(i + 1)];
      final int  ue = output[(i + 2)];
      final int  ul = output[(i + 3)];
      final int  uo = output[(i + 4)];
      final int  ud = output[(i + 5)];
      final int  ub = output[(i + 6)];
      lu1.put(uid, new int[] { uid, uq, ue, ul, uo, ud, ub });
@
{\small If the user is a request, in other words the user load is positive,
we query the request's assignment status. Else, we initialize the last-visitation time.}
<<Admin: JargoCacheUsersFromDB(0)>>=
      if (uq > 0) {
        lu2.put(uid, (this.DBQueryRequestIsAssigned(uid, false).length > 0 ? true : false));
      } else {
        lu3.put(uid, 0);
      }
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Finally we do the assignment and populate some counters.}
<<Admin: JargoCacheUsersFromDB(0)>>=
  this.lu_users   = lu1;
  this.lu_rstatus = lu2;
  this.lu_lvt     = lu3;
  for (Integer uid : this.lu_users.keySet()) {
    final int[] u = this.lu_users.get(uid);
    if (u[1] > 0) {
      this.count_requests++;
      this.sum_distance_unassigned += u[6];
      this.sum_distance_base_requests += u[6];
    } else {
      final int sid = uid;
      <<Cache server distance>>
      <<Cache cruising distance and duration>>
      this.sum_distance_base_servers += u[6];
    }
  }
  for (Integer rid : this.lu_rstatus.keySet()) {
    final boolean flag = this.lu_rstatus.get(rid);
    if (flag == true) {
      this.count_assigned++;
      this.sum_distance_unassigned -= this.lu_users.get(rid)[6];
      int r = rid;
      try {
        int sid = this.DBQueryRequestIsAssigned(rid, false)[0];
        <<Cache request transit distance and duration>>
      } catch (SQLException e) {
        throw e;
      }
    }
  }
}
@

<<Admin: cacheUsersFromDB(0)>>=
void cacheUsersFromDB() throws SQLException {
  this.storage.JargoCacheUsersFromDB();
}
@ %def cacheUsersFromDB

\subsubsection{\jsMethodName{JargoSetupDriver}{0}}
\begin{jsMethod}{Sets up a new database connection.}
{None.}
{Nothing.}
{Assigns new objects to [[connection_factory]], [[poolableconnection_factory]],
[[pool]], [[driver]].}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
    \jsErr{ClassNotFoundException}{if Derby driver cannot be loaded}
  \end{itemize}
}
{None.}
\end{jsMethod}

<<Admin: JargoSetupDriver(0)>>=
void JargoSetupDriver() throws SQLException, ClassNotFoundException {
  connection_factory = new DriverManagerConnectionFactory(CONNECTIONS_URL);
  poolableconnection_factory = new PoolableConnectionFactory(connection_factory, null);
  poolableconnection_factory.setPoolStatements(true);
  poolableconnection_factory.setDefaultAutoCommit(false);
  poolableconnection_factory.setMaxOpenPreparedStatements(STATEMENTS_MAX_COUNT);
  poolableconnection_factory.setDefaultTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
  GenericObjectPoolConfig<PoolableConnection> cfg = new GenericObjectPoolConfig<PoolableConnection>();
  cfg.setMinIdle(100000);
  cfg.setMaxIdle(100000);
  cfg.setMaxTotal(100000);
  pool = new GenericObjectPool<PoolableConnection>(poolableconnection_factory, cfg);
  poolableconnection_factory.setPool(pool);
  Class.forName("org.apache.commons.dbcp2.PoolingDriver");
  driver = (PoolingDriver) DriverManager.getDriver(CONNECTIONS_DRIVER_URL);
  driver.registerPool(CONNECTIONS_POOL_NAME, pool);
}
@ %def JargoSetupDriver

\subsubsection{\jsMethodName{JargoSetupPreparedStatements}{0}}
\begin{jsMethod}{Initialize the statement cache.}
{None.}
{Nothing.}
{Modifies [[lu_pstr]].}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{None.}
\end{jsMethod}

<<Admin: JargoSetupPreparedStatements(0)>>=
void JargoSetupPreparedStatements() {
  final String INS = "INSERT INTO ";
  final String UPD = "UPDATE ";
  final String DEL = "DELETE FROM ";
  final String SEL = "SELECT ";
  final String q2  = "(?,?)";
  final String q3  = "(?,?,?)";
  final String q4  = "(?,?,?,?)";
  final String q7  = "(?,?,?,?,?,?,?)";
  final String q8  = "(?,?,?,?,?,?,?,?)";
  final String q9  = "(?,?,?,?,?,?,?,?,?)";
  final String q12 = "(?,?,?,?,?,?,?,?,?,?,?,?)";
  final String q14 = "(?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
  <<S0>>
  <<S1>>
  <<S2>>
  <<S3>>
  <<S4>>
  <<S5>>
  <<S6>>
  <<S7>>
  <<S8>>
  <<S9>>
  <<S10>>
  <<S11>>
  <<S12>>
  <<S13>>
  <<S14>>
  <<S15>>
  <<S42>>
  <<S43>>
  <<S51>>
  <<S59>>
  <<S60>>
  <<S61>>
  <<S62>>
  <<S63>>
  <<S64>>
  <<S65>>
  <<S66>>
  <<S67>>
  <<S73>>
  <<S76>>
  <<S77>>
  <<S80>>
  <<S82>>
  <<S83>>
  <<S84>>
  <<S86>>
  <<S87>>
  <<S100>>
  <<S101>>
  <<S102>>
  <<S103>>
  <<S104>>
  <<S105>>
  <<S106>>
  <<S107>>
  <<S108>>
  <<S109>>
  <<S110>>
  <<S111>>
  <<S112>>
  <<S113>>
  <<S114>>
  <<S115>>
  <<S116>>
  <<S117>>
  <<S118>>
  <<S119>>
  <<S120>>
  <<S121>>
  <<S122>>
  <<S123>>
  <<S124>>
  <<S125>>
  <<S127>>
  <<S128>>
  <<S129>>
  <<S131>>
  <<S133>>
  <<S134>>
  <<S135>>
  <<S136>>
  <<S137>>
  <<S138>>
  <<S139>>
  <<S140>>
  <<S141>>
  <<S142>>
  <<S143>>
  <<S144>>
  <<S145>>
  <<S147>>
  <<S148>>
  <<S150>>
  <<S151>>
  <<S152>>
  <<S153>>
  <<S154>>
  <<S155>>
  <<S156>>
  <<S157>>
  <<S158>>
  <<S160>>
  <<S161>>
  <<S162>>
  <<S163>>
}
@ %def JargoSetupPreparedStatements
<<S0>>=
this.lu_pstr.put("S0", INS+"V VALUES "+q3);
@ %def S0
<<S1>>=
this.lu_pstr.put("S1", INS+"E VALUES "+q4);
@ %def S1
<<S2>>=
this.lu_pstr.put("S2", INS+"UQ VALUES "+q2);
@ %def S2
<<S3>>=
this.lu_pstr.put("S3", INS+"UE VALUES "+q2);
@ %def S3
<<S4>>=
this.lu_pstr.put("S4", INS+"UL VALUES "+q2);
@ %def S4
<<S5>>=
this.lu_pstr.put("S5", INS+"UO VALUES "+q2);
@ %def S5
<<S6>>=
this.lu_pstr.put("S6", INS+"UD VALUES "+q2);
@ %def S6
<<S7>>=
this.lu_pstr.put("S7", INS+"UB VALUES "+q2);
@ %def S7
<<S8>>=
this.lu_pstr.put("S8", INS+"S VALUES "+q7);
@ %def S8
<<S9>>=
this.lu_pstr.put("S9", INS+"R VALUES "+q7);
@ %def S9
<<S10>>=
this.lu_pstr.put("S10", INS+"W VALUES "+q8);
@ %def S10
<<S70>>=
this.lu_pstr.put("S70", SEL+"sid, sq, se, sl, so, sd, sb FROM S WHERE sid=?");
@ %def S70
<<S11>>=
this.lu_pstr.put("S11", INS+"CW VALUES "+q9);
@ %def S11
<<S12>>=
this.lu_pstr.put("S12", INS+"PD VALUES "+q4);
@ %def S12
<<S13>>=
this.lu_pstr.put("S13", INS+"CPD VALUES "+q12);
@ %def S13
<<S14>>=
this.lu_pstr.put("S14", INS+"CQ VALUES "+q14);
@ %def S14
<<S15>>=
this.lu_pstr.put("S15", UPD+"E SET nu=? WHERE v1=? AND v2=?");
@ %def S15
<<S131>>=
this.lu_pstr.put("S131", UPD+"W SET nu=? WHERE v1=? AND v2=?");
@ %def S131
<<S77>>=
this.lu_pstr.put("S77", UPD+"CW SET te=?, ve=? WHERE sid=?");
@ %def S77
<<S84>>=
this.lu_pstr.put("S84", UPD+"PD SET t2=? WHERE v2=? AND rid=?");
@ %def S84
<<S82>>=
this.lu_pstr.put("S82", UPD+"CPD SET tp=? WHERE vp=? AND rid=?");
@ %def S82
<<S83>>=
this.lu_pstr.put("S83", UPD+"CPD SET td=? WHERE vd=? AND rid=?");
@ %def S83
<<S76>>=
this.lu_pstr.put("S76", DEL+"W WHERE sid=? AND t2>?");
@ %def S76
<<S42>>=
this.lu_pstr.put("S42", DEL+"PD WHERE rid=?");
@ %def S42
<<S43>>=
this.lu_pstr.put("S43", DEL+"CPD WHERE rid=?");
@ %def S43
<<S80>>=
this.lu_pstr.put("S80", DEL+"CQ WHERE sid=? AND t2>?");
@ %def S80
<<S62>>=
this.lu_pstr.put("S62", SEL+"COUNT (*) FROM V WHERE v<>0");
@ %def S62
<<S64>>=
this.lu_pstr.put("S64", SEL+"MIN (lng), MAX (lng), MIN (lat), MAX (lat) "
      + "FROM V WHERE v<>0");
@ %def S64
<<S63>>=
this.lu_pstr.put("S63", SEL+"COUNT (*) FROM E WHERE v1<>0 AND v2<>0");
@ %def S63
<<S65>>=
this.lu_pstr.put("S65", SEL+"MIN (dd), MAX (dd), SUM (dd) / COUNT (dd), "
      + "MIN (nu), MAX (nu), SUM (nu) / COUNT (nu) "
      + "FROM E WHERE v1<>0 AND v2<>0");
@ %def S65
<<S46>>=
this.lu_pstr.put("S46", SEL+"dd, nu FROM E WHERE v1=? AND v2=?");
@ %def S46
<<S130>>=
this.lu_pstr.put("S130", SEL+"lng, lat FROM V WHERE v=?");
@ %def S130
<<S48>>=
this.lu_pstr.put("S48", SEL+"sq, se FROM S WHERE sid=?");
@ %def S48
<<S66>>=
this.lu_pstr.put("S66", SEL+"COUNT (*) FROM S");
@ %def S66
<<S75>>=
this.lu_pstr.put("S75", SEL+"rid, rq, re, rl, ro, rd, rb FROM R WHERE rid=?");
@ %def S75
<<S51>>=
this.lu_pstr.put("S51", SEL+"rq, re, rl, ro, rd FROM R WHERE rid=?");
@ %def S51
<<S67>>=
this.lu_pstr.put("S67", SEL+"COUNT (*) FROM R");
@ %def S67
<<S59>>=
this.lu_pstr.put("S59", SEL+"a.sid, a.t2, a.v2 FROM W AS a INNER JOIN ("
      + "SELECT sid, MIN(ABS(t2-?)) as tdiff FROM W WHERE t2<=? AND v2<>0 "
      + "GROUP BY sid"
      + ") as b ON a.sid=b.sid AND ABS(a.t2-?)=b.tdiff AND a.t2<=?");
@ %def S59
<<S128>>=
this.lu_pstr.put("S128", SEL+"a.sid, a.t2, a.v2 FROM W AS a INNER JOIN ("
      + "SELECT sid FROM CW WHERE te>? OR (ve=0 AND sl>?)"
      + ") as b ON a.sid=b.sid INNER JOIN ("
      + "SELECT sid, MIN(ABS(t2-?)) as tdiff FROM W WHERE t2<=? AND v2<>0 "
      + "GROUP BY sid"
      + ") as c ON a.sid=c.sid AND ABS(a.t2-?)=c.tdiff AND a.t2<=?");
@ %def S128
<<S60>>=
this.lu_pstr.put("S60", SEL+"DISTINCT t, v FROM r_server WHERE sid=? ORDER BY t ASC");
@ %def S60
<<S129>>=
this.lu_pstr.put("S129", SEL+"t, v FROM r_server WHERE sid=? AND t>? ORDER BY t ASC");
@ %def S129
<<S61>>=
this.lu_pstr.put("S61", SEL+"t, v, Ls, Lr FROM r_server "
      + "LEFT JOIN CQ ON t=t2 and lr=rid WHERE r_server.sid=?"
      + "AND (Ls IS NOT NULL OR Lr IS NOT NULL) ORDER BY t, o2 ASC");
@ %def S61
Need to join CQ in order to sort by order number [[o2]]. This query has
worse performance after W (r\_server), CQ, PD grow.
<<S69>>=
this.lu_pstr.put("S69", SEL+"t, v, Ls, Lr "
      + "FROM r_server LEFT JOIN CQ ON t=t2 and v=v2 and Lr=rid "
      + "WHERE r_server.sid=?"
      + "   AND (t>? OR v=0)"
      + "   AND (Ls IS NOT NULL OR Lr IS NOT NULL)"
      + "ORDER BY t ASC, o2 ASC");
@ %def S69
<<S85>>=
this.lu_pstr.put("S85", SEL+"uq FROM UQ WHERE uid=?");
@ %def S85
<<S86>>=
this.lu_pstr.put("S86", SEL+"tp, td FROM CPD WHERE rid=?");
@ %def S86
<<S73>>=
this.lu_pstr.put("S73", SEL+"q2 FROM CQ WHERE sid=? AND t2<=? "
      + "ORDER BY t2 DESC, q2 DESC FETCH FIRST ROW ONLY");
@ %def S73
<<S87>>=
this.lu_pstr.put("S87", SEL+"t2, q2, o2 FROM CQ WHERE sid=? AND t2<=? "
      + "ORDER BY t2 DESC, o2 DESC FETCH FIRST ROW ONLY");
@ %def S87
<<S100>>=
this.lu_pstr.put("S100", SEL+"rid FROM assignments WHERE t>? AND sid=?");
@ %def S100
<<S101>>=
this.lu_pstr.put("S101", SEL+"rid FROM assignments WHERE t<=? AND sid=?");
@ %def S101
<<S102>>=
this.lu_pstr.put("S102", SEL+"* FROM service_rate");
@ %def S102
<<S103>>=
this.lu_pstr.put("S103", SEL+"* FROM dist_base");
@ %def S103
<<S104>>=
this.lu_pstr.put("S104", SEL+"val FROM dist_s_travel WHERE sid=?");
@ %def S104
<<S105>>=
this.lu_pstr.put("S105", SEL+"SUM (val) FROM dist_s_travel");
@ %def S105
<<S106>>=
this.lu_pstr.put("S106", SEL+"val FROM dist_s_cruising WHERE sid=?");
@ %def S106
<<S107>>=
this.lu_pstr.put("S107", SEL+"SUM (val) FROM dist_s_cruising");
@ %def S107
<<S108>>=
this.lu_pstr.put("S108", SEL+"val FROM dist_s_service WHERE sid=?");
@ %def S108
<<S109>>=
this.lu_pstr.put("S109", SEL+"SUM (val) FROM dist_s_service");
@ %def S109
<<S110>>=
this.lu_pstr.put("S110", SEL+"val FROM dist_s_base");
@ %def S110
<<S111>>=
this.lu_pstr.put("S111", SEL+"val FROM dist_r_base");
@ %def S111
<<S112>>=
this.lu_pstr.put("S112", SEL+"val FROM dist_r_detour WHERE rid=?");
@ %def S112
<<S113>>=
this.lu_pstr.put("S113", SEL+"SUM (val) FROM dist_r_detour");
@ %def S113
<<S114>>=
this.lu_pstr.put("S114", SEL+"val FROM dist_r_transit WHERE rid=?");
@ %def S114
<<S115>>=
this.lu_pstr.put("S115", SEL+"SUM (val) FROM dist_r_transit");
@ %def S115
<<S116>>=
this.lu_pstr.put("S116", SEL+"val FROM dur_s_travel WHERE sid=?");
@ %def S116
<<S117>>=
this.lu_pstr.put("S117", SEL+"SUM (val) FROM dur_s_travel");
@ %def S117
<<S118>>=
this.lu_pstr.put("S118", SEL+"val FROM dur_r_pickup WHERE rid=?");
@ %def S118
<<S119>>=
this.lu_pstr.put("S119", SEL+"SUM (val) FROM dur_r_pickup");
@ %def S119
<<S120>>=
this.lu_pstr.put("S120", SEL+"val FROM dur_r_transit WHERE rid=?");
@ %def S120
<<S121>>=
this.lu_pstr.put("S121", SEL+"SUM (val) FROM dur_r_transit");
@ %def S121
<<S122>>=
this.lu_pstr.put("S122", SEL+"val FROM dur_r_travel WHERE rid=?");
@ %def S122
<<S123>>=
this.lu_pstr.put("S123", SEL+"SUM (val) FROM dur_r_travel");
@ %def S123
<<S124>>=
this.lu_pstr.put("S124", SEL+"val FROM t_r_depart WHERE rid=?");
@ %def S124
<<S125>>=
this.lu_pstr.put("S125", SEL+"val FROM t_s_depart WHERE sid=?");
@ %def S125
<<S126>>=
this.lu_pstr.put("S126", SEL+"val FROM t_r_arrive WHERE rid=?");
@ %def S126
<<S127>>=
this.lu_pstr.put("S127", SEL+"te FROM CW WHERE sid=?");
@ %def S127
<<S133>>=
this.lu_pstr.put("S133", SEL+"val FROM f_status WHERE rid=? AND t<=? "
    + "ORDER BY t DESC FETCH FIRST ROW ONLY");
@ %def S133
<<S134>>=
this.lu_pstr.put("S134", SEL+"sid, te FROM CW WHERE se<=? AND (?<te OR (ve=0 AND sl>?))");
@ %def S134
<<S135>>=
this.lu_pstr.put("S135", SEL+"t2, v2 FROM W WHERE sid=? AND t2=("
    + "SELECT t1 FROM W WHERE sid=? AND ? <= t1 AND t1 <= ? AND ? < t2)");
@ %def S135
<<S136>>=
this.lu_pstr.put("S136", SEL+"* FROM V");
@ %def S136
<<S137>>=
this.lu_pstr.put("S137", SEL+"* FROM E");
@ %def S137
<<S138>>=
this.lu_pstr.put("S138", SEL+"val FROM dist_r_unassigned");
@ %def S138
<<S139>>=
this.lu_pstr.put("S139", UPD+"CPD SET te=? WHERE sid=?");
@ %def S139
<<S140>>=
this.lu_pstr.put("S140", UPD+"CQ SET tp=?, td=? WHERE rid=?");
@ %def S140
<<S141>>=
this.lu_pstr.put("S141", SEL+"* FROM r_user");
@ %def S141
<<S142>>=
this.lu_pstr.put("S142", SEL+"SUM (dd) FROM W WHERE sid=? AND t2>?");
@ %def S142
<<S143>>=
this.lu_pstr.put("S143", SEL+"* FROM R WHERE re<=? AND ?<=re+?");
@ %def S143
<<S144>>=
this.lu_pstr.put("S144", SEL+"t2, v2, rid FROM CQ WHERE sid=? AND t2>? ORDER BY o2 ASC");
@ %def S144
<<S145>>=
this.lu_pstr.put("S145", SEL+"te, ve FROM CW WHERE sid=?");
@ %def S145
<<S147>>=
this.lu_pstr.put("S147", SEL+"t2, v2 FROM W WHERE sid=? AND t2=("
    + "SELECT t1 FROM W WHERE sid=? AND v2=0)");
@ %def S147
<<S148>>=
this.lu_pstr.put("S148", SEL+"sid FROM assignments WHERE rid=?");
@ %def S148
<<S149>>=
this.lu_pstr.put("S149", SEL+"t2, v2 FROM W WHERE sid=? ORDER BY t2 ASC");
@ %def S149
<<S150>>=
this.lu_pstr.put("S150", SEL+"COUNT (*) FROM violations_t_s");
@ %def S150
<<S151>>=
this.lu_pstr.put("S151", SEL+"COUNT (*) FROM violations_t_r");
@ %def S151
<<S152>>=
this.lu_pstr.put("S152", SEL+"t2, v2 FROM W WHERE sid=? AND t2>=? "
    + "ORDER BY t2 ASC FETCH FIRST ? ROWS ONLY");
@ %def S152
<<S153>>=
this.lu_pstr.put("S153", SEL+"t1, t2 FROM CQ WHERE sid=? AND q1=sq");
@ %def S153
<<S154>>=
this.lu_pstr.put("S154", SEL+"SUM (dd) FROM W WHERE sid=? AND t2 > ? AND t2 <= ?");
@ %def S154
<<S155>>=
this.lu_pstr.put("S155", SEL+"MAX (td) FROM CPD WHERE sid = ?");
@ %def S155
<<S156>>=
this.lu_pstr.put("S156", SEL+"ts, vs FROM CW WHERE sid=?");
@ %def S156
<<S157>>=
this.lu_pstr.put("S157", SEL+"val FROM dur_s_service WHERE sid=?");
@ %def S157
<<S158>>=
this.lu_pstr.put("S158", SEL+"SUM (val) FROM dur_s_service");
@ %def S158
<<S159>>=
this.lu_pstr.put("S159", SEL+"(a.val - b.val) FROM "
    + "(SELECT val FROM dur_s_travel WHERE sid=?) as a,"
    + "(SELECT val FROM dur_s_service WHERE sid=?) as b");
@ %def S159
<<S160>>=
this.lu_pstr.put("S160", SEL+"(a.val - b.val) FROM "
    + "(SELECT SUM (val) as val FROM dur_s_travel) as a,"
    + "(SELECT SUM (val) as val FROM dur_s_service) as b");
@ %def S160
<<S161>>=
this.lu_pstr.put("S161", SEL+"(a.val - b.val) FROM "
    + "(SELECT COUNT (*) as val FROM R WHERE ?>= re AND ? < rl) as a,"
    + "(SELECT COUNT (*) as val FROM assignments_r WHERE t <= ?) as b");
@ %def S161
<<S162>>=
this.lu_pstr.put("S162", SEL+"r.rid, r.ro FROM R LEFT JOIN CPD ON R.rid = CPD.rid "
    + "WHERE R.re <= ? AND ? < (R.re + ?) AND (? < CPD.tp OR CPD.tp IS NULL)");
@ %def S162
<<S163>>=
this.lu_pstr.put("S163", SEL+"COUNT (*) FROM CQ WHERE sid=? AND q1+? > 0"
    + "AND ( (t1 < ? AND t2 > ?) OR (? < t2 AND t2 <= ?) )");
@ %def S163

\subsubsection{\jsMethodName{PSCreate}{2}}
\begin{jsMethod}{Create a prepared statement for the given statement string.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsArg{Connection}{conn}{the database connection for creating the prepared statement}
    \jsArg{String}{k}{the statement identifier (see [[JargoSetupPreparedStatements]](0))}
  \end{itemize}
}
{A [[PreparedStatement]].}
{None.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{None.}
\end{jsMethod}

<<Admin: PSCreate(2)>>=
PreparedStatement PSCreate(final Connection conn, final String k) throws SQLException {
  PreparedStatement p = null;
  try {
    p = conn.prepareStatement(lu_pstr.get(k),
      ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    p.clearBatch();
    p.clearParameters();
  } catch (SQLException e) {
    throw e;
  }
  return p;
}
@ %def PSCreate

\subsubsection{\jsMethodName{PSAdd}{2..}}
\begin{jsMethod}{Add a prepared statement to the batch of statements to be
executed.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsArg{PreparedStatement}{p}{the prepared statement to add}
    \jsArg{Integer..}{values}{the values to use in the statement, if any}
  \end{itemize}
}
{Nothing.}
{Modifies [[p]].}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{None.}
\end{jsMethod}

<<Admin: PSAdd(2..)>>=
void PSAdd(PreparedStatement p, final Integer... values) throws SQLException {
  p.clearParameters();
  <<Set statement values>>
  try {
    p.addBatch();
  } catch (SQLException e) {
    throw e;
  }
}
@ %def PSAdd

\subsubsection{\jsMethodName{PSSubmit}{1..}}
\begin{jsMethod}{Executes a batch of prepared statements in the order that
they are given.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsArg{PreparedStatement..}{statements}{prepared statements to execute}
  \end{itemize}
}
{Nothing.}
{May modified the database.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{None.}
\end{jsMethod}

<<Admin: PSSubmit(1..)>>=
void PSSubmit(PreparedStatement... statements) throws SQLException {
  try {
    for (PreparedStatement p : statements) {
      p.executeBatch();
      p.close();
    }
  } catch (SQLException e) {
    throw e;
  }
}
@ %def PSSubmit

\subsubsection{\jsMethodName{PSQuery}{3..}}
\begin{jsMethod}{Execute a predefined [[SELECT]] statement and return the
results in a flattened array.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsArg{Connection}{conn}{the database connection}
    \jsArg{String}{k}{the statement identifier (see [[JargoSetupPreparedStatements]])}
    \jsArg{Integer}{ncols}{the number of columns in the selection}
  \end{itemize}
}
{
  results of the query flattened into an integer array, or [[null]] if no
  results. Element $in+j$ contains the value of column $j$ at row $i$ of the
  result set, for $n$ columns.
}
{None.}
{
  \begin{itemize}[leftmargin=*,topsep=0pt,itemsep=0pt]
    \jsErr{SQLException}{if database failure is encountered}
  \end{itemize}
}
{None.}
\end{jsMethod}

<<Admin: PSQuery(3..)>>=
int[] PSQuery(final Connection conn, final String k, final int ncols, final Integer... values)
throws SQLException {
  int[] output = new int[] { };
  try {
    PreparedStatement p = PSCreate(conn, k);
    <<Set statement values>>
    ResultSet res = p.executeQuery();
    if (res.last() == true) {
      <<Flatten results>>
    }
    res.close();
    p.close();
  } catch (SQLException e) {
    throw e;
  }
  return output;
}
@ %def PSQuery


\subsection{Methods: Getters}

\subsubsection{\texttt{getClock}(0)}
<<Admin: getClock(0)>>=
int getClock() {
  return this.simClock;
}
@ %def getClock

\subsubsection{\texttt{getClockStart}(0)}
<<Admin: getClockStart(0)>>=
int getClockStart() {
  return this.CLOCK_START;
}
@ %def getClockStart

\subsubsection{\texttt{getClockReference}(0)}
<<Admin: getClockReference(0)>>=
String getClockReference() {
  return this.refTimeStr;
}
@ %def getClockReference

\subsubsection{\texttt{getClockReferenceMs}(0)}
<<Admin: getClockReferenceMs(0)>>=
long getClockReferenceMs() {
  return this.refTimeMs;
}
@ %def getClockReferenceMs

\subsubsection{\texttt{getRefCacheEdges}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[getRefCacheEdges]]}(0) returns a read-only
reference to [[lu_edges]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} a read-only reference to [[lu_edges]].\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Admin: getRefCacheEdges(0)>>=
final ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>> getRefCacheEdges() {
  return this.lu_edges;
}
@ %def getRefCacheEdges

\subsubsection{\texttt{getRefCacheUsers}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[getRefCacheUsers]]}(0) returns a read-only
reference to [[lu_users]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} a read-only reference to [[lu_users]].\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Admin: getRefCacheUsers(0)>>=
final ConcurrentHashMap<Integer, int[]> getRefCacheUsers() {
  return this.lu_users;
}
@ %def getRefCacheUsers


\subsubsection{\texttt{getRefCacheVertices}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[getRefCacheVertices]]}(0) returns a read-only
reference to [[lu_vertices]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} a read-only reference to [[lu_vertices]].\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Admin: getRefCacheVertices(0)>>=
final ConcurrentHashMap<Integer, int[]> getRefCacheVertices() {
  return this.lu_vertices;
}
@ %def getRefCacheVertices

\subsubsection{\texttt{getRefCommunicator}(0)}
<<Admin: getRefCommunicator(0)>>=
Communicator getRefCommunicator() {
  return this.communicator;
}
@ %def getRefCommunicator

\subsubsection{\texttt{getRefStorage}(0)}
<<Admin: getRefStorage(0)>>=
Storage getRefStorage() {
  return this.storage;
}
@ %def getRefStorage

\subsubsection{\texttt{retrieveQueueSize}(0)}
<<Admin: retrieveQueueSize(0)>>=
int retrieveQueueSize() {
  return this.client.getQueueSize();
}
@ %def retrieveQueueSize

\subsubsection{\texttt{retrieveHandleRequestDur}(0)}
<<Admin: retrieveHandleRequestDur(0)>>=
long retrieveHandleRequestDur() {
  return this.client.getHandleRequestDur();
}
@ %def retrieveHandleRequestDur

\subsubsection{\texttt{retrieveClock}(0)}
<<Admin: retrieveClock(0)>>=
int retrieveClock() {
  return this.controller.getClock();
}
@ %def retrieveClock

\subsubsection{\texttt{retrieveRefCacheVertices}(0)}
<<Admin: retrieveRefCacheVertices(0)>>=
final ConcurrentHashMap<Integer, int[]> retrieveRefCacheVertices() {
  return this.storage.getRefCacheVertices();
}
@ %def retrieveRefCacheVertices

\subsubsection{\texttt{retrieveRefCacheEdges}(0)}
<<Admin: retrieveRefCacheEdges(0)>>=
final ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>> retrieveRefCacheEdges() {
  return this.storage.getRefCacheEdges();
}
@ %def retrieveRefCacheEdges

\subsubsection{\texttt{retrieveRefCacheUsers}(0)}
<<Admin: retrieveRefCacheUsers(0)>>=
final ConcurrentHashMap<Integer, int[]> retrieveRefCacheUsers() {
  return this.storage.getRefCacheUsers();
}
@ %def retrieveRefCacheUsers


\subsection{Methods: Setters}

\subsubsection{\texttt{setClockReference}(1)}
<<Admin: setClockReference(1)>>=
void setClockReference(final String clock_reference) throws IllegalArgumentException {
  int hour = Integer.parseInt(clock_reference.substring(0, 2));
  if (!(0 <= hour && hour <= 23)) {
    throw new IllegalArgumentException("Invalid clock reference (hour got "+hour+"; must be between [00, 23])");
  }
  int minute = Integer.parseInt(clock_reference.substring(2, 4));
  if (!(0 <= minute && minute <= 59)) {
    throw new IllegalArgumentException("Invalid clock reference (minute got "+minute+"; must be between [00, 59])");
  }
  this.refTimeStr = clock_reference;
  try {
    this.refTimeMs = this.tools.parseClockReference(clock_reference);
  } catch (Exception pe) {
    throw new IllegalArgumentException("Invalid clock reference (parse failed)");
  }
  this.simClockReferenceHour= hour;
  this.simClockReferenceMinute = minute;
  if (DEBUG) {
    System.out.printf("refHr=%d, refMn=%d, refMs=%d\n",
      hour, minute, this.refTimeMs);
  }
}
@ %def setClockReference

\subsubsection{\texttt{setClockStart}(1)}
<<Admin: setClockStart(1)>>=
void setClockStart(final int clock_start) {
  this.CLOCK_START = clock_start;
  this.simClockReferenceSecond += clock_start;
  this.simClockReferenceSecond %= 60;
  this.simClockReferenceMinute += (clock_start / 60);
  this.simClockReferenceMinute %= 60;
  this.simClockReferenceHour += (clock_start / 3600);
  this.simClockReferenceHour %= 24;
  this.simClockReferenceDay += (clock_start / 86400);
  if (DEBUG) {
    System.out.printf("clock_start=%d\n", clock_start);
    System.out.printf("clock day %d %02d:%02d:%02d\n",
        this.simClockReferenceDay,
        this.simClockReferenceHour,
        this.simClockReferenceMinute,
        this.simClockReferenceSecond);
  }
}
@ %def setClockStart

\subsubsection{\texttt{setClockEnd}(1)}
<<Admin: setClockEnd(1)>>=
void setClockEnd(final int clock_end) {
  this.CLOCK_END = clock_end;
}
@ %def setClockEnd

\subsubsection{\texttt{setQueueTimeout}(1)}
<<Admin: setQueueTimeout(1)>>=
void setQueueTimeout(final int queue_timeout) {
  this.QUEUE_TIMEOUT = queue_timeout;
}
@ %def setQueueTimeout

\subsubsection{\texttt{setRequestTimeout}(1)}
<<Admin: setRequestTimeout(1)>>=
void setRequestTimeout(final int request_timeout) {
  this.REQUEST_TIMEOUT = request_timeout;
}
@ %def setRequestTimeout


\subsubsection{\texttt{setRefCacheVertices}(1)}
<<Admin: setRefCacheVertices(1)>>=
void setRefCacheVertices(final ConcurrentHashMap<Integer, int[]> lu_vertices) {
  this.lu_vertices = lu_vertices;
}
@ %def setRefCacheVertices

\subsubsection{\texttt{setRefCacheEdges}(1)}
<<Admin: setRefCacheEdges(1)>>=
void setRefCacheEdges(final ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>> lu_edges) {
  this.lu_edges = lu_edges;
}
@ %def setRefCacheEdges

\subsubsection{\texttt{setRefCacheUsers}(1)}
<<Admin: setRefCacheUsers(1)>>=
void setRefCacheUsers(final ConcurrentHashMap<Integer, int[]> lu_users) {
  this.lu_users = lu_users;
}
@ %def setRefCacheUsers

\subsubsection{\texttt{setRefClient}(1)}
<<Admin: setRefClient(1)>>=
void setRefClient(final Client client) {
  this.client = client;
}
@ %def setRefClient

\subsubsection{\texttt{setRefCommunicator}(1)}
<<Admin: setRefCommunicator(1)>>=
void setRefCommunicator(final Communicator communicator) {
  this.communicator = communicator;
}
@ %def setRefCommunicator

\subsubsection{\texttt{setRefController}(1)}
<<Admin: setRefController(1)>>=
void setRefController(final Controller controller) {
  this.controller = controller;
}
@ %def setRefController

\subsubsection{\texttt{setRefStorage}(1)}
<<Admin: setRefStorage(1)>>=
void setRefStorage(final Storage storage) {
  this.storage = storage;
}
@ %def setRefStorage

\subsubsection{\texttt{setRefTraffic}(1)}
<<Admin: setRefTraffic(1)>>=
void setRefTraffic (final Traffic traffic) {
  this.traffic = traffic;
  this.traffic.forwardRefCacheVertices(this.storage.getRefCacheVertices());
  this.traffic.forwardRefCacheEdges(this.storage.getRefCacheEdges());
}
@ %def setRefTraffic

\subsubsection{\texttt{forwardRefTraffic}(1)}
<<Admin: forwardRefTraffic(1)>>=
void forwardRefTraffic(final Traffic traffic) {
  this.communicator.setRefTraffic(traffic);
}
@ %def forwardRefTraffic

\subsubsection{\texttt{forwardRefCommunicator}(1)}
<<Admin: forwardRefCommunicator(1)>>=
void forwardRefCommunicator(final Communicator communicator) {
  this.client.setRefCommunicator(communicator);
}
@ %def forwardRefCommunicator

\subsubsection{\texttt{forwardRefCacheEdges}(1)}
<<Admin: forwardRefCacheEdges(1)>>=
void forwardRefCacheEdges(final ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>> lu_edges) {
  this.tools.setRefCacheEdges(lu_edges);
}
@ %def forwardRefCacheEdges

\subsubsection{\texttt{forwardRefCacheUsers}(1)}
<<Admin: forwardRefCacheUsers(1)>>=
void forwardRefCacheUsers(final ConcurrentHashMap<Integer, int[]> lu_users) {
  this.tools.setRefCacheUsers(lu_users);
}
@ %def forwardRefCacheUsers

\subsubsection{\texttt{forwardRefCacheVertices}(1)}
<<Admin: forwardRefCacheVertices(1)>>=
void forwardRefCacheVertices(final ConcurrentHashMap<Integer, int[]> lu_vertices) {
  this.tools.setRefCacheVertices(lu_vertices);
}
@ %def forwardRefCacheVertices

\subsection{Exceptions}

\subsubsection{\texttt{DuplicateEdgeException}}
<<DuplicateEdgeException.java>>=
<<Package: [[sim]]>>
public class DuplicateEdgeException extends Exception {
  public DuplicateEdgeException <<Construct empty exception>>
  public DuplicateEdgeException <<Construct message exception>>
  public DuplicateEdgeException <<Construct cause exception>>
  public DuplicateEdgeException <<Construct message and cause exception>>
}
@ %def DuplicateEdgeException

\subsubsection{\texttt{DuplicateUserException}}
<<DuplicateUserException.java>>=
<<Package: [[sim]]>>
public class DuplicateUserException extends Exception {
  public DuplicateUserException <<Construct empty exception>>
  public DuplicateUserException <<Construct message exception>>
  public DuplicateUserException <<Construct cause exception>>
  public DuplicateUserException <<Construct message and cause exception>>
}
@ %def DuplicateUserException

\subsubsection{\texttt{DuplicateVertexException}}
<<DuplicateVertexException.java>>=
<<Package: [[sim]]>>
public class DuplicateVertexException extends Exception {
  public DuplicateVertexException <<Construct empty exception>>
  public DuplicateVertexException <<Construct message exception>>
  public DuplicateVertexException <<Construct cause exception>>
  public DuplicateVertexException <<Construct message and cause exception>>
}
@ %def DuplicateVertexException

\subsubsection{\texttt{EdgeNotFoundException}}
<<EdgeNotFoundException.java>>=
<<Package: [[sim]]>>
public class EdgeNotFoundException extends Exception {
  public EdgeNotFoundException <<Construct empty exception>>
  public EdgeNotFoundException <<Construct message exception>>
  public EdgeNotFoundException <<Construct cause exception>>
  public EdgeNotFoundException <<Construct message and cause exception>>
}
@ %def EdgeNotFoundException

\subsubsection{\texttt{GtreeIllegalSourceException}}
<<GtreeIllegalSourceException.java>>=
<<Package: [[sim]]>>
public class GtreeIllegalSourceException extends Exception {
  public GtreeIllegalSourceException <<Construct empty exception>>
  public GtreeIllegalSourceException <<Construct message exception>>
  public GtreeIllegalSourceException <<Construct cause exception>>
  public GtreeIllegalSourceException <<Construct message and cause exception>>
}
@ %def GtreeIllegalSourceException

\subsubsection{\texttt{GtreeIllegalTargetException}}
<<GtreeIllegalTargetException.java>>=
<<Package: [[sim]]>>
public class GtreeIllegalTargetException extends Exception {
  public GtreeIllegalTargetException <<Construct empty exception>>
  public GtreeIllegalTargetException <<Construct message exception>>
  public GtreeIllegalTargetException <<Construct cause exception>>
  public GtreeIllegalTargetException <<Construct message and cause exception>>
}
@ %def GtreeIllegalTargetException

\subsubsection{\texttt{GtreeNotLoadedException}}
<<GtreeNotLoadedException.java>>=
<<Package: [[sim]]>>
public class GtreeNotLoadedException extends Exception {
  public GtreeNotLoadedException <<Construct empty exception>>
  public GtreeNotLoadedException <<Construct message exception>>
  public GtreeNotLoadedException <<Construct cause exception>>
  public GtreeNotLoadedException <<Construct message and cause exception>>
}
@ %def GtreeNotLoadedException

\subsubsection{\texttt{RouteIllegalOverwriteException}}
<<RouteIllegalOverwriteException.java>>=
<<Package: [[sim]]>>
public class RouteIllegalOverwriteException extends Exception {
  public RouteIllegalOverwriteException <<Construct empty exception>>
  public RouteIllegalOverwriteException <<Construct message exception>>
  public RouteIllegalOverwriteException <<Construct cause exception>>
  public RouteIllegalOverwriteException <<Construct message and cause exception>>
}
@ %def RouteIllegalOverwriteException

\subsubsection{\texttt{TimeWindowException}}
<<TimeWindowException.java>>=
<<Package: [[sim]]>>
public class TimeWindowException extends Exception {
  public TimeWindowException <<Construct empty exception>>
  public TimeWindowException <<Construct message exception>>
  public TimeWindowException <<Construct cause exception>>
  public TimeWindowException <<Construct message and cause exception>>
}
@ %def TimeWindowException

\subsubsection{\texttt{UserNotFoundException}}
<<UserNotFoundException.java>>=
<<Package: [[sim]]>>
public class UserNotFoundException extends Exception {
  public UserNotFoundException <<Construct empty exception>>
  public UserNotFoundException <<Construct message exception>>
  public UserNotFoundException <<Construct cause exception>>
  public UserNotFoundException <<Construct message and cause exception>>
}
@ %def UserNotFoundException

\subsubsection{\texttt{VertexNotFoundException}}
<<VertexNotFoundException.java>>=
<<Package: [[sim]]>>
public class VertexNotFoundException extends Exception {
  public VertexNotFoundException <<Construct empty exception>>
  public VertexNotFoundException <<Construct message exception>>
  public VertexNotFoundException <<Construct cause exception>>
  public VertexNotFoundException <<Construct message and cause exception>>
}
@ %def VertexNotFoundException

