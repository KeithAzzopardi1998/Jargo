\chapter{Administration, Getters, and Setters}
\label{admin}

\section{Chunks}

\subsection{Open \texttt{conn}}
<<Open [[conn]]>>=
Connection conn = DriverManager.getConnection(CONNECTIONS_POOL_URL)
@

\subsection{Set statement values}
<<Set statement values>>=
for (int i = 0; i < values.length; i++) {
  if (values[i] == null) {
    p.setNull((i + 1), java.sql.Types.INTEGER);
  } else {
    p.setInt ((i + 1), values[i]);
  }
}
@

\section{Methods: Administration}

\subsection{\texttt{JargoInstanceNew}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoInstanceNew]]}(0) creates a new database
instance. It uses [[JargoSetupDriver]](0) to register the JDBC [[DriverManager]] to
the new instance.  If the DBCP2 [[PoolingDriver]] cannot be found, a
[[ClassNotFoundException]] is thrown. We consider this exception to be fatal
and we exit immediately.  On the other hand if a [[SQLException]] occurs, we
rethrow to let the caller handle it. This exception can occur if the driver
cannot access the database for whatever reason.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} initializes a new in-memory Derby instance,
or exits the JVM if the DBCP2 driver
cannot be loaded.\\
\textbf{Throws:} [[SQLException]] if database cannot be accessed for whatever
reason.\\
\bottomrule
\end{tabular}
<<Admin: JargoInstanceNew(0)>>=
void JargoInstanceNew() throws SQLException {
  try {
    this.JargoSetupDriver();
  } catch (SQLException e) {
    throw e;
  } catch (ClassNotFoundException e) {
    System.err.println("Fatal exception");
    e.printStackTrace();
    System.exit(1);
  }
}
@ %def JargoInstanceNew
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[instanceNew]]}(0) wraps [[JargoInstanceNew]](0).\\
\bottomrule
\end{tabular}
<<Admin: instanceNew(0)>>=
void instanceNew() throws SQLException {
  this.storage.JargoInstanceNew();
}
@ %def instanceNew

\subsection{\texttt{JargoInstanceInitialize}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoInstanceInitialize]]}(0) loads the data model in
\S\ref{TODO} into the Jargo database instance. If the
data model cannot be loaded, a [[SQLException]] is thrown. We consider this
exception to be fatal and we exit immediately. Possible reasons for such an
exception might be because the caller forgot to first call
[[JargoInstanceNew]](0) resulting in ``No suitable driver found'' (error
code 0), or because the caller previously called [[JargoInstanceLoad]](1) resulting
in ``Table/View V already exists'' (error code 20000). In either case we print
a hint to terminal to guide the debugging.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} loads the data model in \S\ref{TODO}
into the Jargo instance, or exits the JVM if failure occurs.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Admin: JargoInstanceInitialize(0)>>=
void JargoInstanceInitialize() {
  try (<<Open [[conn]]>>) {
    Statement stmt = conn.createStatement();
    stmt.clearBatch();
    stmt.addBatch(<<Create Table V statement>>);
    stmt.addBatch(<<Create Table E statement>>);
    stmt.addBatch(<<Create Table UQ statement>>);
    stmt.addBatch(<<Create Table UE statement>>);
    stmt.addBatch(<<Create Table UL statement>>);
    stmt.addBatch(<<Create Table UO statement>>);
    stmt.addBatch(<<Create Table UD statement>>);
    stmt.addBatch(<<Create Table UB statement>>);
    stmt.addBatch(<<Create Table S statement>>);
    stmt.addBatch(<<Create Table R statement>>);
    stmt.addBatch(<<Create Table W statement>>);
    stmt.addBatch(<<Create Table PD statement>>);
    stmt.addBatch(<<Create Table CW statement>>);
    stmt.addBatch(<<Create Table CPD statement>>);
    stmt.addBatch(<<Create Table CQ statement>>);
    stmt.addBatch(<<Create View r\_user statement>>);
    stmt.addBatch(<<Create View r\_server statement>>);
    stmt.addBatch(<<Create View f\_distance\_blocks statement>>);
    stmt.addBatch(<<Create View f\_status statement (Eq.~\ref{eq:status})>>);
    stmt.addBatch(<<Create View assignments statement (Eq.~\ref{eq:assignments})>>);
    stmt.addBatch(<<Create View assignments\_r statement (Eq.~\ref{eq:assigned-requests})>>);
    stmt.addBatch(<<Create View service\_rate statement (Eq.~\ref{eq:service-rate})>>);
    stmt.addBatch(<<Create View dist\_base statement (Eq.~\ref{eq:base-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_travel statement>>);
    stmt.addBatch(<<Create View dist\_s\_cruising statement (Eq.~\ref{eq:cruising-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_service statement (Eq.~\ref{eq:service-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_base statement>>);
    stmt.addBatch(<<Create View dist\_r\_base statement>>);
    stmt.addBatch(<<Create View dist\_r\_unassigned statement>>);
    stmt.addBatch(<<Create View dist\_r\_transit statement (Eq.~\ref{eq:transit-distance})>>);
    stmt.addBatch(<<Create View dist\_r\_detour statement (Eq.~\ref{eq:detour-distance})>>);
    stmt.addBatch(<<Create View dur\_s\_travel statement>>);
    stmt.addBatch(<<Create View dur\_r\_pickup statement (Eq.~\ref{eq:pick-up delay})>>);
    stmt.addBatch(<<Create View dur\_r\_transit statement (Eq.~\ref{eq:transit-duration})>>);
    stmt.addBatch(<<Create View dur\_r\_travel statement (Eq.~\ref{eq:travel-duration})>>);
    stmt.addBatch(<<Create View t\_r\_depart statement (Eq.~\ref{eq:departure-time})>>);
    stmt.addBatch(<<Create View t\_s\_depart statement (Eq.~\ref{eq:departure-time})>>);
    stmt.addBatch(<<Create View t\_r\_arrive statement (Eq.~\ref{eq:arrival-time})>>);
    stmt.addBatch(<<Create View t\_s\_arrive statement (Eq.~\ref{eq:arrival-time})>>);
    stmt.addBatch(<<Create View violations\_t\_s>>);
    stmt.addBatch(<<Create View violations\_t\_r>>);
    stmt.addBatch("CREATE INDEX R_re ON R (re)");
    stmt.addBatch("CREATE INDEX W_sid_t1 ON W (sid, t1)");
    stmt.addBatch("CREATE INDEX W_sid_t2 ON W (sid, t2)");
    stmt.addBatch("CREATE INDEX W_sid_v2 ON W (sid, v2)");
    stmt.addBatch("CREATE INDEX W_sid_t1_t2 ON W (sid, t1, t2)");
    stmt.addBatch("CREATE INDEX CQ_sid_t2_o2 ON CQ (sid, t2, o2)");
    stmt.addBatch("CREATE INDEX CQ_sid_t2_q2 ON CQ (sid, t2 DESC, q2 DESC)");
    stmt.executeBatch();
    conn.commit();
  } catch (SQLException e) {
    System.err.println("Fatal error.");
    if (e.getErrorCode() == 0) {
      System.err.println("(did you forget to call Storage.JargoInstanceNew()?)");
    } else if (e.getErrorCode() == 20000) {
      System.err.println("(data model already exists from Storage.JargoInstanceLoad()?)");
    }
    e.printStackTrace(System.err);
    System.exit(1);
  }
}
@ %def JargoInstanceInitialize
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[instanceInitialize]]}(0) wraps [[JargoInstanceInitialize]](0).\\
\bottomrule
\end{tabular}
<<Admin: instanceInitialize(0)>>=
void instanceInitialize() {
  this.storage.JargoInstanceInitialize();
}
@ %def instanceInitialize


\subsection{\texttt{JargoInstanceLoad}(1)}
<<Admin: JargoInstanceLoad(1)>>=
void JargoInstanceLoad(final String p) throws SQLException {
  this.CONNECTIONS_URL = "jdbc:derby:"+p;
  try {
    this.JargoSetupDriver();
  } catch (ClassNotFoundException e) {
    System.out.println("Fatal error.");
    e.printStackTrace();
    System.exit(1);
  }
}
@ %def JargoInstanceLoad
<<Admin: instanceLoad(1)>>=
void instanceLoad(final String p) throws SQLException {
  this.storage.JargoInstanceLoad(p);
}
@ %def instanceLoad

\subsection{\texttt{JargoInstanceLoadInMem}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoInstanceLoadInMem]]}(1) loads a previously saved Jargo
database instance from disk into working memory. It uses [[JargoSetupDriver]](0) to
register the JDBC [[DriverManager]] to the new instance.  If the DBCP2
[[PoolingDriver]] cannot be found, a [[ClassNotFoundException]] is thrown. We
consider this exception to be fatal and we exit immediately.  On the other hand
if a [[SQLException]] occurs, we rethrow to let the caller handle it. This
exception can occur if the driver cannot access the database for whatever
reason.\\
\midrule
\textbf{Parameters:} \\
\hspace{2mm} String [[p]] (param. 1): path to directory where backup is located.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} loads backup into Jargo database instance, or exits the
JVM if failure occurs.\\
\textbf{Throws:} [[SQLException]] if database cannot be accessed, or
[[ClassNotFoundException]] if the DBCP2 driver cannot be found.\\
\bottomrule
\end{tabular}
<<Admin: JargoInstanceLoadInMem(1)>>=
void JargoInstanceLoadInMem(final String p) throws SQLException {
  this.CONNECTIONS_URL = "jdbc:derby:memory:jargo;createFrom="+p;
  try {
    this.JargoSetupDriver();
  } catch (ClassNotFoundException e) {
    System.out.println("Fatal error.");
    e.printStackTrace();
    System.exit(1);
  }
}
@ %def JargoInstanceLoadInMem
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[instanceLoadInMem]]}(1) wraps [[JargoInstanceLoadInMem]](1).\\
\bottomrule
\end{tabular}
<<Admin: instanceLoadInMem(1)>>=
void instanceLoadInMem(final String p) throws SQLException {
  this.storage.JargoInstanceLoadInMem(p);
}
@ %def instanceLoadInMem

\subsection{\texttt{JargoInstanceExport}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoInstanceExport]]}(1) exports the Jargo database
instance to disk. If a [[SQLException]] occurs, we rethrow to let the caller
handle it.\\
\midrule
\textbf{Parameters:} \\
\hspace{2mm} String [[p]] (param. 1): path to directory where instance should
be exported to.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} writes the database to disk.\\
\textbf{Throws:} [[SQLException]] if failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: JargoInstanceExport(1)>>=
void JargoInstanceExport(final String p) throws SQLException {
  try (<<Open [[conn]]>>) {
    CallableStatement cs = conn.prepareCall("CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE('"+p+"')");
    cs.execute();
  } catch (SQLException e) {
    throw e;
  }
}
@ %def JargoInstanceExport
\noindent\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[instanceExport]]}(1) wraps [[JargoInstanceExport]](1).\\
\bottomrule
\end{tabular}
<<Admin: instanceExport(1)>>=
void instanceExport(final String p) throws SQLException {
  this.storage.JargoInstanceExport(p);
}
@ %def instanceExport

\subsection{\texttt{JargoInstanceClose}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoInstanceClose]]}(0) closes an existing Jargo
database instance.  If the instance closes successfully, a [[SQLException]]
with error code [[45000]] is thrown. Otherwise, some other error code is
thrown. In this case we rethrow to let the caller handle it.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} closes an existing Jargo database instance.\\
\textbf{Throws:} [[SQLException]] if database cannot be closed for whatever
reason.\\
\bottomrule
\end{tabular}
<<Admin: JargoInstanceClose(0)>>=
void JargoInstanceClose() throws SQLException {
  try {
    DriverManager.getConnection("jdbc:derby:memory:jargo;drop=true");
  } catch (SQLException e) {
    if (e.getErrorCode() != 45000) {
      throw e;
    }
  }
}
@ %def JargoInstanceClose
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[instanceClose]]}(0) wraps [[JargoInstanceClose]](0).\\
\bottomrule
\end{tabular}
<<Admin: instanceClose(0)>>=
void instanceClose() throws SQLException {
  this.storage.JargoInstanceClose();
}
@ %def instanceClose

\subsection{\texttt{JargoCacheRoadNetworkFromDB}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoCacheRoadNetworkFromDB]]}(0) loads two caches
[[lu_vertices]] and [[lu_edges]] using the vertices and edges data in Tables V
and E in the database. If queries on Tables V and E fail, this method throws a
[[SQLException]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} populates [[lu_vertices]] and [[lu_edges]].\\
\textbf{Throws:} [[SQLException]] if Tables V and E cannot be queried or
other database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
void JargoCacheRoadNetworkFromDB() throws SQLException {
@ %def JargoCacheRoadNetworkFromDB
{\small Our approach is to create two temporary maps on the heap, populate the
temporary maps, then assign [[lu_vertices]] and [[lu_edges]] to reference the
temporary maps if all succeeds. This way we don't corrupt [[lu_vertices]] and
[[lu_edges]] in case of failure. (The approach might be overly cautious as it's
hard to imagine why this method would ever be called if the caches are already
populated.)}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
  ConcurrentHashMap<Integer, int[]>    lu1 = new ConcurrentHashMap<Integer, int[]>();
  ConcurrentHashMap<Integer,
    ConcurrentHashMap<Integer, int[]>> lu2 = new ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>>();
@
{\small We start by querying the vertices.}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
  try {
    final int[] output = this.DBQueryVertices();
    for (int i = 0; i < (output.length - 2); i += 3) {
      final int   v = output[(i + 0)];
      final int lng = output[(i + 1)];
      final int lat = output[(i + 2)];
      lu1.put(v, new int[] { lng, lat });
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Then we go on to query the edges.}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
  try {
    final int[] output = this.DBQueryEdges();
    for (int i = 0; i < (output.length - 3); i += 4) {
      final int v1 = output[(i + 0)];
      final int v2 = output[(i + 1)];
      final int dd = output[(i + 2)];
      final int nu = output[(i + 3)];
      if (!lu2.containsKey(v1)) {
        lu2.put(v1, new ConcurrentHashMap<Integer, int[]>());
      }
      lu2.get(v1).put(v2, new int[] { dd, nu });
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Finally we do the assignment.}
<<Admin: JargoCacheRoadNetworkFromDB(0)>>=
  this.lu_vertices = lu1;
  this.lu_edges    = lu2;
}
@
\noindent\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[cacheRoadNetworkFromDB]]}(0) wraps [[JargoCacheRoadNetworkFromDB]](0).\\
\bottomrule
\end{tabular}
<<Admin: cacheRoadNetworkFromDB(0)>>=
void cacheRoadNetworkFromDB() throws SQLException {
  this.storage.JargoCacheRoadNetworkFromDB();
}
@ %def cacheRoadNetworkFromDB



\subsection{\texttt{JargoCacheUsersFromDB}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoCacheUsersFromDB]]}(0) loads the two caches
[[lu_users]] and [[lu_rstatus]] using data in the user and assignment tables in
the database. If queries on these tables fail, this method throws a
[[SQLException]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} populates [[lu_users]] and [[lu_rstatus]].\\
\textbf{Throws:} [[SQLException]] if user and assignment tables cannot be
queried or other database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: JargoCacheUsersFromDB(0)>>=
void JargoCacheUsersFromDB() throws SQLException {
@ %def JargoCacheUsersFromDB
{\small Our approach follows the approach for [[JargoCacheRoadNetworkFromDB]](0).
We start by creating two temporary maps on the heap.}
<<Admin: JargoCacheUsersFromDB(0)>>=
  ConcurrentHashMap<Integer, int[]> lu1 = new ConcurrentHashMap<Integer, int[]>();
  Map<Integer, Boolean>             lu2 = new HashMap<Integer, Boolean>();
  Map<Integer, Integer>             lu3 = new HashMap<Integer, Integer>();
@
{\small Then we query the users.}
<<Admin: JargoCacheUsersFromDB(0)>>=
  try {
    final int[] output = this.DBQueryUsers();
    for (int i = 0; i < (output.length - 6); i += 7) {
      final int uid = output[(i + 0)];
      final int  uq = output[(i + 1)];
      final int  ue = output[(i + 2)];
      final int  ul = output[(i + 3)];
      final int  uo = output[(i + 4)];
      final int  ud = output[(i + 5)];
      final int  ub = output[(i + 6)];
      lu1.put(uid, new int[] { uid, uq, ue, ul, uo, ud, ub });
@
{\small If the user is a request, in other words the user load is positive,
we query the request's assignment status. Else, we initialize the last-visitation time.}
<<Admin: JargoCacheUsersFromDB(0)>>=
      if (uq > 0) {
        lu2.put(uid, (this.DBQueryRequestIsAssigned(uid).length > 0 ? true : false));
      } else {
        lu3.put(uid, 0);
      }
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Finally we do the assignment.}
<<Admin: JargoCacheUsersFromDB(0)>>=
  this.lu_users   = lu1;
  this.lu_rstatus = lu2;
  this.lu_lvt     = lu3;
}
@
\noindent\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[cacheUsersFromDB]]}(0) wraps [[JargoCacheUsersFromDB]](0).\\
\bottomrule
\end{tabular}
<<Admin: cacheUsersFromDB(0)>>=
void cacheUsersFromDB() throws SQLException {
  this.storage.JargoCacheUsersFromDB();
}
@ %def cacheUsersFromDB

\subsection{\texttt{JargoSetupDriver}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoSetupDriver]]}(0) registers a connection pool to the
JDBC driver.
The connection pool allows us to concurrently submit SQL
commands against the database from different threads.
A [[SQLException]] is thrown in case of database failure.
A [[ClassNotFoundException]] is thrown if the DBCP2 [[PoolingDriver]]
cannot be found.
Portions of this code are licensed by the Apache Software Foundation.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} registers a new connection pool to the JDBC driver manager.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered, or
[[ClassNotFoundException]] if the DBCP2 driver cannot be found.\\
\bottomrule
\end{tabular}
<<Admin: JargoSetupDriver(0)>>=
void JargoSetupDriver() throws SQLException, ClassNotFoundException {
  connection_factory = new DriverManagerConnectionFactory(CONNECTIONS_URL);
  poolableconnection_factory = new PoolableConnectionFactory(connection_factory, null);
  poolableconnection_factory.setPoolStatements(true);
  poolableconnection_factory.setDefaultAutoCommit(false);
  poolableconnection_factory.setMaxOpenPreparedStatements(STATEMENTS_MAX_COUNT);
  poolableconnection_factory.setDefaultTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
  GenericObjectPoolConfig<PoolableConnection> cfg = new GenericObjectPoolConfig<PoolableConnection>();
  cfg.setMinIdle(100000);
  cfg.setMaxIdle(100000);
  cfg.setMaxTotal(100000);
  pool = new GenericObjectPool<PoolableConnection>(poolableconnection_factory, cfg);
  poolableconnection_factory.setPool(pool);
  Class.forName("org.apache.commons.dbcp2.PoolingDriver");
  driver = (PoolingDriver) DriverManager.getDriver(CONNECTIONS_DRIVER_URL);
  driver.registerPool(CONNECTIONS_POOL_NAME, pool);
}
@ %def JargoSetupDriver

\subsection{\texttt{JargoSetupPreparedStatements}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[JargoSetupPreparedStatements]]}(0) initializes the statement cache
[[lu_pstr]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} populates [[lu_pstr]].\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Admin: JargoSetupPreparedStatements(0)>>=
void JargoSetupPreparedStatements() {
  final String INS = "INSERT INTO ";
  final String UPD = "UPDATE ";
  final String DEL = "DELETE FROM ";
  final String SEL = "SELECT ";
  final String q2  = "(?,?)";
  final String q3  = "(?,?,?)";
  final String q4  = "(?,?,?,?)";
  final String q7  = "(?,?,?,?,?,?,?)";
  final String q8  = "(?,?,?,?,?,?,?,?)";
  final String q9  = "(?,?,?,?,?,?,?,?,?)";
  final String q12 = "(?,?,?,?,?,?,?,?,?,?,?,?)";
  final String q14 = "(?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
  <<S0>> <<S1>> <<S2>> <<S3>> <<S4>> <<S5>> <<S6>> <<S7>> <<S8>> <<S9>> <<S10>>
  <<S11>> <<S12>> <<S13>> <<S14>> <<S15>> <<S131>> <<S77>> <<S84>> <<S82>>
  <<S83>> <<S76>> <<S42>> <<S43>> <<S80>> <<S62>> <<S64>> <<S63>> <<S65>>
  <<S46>> <<S130>> <<S70>> <<S48>> <<S66>> <<S75>> <<S51>> <<S67>> <<S59>>
  <<S128>> <<S60>> <<S129>> <<S61>> <<S69>> <<S68>> <<S85>> <<S86>> <<S73>>
  <<S87>> <<S100>> <<S101>> <<S102>> <<S103>> <<S104>> <<S105>> <<S106>>
  <<S107>> <<S108>> <<S109>> <<S110>> <<S111>> <<S112>> <<S113>> <<S114>>
  <<S115>> <<S116>> <<S117>> <<S118>> <<S119>> <<S120>> <<S121>> <<S122>>
  <<S123>> <<S124>> <<S125>> <<S126>> <<S127>> <<S133>> <<S134>> <<S135>>
  <<S136>> <<S137>> <<S138>> <<S139>> <<S140>> <<S141>> <<S142>> <<S143>>
  <<S144>> <<S145>> <<S147>> <<S148>> <<S149>> <<S150>> <<S151>> <<S152>>
}
@ %def JargoSetupPreparedStatements
<<S0>>=
this.lu_pstr.put("S0", INS+"V VALUES "+q3);
@ %def S0
<<S1>>=
this.lu_pstr.put("S1", INS+"E VALUES "+q4);
@ %def S1
<<S2>>=
this.lu_pstr.put("S2", INS+"UQ VALUES "+q2);
@ %def S2
<<S3>>=
this.lu_pstr.put("S3", INS+"UE VALUES "+q2);
@ %def S3
<<S4>>=
this.lu_pstr.put("S4", INS+"UL VALUES "+q2);
@ %def S4
<<S5>>=
this.lu_pstr.put("S5", INS+"UO VALUES "+q2);
@ %def S5
<<S6>>=
this.lu_pstr.put("S6", INS+"UD VALUES "+q2);
@ %def S6
<<S7>>=
this.lu_pstr.put("S7", INS+"UB VALUES "+q2);
@ %def S7
<<S8>>=
this.lu_pstr.put("S8", INS+"S VALUES "+q7);
@ %def S8
<<S9>>=
this.lu_pstr.put("S9", INS+"R VALUES "+q7);
@ %def S9
<<S10>>=
this.lu_pstr.put("S10", INS+"W VALUES "+q8);
@ %def S10
<<S70>>=
this.lu_pstr.put("S70", SEL+"sid, sq, se, sl, so, sd, sb FROM S WHERE sid=?");
@ %def S70
<<S11>>=
this.lu_pstr.put("S11", INS+"CW VALUES "+q9);
@ %def S11
<<S12>>=
this.lu_pstr.put("S12", INS+"PD VALUES "+q4);
@ %def S12
<<S13>>=
this.lu_pstr.put("S13", INS+"CPD VALUES "+q12);
@ %def S13
<<S14>>=
this.lu_pstr.put("S14", INS+"CQ VALUES "+q14);
@ %def S14
<<S15>>=
this.lu_pstr.put("S15", UPD+"E SET nu=? WHERE v1=? AND v2=?");
@ %def S15
<<S131>>=
this.lu_pstr.put("S131", UPD+"W SET nu=? WHERE v1=? AND v2=?");
@ %def S131
<<S77>>=
this.lu_pstr.put("S77", UPD+"CW SET te=?, ve=? WHERE sid=?");
@ %def S77
<<S84>>=
this.lu_pstr.put("S84", UPD+"PD SET t2=? WHERE v2=? AND rid=?");
@ %def S84
<<S82>>=
this.lu_pstr.put("S82", UPD+"CPD SET tp=? WHERE vp=? AND rid=?");
@ %def S82
<<S83>>=
this.lu_pstr.put("S83", UPD+"CPD SET td=? WHERE vd=? AND rid=?");
@ %def S83
<<S76>>=
this.lu_pstr.put("S76", DEL+"W WHERE sid=? AND t2>?");
@ %def S76
<<S42>>=
this.lu_pstr.put("S42", DEL+"PD WHERE rid=?");
@ %def S42
<<S43>>=
this.lu_pstr.put("S43", DEL+"CPD WHERE rid=?");
@ %def S43
<<S80>>=
this.lu_pstr.put("S80", DEL+"CQ WHERE sid=? AND t2>?");
@ %def S80
<<S62>>=
this.lu_pstr.put("S62", SEL+"COUNT (*) FROM V WHERE v<>0");
@ %def S62
<<S64>>=
this.lu_pstr.put("S64", SEL+"MIN (lng), MAX (lng), MIN (lat), MAX (lat) "
      + "FROM V WHERE v<>0");
@ %def S64
<<S63>>=
this.lu_pstr.put("S63", SEL+"COUNT (*) FROM E WHERE v1<>0 AND v2<>0");
@ %def S63
<<S65>>=
this.lu_pstr.put("S65", SEL+"MIN (dd), MAX (dd), SUM (dd) / COUNT (dd), "
      + "MIN (nu), MAX (nu), SUM (nu) / COUNT (nu) "
      + "FROM E WHERE v1<>0 AND v2<>0");
@ %def S65
<<S46>>=
this.lu_pstr.put("S46", SEL+"dd, nu FROM E WHERE v1=? AND v2=?");
@ %def S46
<<S130>>=
this.lu_pstr.put("S130", SEL+"lng, lat FROM V WHERE v=?");
@ %def S130
<<S48>>=
this.lu_pstr.put("S48", SEL+"sq, se FROM S WHERE sid=?");
@ %def S48
<<S66>>=
this.lu_pstr.put("S66", SEL+"COUNT (*) FROM S");
@ %def S66
<<S75>>=
this.lu_pstr.put("S75", SEL+"rid, rq, re, rl, ro, rd, rb FROM R WHERE rid=?");
@ %def S75
<<S51>>=
this.lu_pstr.put("S51", SEL+"rq, re, rl, ro, rd FROM R WHERE rid=?");
@ %def S51
<<S67>>=
this.lu_pstr.put("S67", SEL+"COUNT (*) FROM R");
@ %def S67
<<S59>>=
this.lu_pstr.put("S59", SEL+"a.sid, a.t2, a.v2 FROM W AS a INNER JOIN ("
      + "SELECT sid, MIN(ABS(t2-?)) as tdiff FROM W WHERE t2<=? AND v2<>0 "
      + "GROUP BY sid"
      + ") as b ON a.sid=b.sid AND ABS(a.t2-?)=b.tdiff AND a.t2<=?");
@ %def S59
<<S128>>=
this.lu_pstr.put("S128", SEL+"a.sid, a.t2, a.v2 FROM W AS a INNER JOIN ("
      + "SELECT sid FROM CW WHERE te>? OR (ve=0 AND sl>?)"
      + ") as b ON a.sid=b.sid INNER JOIN ("
      + "SELECT sid, MIN(ABS(t2-?)) as tdiff FROM W WHERE t2<=? AND v2<>0 "
      + "GROUP BY sid"
      + ") as c ON a.sid=c.sid AND ABS(a.t2-?)=c.tdiff AND a.t2<=?");
@ %def S128
<<S60>>=
this.lu_pstr.put("S60", SEL+"t, v FROM r_server WHERE sid=? ORDER BY t ASC");
@ %def S60
<<S129>>=
this.lu_pstr.put("S129", SEL+"t, v FROM r_server WHERE sid=? AND t>? ORDER BY t ASC");
@ %def S129
<<S152>>=
this.lu_pstr.put("S152", SEL+"t, v FROM r_server WHERE sid=? AND t>? ORDER BY t ASC FETCH FIRST ? ROWS ONLY");
@ %def S152
<<S61>>=
this.lu_pstr.put("S61", SEL+"t, v, Ls, Lr FROM r_server WHERE sid=?"
      + "AND (Ls IS NOT NULL OR Lr IS NOT NULL) ORDER BY t ASC");
@ %def S61
Need to join CQ in order to sort by order number [[o2]]. This query has
worse performance after W (r\_server), CQ, PD grow.
<<S69>>=
this.lu_pstr.put("S69", SEL+"t, v, Ls, Lr "
      + "FROM r_server LEFT JOIN CQ ON t=t2 and v=v2 and Lr=rid "
      + "WHERE r_server.sid=?"
      + "   AND (t>? OR v=0)"
      + "   AND (Ls IS NOT NULL OR Lr IS NOT NULL)"
      + "ORDER BY t ASC, o2 ASC");
@ %def S69
<<S68>>=
// A "timeout" of 30 seconds is hard-coded here
this.lu_pstr.put("S68", SEL+"* FROM R WHERE re<=? AND ?<=re+30 AND rid NOT IN  "
      + "(SELECT rid FROM assignments_r)");
@ %def S68
<<S85>>=
this.lu_pstr.put("S85", SEL+"uq FROM UQ WHERE uid=?");
@ %def S85
<<S86>>=
this.lu_pstr.put("S86", SEL+"tp, td FROM CPD WHERE rid=?");
@ %def S86
<<S73>>=
this.lu_pstr.put("S73", SEL+"q2 FROM CQ WHERE sid=? AND t2<=? "
      + "ORDER BY t2 DESC, q2 DESC FETCH FIRST ROW ONLY");
@ %def S73
<<S87>>=
this.lu_pstr.put("S87", SEL+"t2, q2, o2 FROM CQ WHERE sid=? AND t2<=? "
      + "ORDER BY t2 DESC, o2 DESC FETCH FIRST ROW ONLY");
@ %def S87
<<S100>>=
this.lu_pstr.put("S100", SEL+"rid FROM assignments WHERE t>? AND sid=?");
@ %def S100
<<S101>>=
this.lu_pstr.put("S101", SEL+"rid FROM assignments WHERE t<=? AND sid=?");
@ %def S101
<<S102>>=
this.lu_pstr.put("S102", SEL+"* FROM service_rate");
@ %def S102
<<S103>>=
this.lu_pstr.put("S103", SEL+"* FROM dist_base");
@ %def S103
<<S104>>=
this.lu_pstr.put("S104", SEL+"val FROM dist_s_travel WHERE sid=?");
@ %def S104
<<S105>>=
this.lu_pstr.put("S105", SEL+"SUM (val) FROM dist_s_travel");
@ %def S105
<<S106>>=
this.lu_pstr.put("S106", SEL+"val FROM dist_s_cruising WHERE sid=?");
@ %def S106
<<S107>>=
this.lu_pstr.put("S107", SEL+"SUM (val) FROM dist_s_cruising");
@ %def S107
<<S108>>=
this.lu_pstr.put("S108", SEL+"val FROM dist_s_service WHERE sid=?");
@ %def S108
<<S109>>=
this.lu_pstr.put("S109", SEL+"SUM (val) FROM dist_s_service");
@ %def S109
<<S110>>=
this.lu_pstr.put("S110", SEL+"val FROM dist_s_base");
@ %def S110
<<S111>>=
this.lu_pstr.put("S111", SEL+"val FROM dist_r_base");
@ %def S111
<<S112>>=
this.lu_pstr.put("S112", SEL+"val FROM dist_r_detour WHERE rid=?");
@ %def S112
<<S113>>=
this.lu_pstr.put("S113", SEL+"SUM (val) FROM dist_r_detour");
@ %def S113
<<S114>>=
this.lu_pstr.put("S114", SEL+"val FROM dist_r_transit WHERE rid=?");
@ %def S114
<<S115>>=
this.lu_pstr.put("S115", SEL+"SUM (val) FROM dist_r_transit");
@ %def S115
<<S116>>=
this.lu_pstr.put("S116", SEL+"val FROM dur_s_travel WHERE sid=?");
@ %def S116
<<S117>>=
this.lu_pstr.put("S117", SEL+"SUM (val) FROM dur_s_travel");
@ %def S117
<<S118>>=
this.lu_pstr.put("S118", SEL+"val FROM dur_r_pickup WHERE rid=?");
@ %def S118
<<S119>>=
this.lu_pstr.put("S119", SEL+"SUM (val) FROM dur_r_pickup");
@ %def S119
<<S120>>=
this.lu_pstr.put("S120", SEL+"val FROM dur_r_transit WHERE rid=?");
@ %def S120
<<S121>>=
this.lu_pstr.put("S121", SEL+"SUM (val) FROM dur_r_transit");
@ %def S121
<<S122>>=
this.lu_pstr.put("S122", SEL+"val FROM dur_r_travel WHERE rid=?");
@ %def S122
<<S123>>=
this.lu_pstr.put("S123", SEL+"SUM (val) FROM dur_r_travel");
@ %def S123
<<S124>>=
this.lu_pstr.put("S124", SEL+"val FROM t_r_depart WHERE rid=?");
@ %def S124
<<S125>>=
this.lu_pstr.put("S125", SEL+"val FROM t_s_depart WHERE sid=?");
@ %def S125
<<S126>>=
this.lu_pstr.put("S126", SEL+"val FROM t_r_arrive WHERE rid=?");
@ %def S126
<<S127>>=
this.lu_pstr.put("S127", SEL+"te FROM CW WHERE sid=?");
@ %def S127
<<S133>>=
this.lu_pstr.put("S133", SEL+"val FROM f_status WHERE rid=? AND t<=? "
    + "ORDER BY t DESC FETCH FIRST ROW ONLY");
@ %def S133
<<S134>>=
this.lu_pstr.put("S134", SEL+"sid, te FROM CW WHERE se<=? AND (?<te OR (ve=0 AND sl>?))");
@ %def S134
<<S135>>=
this.lu_pstr.put("S135", SEL+"t2, v2 FROM W WHERE sid=? AND t2=("
    + "SELECT t1 FROM W WHERE sid=? AND ? <= t1 AND t1 <= ? AND ? < t2)");
@ %def S135
<<S136>>=
this.lu_pstr.put("S136", SEL+"* FROM V");
@ %def S136
<<S137>>=
this.lu_pstr.put("S137", SEL+"* FROM E");
@ %def S137
<<S138>>=
this.lu_pstr.put("S138", SEL+"val FROM dist_r_unassigned");
@ %def S138
<<S139>>=
this.lu_pstr.put("S139", UPD+"CPD SET te=? WHERE sid=?");
@ %def S139
<<S140>>=
this.lu_pstr.put("S140", UPD+"CQ SET tp=?, td=? WHERE rid=?");
@ %def S140
<<S141>>=
this.lu_pstr.put("S141", SEL+"* FROM r_user");
@ %def S141
<<S142>>=
this.lu_pstr.put("S142", SEL+"SUM (dd) FROM W WHERE sid=? AND t2>?");
@ %def S142
<<S143>>=
this.lu_pstr.put("S143", SEL+"* FROM R WHERE re<=? AND ?<=re+?");
@ %def S143
<<S144>>=
this.lu_pstr.put("S144", SEL+"t2, v2, rid FROM CQ WHERE sid=? AND t2>? ORDER BY o2 ASC");
@ %def S144
<<S145>>=
this.lu_pstr.put("S145", SEL+"te, ve FROM CW WHERE sid=?");
@ %def S145
<<S147>>=
this.lu_pstr.put("S147", SEL+"t2, v2 FROM W WHERE sid=? AND t2=("
    + "SELECT t1 FROM W WHERE sid=? AND v2=0)");
@ %def S147
<<S148>>=
this.lu_pstr.put("S148", SEL+"1 FROM assignments_r WHERE rid=?");
@ %def S148
<<S149>>=
this.lu_pstr.put("S149", SEL+"t2, v2 FROM W WHERE sid=? ORDER BY t2 ASC");
@ %def S149
<<S150>>=
this.lu_pstr.put("S150", SEL+"sid, val FROM violations_t_s");
@ %def S150
<<S151>>=
this.lu_pstr.put("S151", SEL+"rid, val FROM violations_t_r");
@ %def S151

\subsection{\texttt{PSCreate}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[PSCreate]]}(2) returns a JDBC [[PreparedStatement]] for the
statement string identified by [[k]] (param. 2) on the connection given in
param. 1.  A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Connection [[conn]] (param. 1):&a JDBC connection.\\
String [[k]] (param. 2):&statement identifier.\\
\end{tabular}\\
\textbf{Returns:} a prepared statement on the connection in param. 1 of the
statement string identified by param. 2.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: PSCreate(2)>>=
PreparedStatement PSCreate(final Connection conn, final String k) throws SQLException {
  PreparedStatement p = null;
  try {
    p = conn.prepareStatement(lu_pstr.get(k),
      ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    p.clearBatch();
    p.clearParameters();
  } catch (SQLException e) {
    throw e;
  }
  return p;
}
@ %def PSCreate

\subsection{\texttt{PSAdd}(2..)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[PSAdd]]}(2..) adds a prepared statement to
the execution batch.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Prepared statement [[p]] (param. 1):&a prepared statement.\\
Integer... [[values]] (param. 2..):&values to use in the statement, in order of appearance.\\
\end{tabular}\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} adds to the execution batch for the statement in param. 1.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: PSAdd(2..)>>=
void PSAdd(PreparedStatement p, final Integer... values) throws SQLException {
  p.clearParameters();
  <<Set statement values>>
  try {
    p.addBatch();
  } catch (SQLException e) {
    throw e;
  }
}
@ %def PSAdd

\subsection{\texttt{PSSubmit}(1..)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[PSSubmit]]}(1..) executes a prepared statement's batch.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Prepared statement [[p]] (param. 1..):&prepared statements.
\end{tabular}\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} may modify tables in the Jargo database.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: PSSubmit(1..)>>=
void PSSubmit(PreparedStatement... statements) throws SQLException {
  try {
    for (PreparedStatement p : statements) {
      p.executeBatch();
      p.close();
    }
  } catch (SQLException e) {
    throw e;
  }
}
@ %def PSSubmit

\subsection{\texttt{PSQuery}(3..)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[PSQuery]]}(3..) executes a predefined [[SELECT]]
query against the Jargo database instance and returns the results in a
flattened array. A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Connection [[conn]] (param. 1):&a JDBC connection.\\
String [[k]] (param. 2):&statement identifier.\\
Integer [[ncols]] (param. 3):&number of columns in the selection.\\
Integer... [[values]] (param. 4..):&values to use in the statement, in order
of appearance.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node {...};
 &\node[draw] {$in+j:\textrm{value at column $j$, row $i$ of the result set}$};
 &\node {...};\\
};
\end{tikzpicture}

where $i$, $j$ start from 0.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: PSQuery(3..)>>=
int[] PSQuery(final Connection conn, final String k, final int ncols, final Integer... values)
throws SQLException {
  int[] output = new int[] { };
  try {
    PreparedStatement p = PSCreate(conn, k);
    <<Set statement values>>
    ResultSet res = p.executeQuery();
    if (res.last() == true) {
      <<Flatten results>>
    }
    res.close();
    p.close();
  } catch (SQLException e) {
    throw e;
  }
  return output;
}
@ %def PSQuery

\section{Methods: Getters}

\subsection{\texttt{getRefCacheEdges}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[getRefCacheEdges]]}(0) returns a read-only
reference to [[lu_edges]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} a read-only reference to [[lu_edges]].\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Get: getRefCacheEdges(0)>>=
final ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>> getRefCacheEdges() {
  return this.lu_edges;
}
@ %def getRefCacheEdges

\subsection{\texttt{getRefCacheUsers}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[getRefCacheUsers]]}(0) returns a read-only
reference to [[lu_users]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} a read-only reference to [[lu_users]].\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Get: getRefCacheUsers(0)>>=
final ConcurrentHashMap<Integer, int[]> getRefCacheUsers() {
  return this.lu_users;
}
@ %def getRefCacheUsers


\subsection{\texttt{getRefCacheVertices}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[getRefCacheVertices]]}(0) returns a read-only
reference to [[lu_vertices]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} a read-only reference to [[lu_vertices]].\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Get: getRefCacheVertices(0)>>=
final ConcurrentHashMap<Integer, int[]> getRefCacheVertices() {
  return this.lu_vertices;
}
@ %def getRefCacheVertices

\subsection{\texttt{getRefCommunicator}(0)}
<<Get: getRefCommunicator(0)>>=
Communicator getRefCommunicator() {
  return this.communicator;
}
@ %def getRefCommunicator

\subsection{\texttt{getRefStorage}(0)}
<<Get: getRefStorage(0)>>=
Storage getRefStorage() {
  return this.storage;
}
@ %def getRefStorage

\subsection{\texttt{getClock(0)}}
<<Get: getClock(0)>>=
int getClock() {
  return this.statControllerClock;
}
@ %def getClock

\subsection{\texttt{retrieveQueueSize}(0)}
<<Get: retrieveQueueSize(0)>>=
int retrieveQueueSize() {
  return this.client.getStatClientQueueSize();
}
@ %def retrieveQueueSize

\subsection{\texttt{retrieveClock}(0)}
<<Get: retrieveClock(0)>>=
int retrieveClock() {
  return this.controller.getClock();
}
@ %def retrieveClock

\subsection{\texttt{retrieveRefCacheVertices}(0)}
<<Get: retrieveRefCacheVertices(0)>>=
final ConcurrentHashMap<Integer, int[]> retrieveRefCacheVertices() {
  return this.storage.getRefCacheVertices();
}
@ %def retrieveRefCacheVertices

\subsection{\texttt{retrieveRefCacheEdges}(0)}
<<Get: retrieveRefCacheEdges(0)>>=
final ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>> retrieveRefCacheEdges() {
  return this.storage.getRefCacheEdges();
}
@ %def retrieveRefCacheEdges

\subsection{\texttt{retrieveRefCacheUsers}(0)}
<<Get: retrieveRefCacheUsers(0)>>=
final ConcurrentHashMap<Integer, int[]> retrieveRefCacheUsers() {
  return this.storage.getRefCacheUsers();
}
@ %def retrieveRefCacheUsers


\section{Methods: Setters}

\subsection{\texttt{setClockReference}(1)}
<<Set: setClockReference(1)>>=
void setClockReference(final String clock_reference) throws IllegalArgumentException {
  int hour = Integer.parseInt(clock_reference.substring(0, 2));
  if (!(0 <= hour && hour <= 23)) {
    throw new IllegalArgumentException("Invalid clock reference (hour got "+hour+"; must be between [00, 23])");
  }
  int minute = Integer.parseInt(clock_reference.substring(2, 4));
  if (!(0 <= minute && minute <= 59)) {
    throw new IllegalArgumentException("Invalid clock reference (minute got "+minute+"; must be between [00, 59])");
  }
  this.statControllerClockReferenceHour= hour;
  this.statControllerClockReferenceMinute = minute;
}
@ %def setClockReference

\subsection{\texttt{setClockStart}(1)}
<<Set: setClockStart(1)>>=
void setClockStart(final int clock_start) {
  this.CLOCK_START = clock_start;
}
@ %def setClockStart

\subsection{\texttt{setClockEnd}(1)}
<<Set: setClockEnd(1)>>=
void setClockEnd(final int clock_end) {
  this.CLOCK_END = clock_end;
}
@ %def setClockEnd

\subsection{\texttt{setQueueTimeout}(1)}
<<Set: setQueueTimeout(1)>>=
void setQueueTimeout(final int queue_timeout) {
  this.QUEUE_TIMEOUT = queue_timeout;
}
@ %def setQueueTimeout

\subsection{\texttt{setRequestTimeout}(1)}
<<Set: setRequestTimeout(1)>>=
void setRequestTimeout(final int request_timeout) {
  this.REQUEST_TIMEOUT = request_timeout;
}
@ %def setRequestTimeout


\subsection{\texttt{setRefCacheVertices}(1)}
<<Set: setRefCacheVertices(1)>>=
void setRefCacheVertices(final ConcurrentHashMap<Integer, int[]> lu_vertices) {
  this.lu_vertices = lu_vertices;
}
@ %def setRefCacheVertices

\subsection{\texttt{setRefCacheEdges}(1)}
<<Set: setRefCacheEdges(1)>>=
void setRefCacheEdges(final ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>> lu_edges) {
  this.lu_edges = lu_edges;
}
@ %def setRefCacheEdges

\subsection{\texttt{setRefCacheUsers}(1)}
<<Set: setRefCacheUsers(1)>>=
void setRefCacheUsers(final ConcurrentHashMap<Integer, int[]> lu_users) {
  this.lu_users = lu_users;
}
@ %def setRefCacheUsers

\subsection{\texttt{setRefClient}(1)}
<<Set: setRefClient(1)>>=
void setRefClient(final Client client) {
  this.client = client;
}
@ %def setRefClient

\subsection{\texttt{setRefCommunicator}(1)}
<<Set: setRefCommunicator(1)>>=
void setRefCommunicator(final Communicator communicator) {
  this.communicator = communicator;
}
@ %def setRefCommunicator

\subsection{\texttt{setRefController}(1)}
<<Set: setRefController(1)>>=
void setRefController(final Controller controller) {
  this.controller = controller;
}
@ %def setRefController

\subsection{\texttt{setRefStorage}(1)}
<<Set: setRefStorage(1)>>=
void setRefStorage(final Storage storage) {
  this.storage = storage;
}
@ %def setRefStorage

\subsection{\texttt{setRefTraffic}(1)}
<<Set: setRefTraffic(1)>>=
void setRefTraffic (final Traffic traffic) {
  this.traffic = traffic;
  this.traffic.forwardRefCacheVertices(this.storage.getRefCacheVertices());
  this.traffic.forwardRefCacheEdges(this.storage.getRefCacheEdges());
}
@ %def setRefTraffic

\subsection{\texttt{forwardRefTraffic}(1)}
<<Set: forwardRefTraffic(1)>>=
void forwardRefTraffic(final Traffic traffic) {
  this.communicator.setRefTraffic(traffic);
}
@ %def forwardRefTraffic

\subsection{\texttt{forwardRefCommunicator}(1)}
<<Set: forwardRefCommunicator(1)>>=
void forwardRefCommunicator(final Communicator communicator) {
  this.client.setRefCommunicator(communicator);
}
@ %def forwardRefCommunicator

\subsection{\texttt{forwardRefCacheEdges}(1)}
<<Set: forwardRefCacheEdges(1)>>=
void forwardRefCacheEdges(final ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>> lu_edges) {
  this.tools.setRefCacheEdges(lu_edges);
}
@ %def forwardRefCacheEdges

\subsection{\texttt{forwardRefCacheUsers}(1)}
<<Set: forwardRefCacheUsers(1)>>=
void forwardRefCacheUsers(final ConcurrentHashMap<Integer, int[]> lu_users) {
  this.tools.setRefCacheUsers(lu_users);
}
@ %def forwardRefCacheUsers

\subsection{\texttt{forwardRefCacheVertices}(1)}
<<Set: forwardRefCacheVertices(1)>>=
void forwardRefCacheVertices(final ConcurrentHashMap<Integer, int[]> lu_vertices) {
  this.tools.setRefCacheVertices(lu_vertices);
}
@ %def forwardRefCacheVertices

