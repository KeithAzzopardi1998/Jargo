\chapter{Administration, Settings, and Glue}
\label{admin}

\section{Chunks}

\subsection{Open \texttt{conn}}
<<Open [[conn]]>>=
Connection conn = DriverManager.getConnection(CONNECTIONS_POOL_URL)
@

\subsection{Set statement values}
<<Set statement values>>=
for (int i = 0; i < values.length; i++) {
  if (values[i] == null) {
    p.setNull((i + 1), java.sql.Types.INTEGER);
  } else {
    p.setInt ((i + 1), values[i]);
  }
}
@

\section{Methods: Administration}

\subsection{\texttt{DBCreateNewInstance}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBCreateNewInstance]]}(0) creates a new database
instance. It uses [[setupDriver]](0) to register the JDBC [[DriverManager]] to
the new instance.  If the DBCP2 [[PoolingDriver]] cannot be found, a
[[ClassNotFoundException]] is thrown. We consider this exception to be fatal
and we exit immediately.  On the other hand if a [[SQLException]] occurs, we
rethrow to let the caller handle it. This exception can occur if the driver
cannot access the database for whatever reason.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} initializes a new in-memory Derby instance,
or exits the JVM if the DBCP2 driver
cannot be loaded.\\
\textbf{Throws:} [[SQLException]] if database cannot be accessed for whatever
reason.\\
\bottomrule
\end{tabular}
<<Admin: DBCreateNewInstance(0)>>=
void DBCreateNewInstance() throws SQLException {
  try {
    this.setupDriver();
  } catch (SQLException e) {
    throw e;
  } catch (ClassNotFoundException e) {
    System.err.println("Fatail exception");
    e.printStackTrace();
    System.exit(1);
  }
}
@ %def DBCreateNewInstance
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[createNewInstance]]}(0) wraps [[DBCreateNewInstance]](0).\\
\bottomrule
\end{tabular}
<<Admin: createNewInstance(0)>>=
void createNewInstance() throws SQLException {
  this.storage.DBCreateNewInstance();
}
@ %def createNewInstance

\subsection{\texttt{DBCloseInstance}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBCloseInstance]]}(0) closes an existing Jargo
database instance.  If the instance closes successfully, a [[SQLException]]
with error code [[45000]] is thrown. Otherwise, some other error code is
thrown. In this case we rethrow to let the caller handle it.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} closes an existing Jargo database instance.\\
\textbf{Throws:} [[SQLException]] if database cannot be closed for whatever
reason.\\
\bottomrule
\end{tabular}
<<Admin: DBCloseInstance(0)>>=
void DBCloseInstance() throws SQLException {
  try {
    DriverManager.getConnection("jdbc:derby:memory:jargo;drop=true");
  } catch (SQLException e) {
    if (e.getErrorCode() != 45000) {
      throw e;
    }
  }
}
@ %def DBCloseInstance
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[closeInstance]]}(0) wraps [[DBCloseInstance]](0).\\
\bottomrule
\end{tabular}
<<Admin: closeInstance(0)>>=
void closeInstance() throws SQLException {
  this.storage.DBCloseInstance();
}
@ %def closeInstance

\subsection{\texttt{DBLoadDataModel}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBLoadDataModel]]}(0) loads the data model in
\S\ref{TODO} into the Jargo database instance. If the
data model cannot be loaded, a [[SQLException]] is thrown. We consider this
exception to be fatal and we exit immediately. Possible reasons for such an
exception might be because the caller forgot to first call
[[DBCreateNewInstance]](0) resulting in ``No suitable driver found'' (error
code 0), or because the caller previously called [[DBLoadBackup]](1) resulting
in ``Table/View V already exists'' (error code 20000). In either case we print
a hint to terminal to guide the debugging.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} loads the data model in \S\ref{TODO}
into the Jargo instance, or exits the JVM if failure occurs.\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Admin: DBLoadDataModel(0)>>=
void DBLoadDataModel() {
  try (<<Open [[conn]]>>) {
    Statement stmt = conn.createStatement();
    stmt.clearBatch();
    stmt.addBatch(<<Create Table V statement>>);
    stmt.addBatch(<<Create Table E statement>>);
    stmt.addBatch(<<Create Table UQ statement>>);
    stmt.addBatch(<<Create Table UE statement>>);
    stmt.addBatch(<<Create Table UL statement>>);
    stmt.addBatch(<<Create Table UO statement>>);
    stmt.addBatch(<<Create Table UD statement>>);
    stmt.addBatch(<<Create Table UB statement>>);
    stmt.addBatch(<<Create Table S statement>>);
    stmt.addBatch(<<Create Table R statement>>);
    stmt.addBatch(<<Create Table W statement>>);
    stmt.addBatch(<<Create Table PD statement>>);
    stmt.addBatch(<<Create Table CW statement>>);
    stmt.addBatch(<<Create Table CPD statement>>);
    stmt.addBatch(<<Create Table CQ statement>>);
    stmt.addBatch(<<Create View r\_user statement>>);
    stmt.addBatch(<<Create View r\_server statement>>);
    stmt.addBatch(<<Create View f\_distance\_blocks statement>>);
    stmt.addBatch(<<Create View f\_status statement (Eq.~\ref{eq:status})>>);
    stmt.addBatch(<<Create View assignments statement (Eq.~\ref{eq:assignments})>>);
    stmt.addBatch(<<Create View assignments\_r statement (Eq.~\ref{eq:assigned-requests})>>);
    stmt.addBatch(<<Create View service\_rate statement (Eq.~\ref{eq:service-rate})>>);
    stmt.addBatch(<<Create View dist\_base statement (Eq.~\ref{eq:base-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_travel statement>>);
    stmt.addBatch(<<Create View dist\_s\_cruising statement (Eq.~\ref{eq:cruising-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_service statement (Eq.~\ref{eq:service-distance})>>);
    stmt.addBatch(<<Create View dist\_s\_base statement>>);
    stmt.addBatch(<<Create View dist\_r\_base statement>>);
    stmt.addBatch(<<Create View dist\_r\_unassigned statement>>);
    stmt.addBatch(<<Create View dist\_r\_transit statement (Eq.~\ref{eq:transit-distance})>>);
    stmt.addBatch(<<Create View dist\_r\_detour statement (Eq.~\ref{eq:detour-distance})>>);
    stmt.addBatch(<<Create View dur\_s\_travel statement>>);
    stmt.addBatch(<<Create View dur\_r\_pickup statement (Eq.~\ref{eq:pick-up delay})>>);
    stmt.addBatch(<<Create View dur\_r\_transit statement (Eq.~\ref{eq:transit-duration})>>);
    stmt.addBatch(<<Create View dur\_r\_travel statement (Eq.~\ref{eq:travel-duration})>>);
    stmt.addBatch(<<Create View t\_r\_depart statement (Eq.~\ref{eq:departure-time})>>);
    stmt.addBatch(<<Create View t\_s\_depart statement (Eq.~\ref{eq:departure-time})>>);
    stmt.addBatch(<<Create View t\_r\_arrive statement (Eq.~\ref{eq:arrival-time})>>);
    stmt.addBatch(<<Create View t\_s\_arrive statement (Eq.~\ref{eq:arrival-time})>>);
    stmt.addBatch(<<Create View violations\_t\_s>>);
    stmt.addBatch(<<Create View violations\_t\_r>>);
    stmt.addBatch("CREATE INDEX W_sid_t1 ON W (sid, t1)");
    stmt.addBatch("CREATE INDEX W_sid_t2 ON W (sid, t2)");
    stmt.addBatch("CREATE INDEX W_sid_v2 ON W (sid, v2)");
    stmt.addBatch("CREATE INDEX W_sid_t1_t2 ON W (sid, t1, t2)");
    stmt.executeBatch();
    conn.commit();
  } catch (SQLException e) {
    System.err.println("Fatal error.");
    if (e.getErrorCode() == 0) {
      System.err.println("(did you forget to call Storage.DBCreateNewInstance()?)");
    } else if (e.getErrorCode() == 20000) {
      System.err.println("(data model already exists from Storage.DBLoadBackup()?)");
    }
    e.printStackTrace(System.err);
    System.exit(1);
  }
}
@ %def DBLoadDataModel
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[loadDataModel]]}(0) wraps [[DBLoadDataModel]](0).\\
\bottomrule
\end{tabular}
<<Admin: loadDataModel(0)>>=
void loadDataModel() {
  this.storage.DBLoadDataModel();
}
@ %def loadDataModel

\subsection{\texttt{DBLoadBackup}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBLoadBackup]]}(1) loads a previously saved Jargo
database instance from disk into working memory. It uses [[setupDriver]](0) to
register the JDBC [[DriverManager]] to the new instance.  If the DBCP2
[[PoolingDriver]] cannot be found, a [[ClassNotFoundException]] is thrown. We
consider this exception to be fatal and we exit immediately.  On the other hand
if a [[SQLException]] occurs, we rethrow to let the caller handle it. This
exception can occur if the driver cannot access the database for whatever
reason.\\
\midrule
\textbf{Parameters:} \\
\hspace{2mm} String [[p]] (param. 1): path to directory where backup is located.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} loads backup into Jargo database instance, or exits the
JVM if failure occurs.\\
\textbf{Throws:} [[SQLException]] if database cannot be accessed, or
[[ClassNotFoundException]] if the DBCP2 driver cannot be found.\\
\bottomrule
\end{tabular}
<<Admin: DBLoadBackup(1)>>=
void DBLoadBackup(final String p) throws SQLException {
  this.CONNECTIONS_URL = "jdbc:derby:memory:jargo;createFrom="+p;
  try {
    this.setupDriver();
  } catch (ClassNotFoundException e) {
    System.out.println("Fatal error.");
    e.printStackTrace();
    System.exit(1);
  }
}
@ %def DBLoadBackup
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[loadBackup]]}(1) wraps [[DBLoadBackup]](1).\\
\bottomrule
\end{tabular}
<<Admin: loadBackup(1)>>=
void loadBackup(final String p) throws SQLException {
  this.storage.DBLoadBackup(p);
}
@ %def loadBackup

\subsection{\texttt{DBLoadRoadNetworkFromDB}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBLoadRoadNetworkFromDB]]}(0) loads two caches
[[lu_vertices]] and [[lu_edges]] using the vertices and edges data in Tables V
and E in the database. If queries on Tables V and E fail, this method throws a
[[SQLException]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} populates [[lu_vertices]] and [[lu_edges]].\\
\textbf{Throws:} [[SQLException]] if Tables V and E cannot be queried or
other database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: DBLoadRoadNetworkFromDB(0)>>=
void DBLoadRoadNetworkFromDB() throws SQLException {
@ %def DBLoadRoadNetworkFromDB
{\small Our approach is to create two temporary maps on the heap, populate the
temporary maps, then assign [[lu_vertices]] and [[lu_edges]] to reference the
temporary maps if all succeeds. This way we don't corrupt [[lu_vertices]] and
[[lu_edges]] in case of failure. (The approach might be overly cautious as it's
hard to imagine why this method would ever be called if the caches are already
populated.)}
<<Admin: DBLoadRoadNetworkFromDB(0)>>=
  ConcurrentHashMap<Integer, int[]>    lu1 = new ConcurrentHashMap<Integer, int[]>();
  ConcurrentHashMap<Integer,
    ConcurrentHashMap<Integer, int[]>> lu2 = new ConcurrentHashMap<Integer, ConcurrentHashMap<Integer, int[]>>();
@
{\small We start by querying the vertices.}
<<Admin: DBLoadRoadNetworkFromDB(0)>>=
  try {
    final int[] output = this.DBQueryAllVertices();
    for (int i = 0; i < (output.length - 2); i += 3) {
      final int   v = output[(i + 0)];
      final int lng = output[(i + 1)];
      final int lat = output[(i + 2)];
      lu1.put(v, new int[] { lng, lat });
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Then we go on to query the edges.}
<<Admin: DBLoadRoadNetworkFromDB(0)>>=
  try {
    final int[] output = this.DBQueryAllEdges();
    for (int i = 0; i < (output.length - 3); i += 4) {
      final int v1 = output[(i + 0)];
      final int v2 = output[(i + 1)];
      final int dd = output[(i + 2)];
      final int nu = output[(i + 3)];
      if (!lu2.containsKey(v1)) {
        lu2.put(v1, new ConcurrentHashMap<Integer, int[]>());
      }
      lu2.get(v1).put(v2, new int[] { dd, nu });
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Finally we do the assignment.}
<<Admin: DBLoadRoadNetworkFromDB(0)>>=
  this.lu_vertices = lu1;
  this.lu_edges    = lu2;
}
@
\noindent\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[loadRoadNetworkFromDB]]}(0) wraps [[DBLoadRoadNetworkFromDB]](0).\\
\bottomrule
\end{tabular}
<<Admin: loadRoadNetworkFromDB(0)>>=
void loadRoadNetworkFromDB() throws SQLException {
  this.storage.DBLoadRoadNetworkFromDB();
}
@ %def loadRoadNetworkFromDB



\subsection{\texttt{DBLoadUsersFromDB}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBLoadUsersFromDB]]}(0) loads the two caches
[[lu_users]] and [[lu_rstatus]] using data in the user and assignment tables in
the database. If queries on these tables fail, this method throws a
[[SQLException]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} populates [[lu_users]] and [[lu_rstatus]].\\
\textbf{Throws:} [[SQLException]] if user and assignment tables cannot be
queried or other database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: DBLoadUsersFromDB(0)>>=
void DBLoadUsersFromDB() throws SQLException {
@ %def DBLoadUsersFromDB
{\small Our approach follows the approach for [[DBLoadRoadNetworkFromDB]](0).
We start by creating two temporary maps on the heap.}
<<Admin: DBLoadUsersFromDB(0)>>=
  ConcurrentHashMap<Integer, int[]> lu1 = new ConcurrentHashMap<Integer, int[]>();
  Map<Integer, Boolean>             lu2 = new HashMap<Integer, Boolean>();
@
{\small Then we query the users.}
<<Admin: DBLoadUsersFromDB(0)>>=
  try {
    final int[] output = this.DBQueryAllUsers();
    for (int i = 0; i < (output.length - 6); i += 7) {
      final int uid = output[(i + 0)];
      final int  uq = output[(i + 1)];
      final int  ue = output[(i + 2)];
      final int  ul = output[(i + 3)];
      final int  uo = output[(i + 4)];
      final int  ud = output[(i + 5)];
      final int  ub = output[(i + 6)];
      lu1.put(uid, new int[] { uid, uq, ue, ul, uo, ud, ub });
@
{\small If the user is a request, in other words the user load is positive,
we query the request's assignment status.}
<<Admin: DBLoadUsersFromDB(0)>>=
      if (uq > 0) {
        lu2.put(uid, (this.DBQueryRequestIsAssigned(uid).length > 0 ? true : false));
      }
    }
  } catch (SQLException e) {
    throw e;
  }
@
{\small Finally we do the assignment.}
<<Admin: DBLoadUsersFromDB(0)>>=
  this.lu_users   = lu1;
  this.lu_rstatus = lu2;
}
@
\noindent\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[loadUsersFromDB]]}(0) wraps [[DBLoadUsersFromDB]](0).\\
\bottomrule
\end{tabular}
<<Admin: loadUsersFromDB(0)>>=
void loadUsersFromDB() throws SQLException {
  this.storage.DBLoadUsersFromDB();
}
@ %def loadUsersFromDB

\subsection{\texttt{DBSaveBackup}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBSaveBackup]]}(1) exports the Jargo database
instance to disk. If a [[SQLException]] occurs, we rethrow to let the caller
handle it.\\
\midrule
\textbf{Parameters:} \\
\hspace{2mm} String [[p]] (param. 1): path to directory where instance should
be exported to.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} writes the database to disk.\\
\textbf{Throws:} [[SQLException]] if failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: DBSaveBackup(1)>>=
void DBSaveBackup(final String p) throws SQLException {
  try (<<Open [[conn]]>>) {
    CallableStatement cs = conn.prepareCall("CALL SYSCS_UTIL.SYSCS_BACKUP_DATABASE('"+p+"')");
    cs.execute();
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBSaveBackup
\noindent\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[saveBackup]]}(1) wraps [[DBSaveBackup]](1).\\
\bottomrule
\end{tabular}
<<Admin: saveBackup(1)>>=
void saveBackup(final String p) throws SQLException {
  this.storage.DBSaveBackup(p);
}
@ %def saveBackup

\subsection{\texttt{DBFetch}(3..)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBFetch]]}(3..) executes a predefined [[SELECT]]
query against the Jargo database instance and returns the results in a
flattened array. A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Connection [[conn]] (param. 1):&a JDBC connection.\\
String [[k]] (param. 2):&statement identifier.\\
Integer [[ncols]] (param. 3):&number of columns in the selection.\\
Integer... [[values]] (param. 4..):&values to use in the statement, in order
of appearance.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node {...};
 &\node[draw] {$in+j:\textrm{value at column $j$, row $i$ of the result set}$};
 &\node {...};\\
};
\end{tikzpicture}

where $i$, $j$ start from 0.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: DBFetch(3..)>>=
int[] DBFetch(final Connection conn, final String k, final int ncols, final Integer... values)
throws SQLException {
  int[] output = new int[] { };
  try {
    PreparedStatement p = PS(conn, k);
    <<Set statement values>>
    ResultSet res = p.executeQuery();
    if (res.last() == true) {
      <<Flatten results>>
    }
    res.close();
    p.close();
  } catch (SQLException e) {
    throw e;
  }
  return output;
}
@ %def DBFetch

\subsection{\texttt{setupDriver}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[setupDriver]]}(0) registers a connection pool to the
JDBC driver.
The connection pool allows us to concurrently submit SQL
commands against the database from different threads.
A [[SQLException]] is thrown in case of database failure.
A [[ClassNotFoundException]] is thrown if the DBCP2 [[PoolingDriver]]
cannot be found.
Portions of this code are licensed by the Apache Software Foundation.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} registers a new connection pool to the JDBC driver manager.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered, or
[[ClassNotFoundException]] if the DBCP2 driver cannot be found.\\
\bottomrule
\end{tabular}
<<Admin: setupDriver(0)>>=
void setupDriver() throws SQLException, ClassNotFoundException {
  connection_factory = new DriverManagerConnectionFactory(CONNECTIONS_URL);
  poolableconnection_factory = new PoolableConnectionFactory(connection_factory, null);
  poolableconnection_factory.setPoolStatements(true);
  poolableconnection_factory.setDefaultAutoCommit(false);
  poolableconnection_factory.setMaxOpenPreparedStatements(STATEMENTS_MAX_COUNT);
  GenericObjectPoolConfig<PoolableConnection> cfg = new GenericObjectPoolConfig<PoolableConnection>();
  cfg.setMinIdle(100000);
  cfg.setMaxIdle(100000);
  cfg.setMaxTotal(100000);
  pool = new GenericObjectPool<PoolableConnection>(poolableconnection_factory, cfg);
  poolableconnection_factory.setPool(pool);
  Class.forName("org.apache.commons.dbcp2.PoolingDriver");
  driver = (PoolingDriver) DriverManager.getDriver(CONNECTIONS_DRIVER_URL);
  driver.registerPool(CONNECTIONS_POOL_NAME, pool);
}
@ %def setupDriver

\subsection{\texttt{PSInit}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[PSInit]]}(0) initializes the statement cache
[[lu_pstr]].\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} populates [[lu_pstr]].\\
\textbf{Throws:} nothing.\\
\bottomrule
\end{tabular}
<<Admin: PSInit(0)>>=
void PSInit() {
  final String INS = "INSERT INTO ";
  final String UPD = "UPDATE ";
  final String DEL = "DELETE FROM ";
  final String SEL = "SELECT ";
  final String q2  = "(?,?)";
  final String q3  = "(?,?,?)";
  final String q4  = "(?,?,?,?)";
  final String q7  = "(?,?,?,?,?,?,?)";
  final String q8  = "(?,?,?,?,?,?,?,?)";
  final String q9  = "(?,?,?,?,?,?,?,?,?)";
  final String q12 = "(?,?,?,?,?,?,?,?,?,?,?,?)";
  final String q14 = "(?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
  <<S0>> <<S1>> <<S2>> <<S3>> <<S4>> <<S5>> <<S6>> <<S7>> <<S8>> <<S9>> <<S10>>
  <<S11>> <<S12>> <<S13>> <<S14>> <<S15>> <<S131>> <<S77>> <<S84>> <<S82>>
  <<S83>> <<S76>> <<S42>> <<S43>> <<S80>> <<S62>> <<S64>> <<S63>> <<S65>>
  <<S46>> <<S130>> <<S70>> <<S48>> <<S66>> <<S75>> <<S51>> <<S67>> <<S59>>
  <<S128>> <<S60>> <<S129>> <<S61>> <<S69>> <<S68>> <<S85>> <<S86>> <<S73>>
  <<S87>> <<S100>> <<S101>> <<S102>> <<S103>> <<S104>> <<S105>> <<S106>>
  <<S107>> <<S108>> <<S109>> <<S110>> <<S111>> <<S112>> <<S113>> <<S114>>
  <<S115>> <<S116>> <<S117>> <<S118>> <<S119>> <<S120>> <<S121>> <<S122>>
  <<S123>> <<S124>> <<S125>> <<S126>> <<S127>> <<S133>> <<S134>> <<S135>>
  <<S136>> <<S137>> <<S138>> <<S139>> <<S140>> <<S141>> <<S142>> <<S143>>
  <<S144>> <<S145>> <<S147>> <<S148>> <<S149>> <<S150>> <<S151>>
}
@ %def PSInit
<<S0>>=
this.lu_pstr.put("S0", INS+"V VALUES "+q3);
@ %def S0
<<S1>>=
this.lu_pstr.put("S1", INS+"E VALUES "+q4);
@ %def S1
<<S2>>=
this.lu_pstr.put("S2", INS+"UQ VALUES "+q2);
@ %def S2
<<S3>>=
this.lu_pstr.put("S3", INS+"UE VALUES "+q2);
@ %def S3
<<S4>>=
this.lu_pstr.put("S4", INS+"UL VALUES "+q2);
@ %def S4
<<S5>>=
this.lu_pstr.put("S5", INS+"UO VALUES "+q2);
@ %def S5
<<S6>>=
this.lu_pstr.put("S6", INS+"UD VALUES "+q2);
@ %def S6
<<S7>>=
this.lu_pstr.put("S7", INS+"UB VALUES "+q2);
@ %def S7
<<S8>>=
this.lu_pstr.put("S8", INS+"S VALUES "+q7);
@ %def S8
<<S9>>=
this.lu_pstr.put("S9", INS+"R VALUES "+q7);
@ %def S9
<<S10>>=
this.lu_pstr.put("S10", INS+"W VALUES "+q8);
@ %def S10
<<S70>>=
this.lu_pstr.put("S70", SEL+"sid, sq, se, sl, so, sd, sb FROM S WHERE sid=?");
@ %def S70
<<S11>>=
this.lu_pstr.put("S11", INS+"CW VALUES "+q9);
@ %def S11
<<S12>>=
this.lu_pstr.put("S12", INS+"PD VALUES "+q4);
@ %def S12
<<S13>>=
this.lu_pstr.put("S13", INS+"CPD VALUES "+q12);
@ %def S13
<<S14>>=
this.lu_pstr.put("S14", INS+"CQ VALUES "+q14);
@ %def S14
<<S15>>=
this.lu_pstr.put("S15", UPD+"E SET nu=? WHERE v1=? AND v2=?");
@ %def S15
<<S131>>=
this.lu_pstr.put("S131", UPD+"W SET nu=? WHERE v1=? AND v2=?");
@ %def S131
<<S77>>=
this.lu_pstr.put("S77", UPD+"CW SET te=?, ve=? WHERE sid=?");
@ %def S77
<<S84>>=
this.lu_pstr.put("S84", UPD+"PD SET t2=? WHERE v2=? AND rid=?");
@ %def S84
<<S82>>=
this.lu_pstr.put("S82", UPD+"CPD SET tp=? WHERE vp=? AND rid=?");
@ %def S82
<<S83>>=
this.lu_pstr.put("S83", UPD+"CPD SET td=? WHERE vd=? AND rid=?");
@ %def S83
<<S76>>=
this.lu_pstr.put("S76", DEL+"W WHERE sid=? AND t2>?");
@ %def S76
<<S42>>=
this.lu_pstr.put("S42", DEL+"PD WHERE rid=?");
@ %def S42
<<S43>>=
this.lu_pstr.put("S43", DEL+"CPD WHERE rid=?");
@ %def S43
<<S80>>=
this.lu_pstr.put("S80", DEL+"CQ WHERE sid=? AND t2>?");
@ %def S80
<<S62>>=
this.lu_pstr.put("S62", SEL+"COUNT (*) FROM V WHERE v<>0");
@ %def S62
<<S64>>=
this.lu_pstr.put("S64", SEL+"MIN (lng), MAX (lng), MIN (lat), MAX (lat) "
      + "FROM V WHERE v<>0");
@ %def S64
<<S63>>=
this.lu_pstr.put("S63", SEL+"COUNT (*) FROM E WHERE v1<>0 AND v2<>0");
@ %def S63
<<S65>>=
this.lu_pstr.put("S65", SEL+"MIN (dd), MAX (dd), SUM (dd) / COUNT (dd), "
      + "MIN (nu), MAX (nu), SUM (nu) / COUNT (nu) "
      + "FROM E WHERE v1<>0 AND v2<>0");
@ %def S65
<<S46>>=
this.lu_pstr.put("S46", SEL+"dd, nu FROM E WHERE v1=? AND v2=?");
@ %def S46
<<S130>>=
this.lu_pstr.put("S130", SEL+"lng, lat FROM V WHERE v=?");
@ %def S130
<<S48>>=
this.lu_pstr.put("S48", SEL+"sq, se FROM S WHERE sid=?");
@ %def S48
<<S66>>=
this.lu_pstr.put("S66", SEL+"COUNT (*) FROM S");
@ %def S66
<<S75>>=
this.lu_pstr.put("S75", SEL+"rid, rq, re, rl, ro, rd, rb FROM R WHERE rid=?");
@ %def S75
<<S51>>=
this.lu_pstr.put("S51", SEL+"rq, re, rl, ro, rd FROM R WHERE rid=?");
@ %def S51
<<S67>>=
this.lu_pstr.put("S67", SEL+"COUNT (*) FROM R");
@ %def S67
<<S59>>=
this.lu_pstr.put("S59", SEL+"a.sid, a.t2, a.v2 FROM W AS a INNER JOIN ("
      + "SELECT sid, MIN(ABS(t2-?)) as tdiff FROM W WHERE t2<=? AND v2<>0 "
      + "GROUP BY sid"
      + ") as b ON a.sid=b.sid AND ABS(a.t2-?)=b.tdiff AND a.t2<=?");
@ %def S59
<<S128>>=
this.lu_pstr.put("S128", SEL+"a.sid, a.t2, a.v2 FROM W AS a INNER JOIN ("
      + "SELECT sid FROM CW WHERE te>? OR (ve=0 AND sl>?)"
      + ") as b ON a.sid=b.sid INNER JOIN ("
      + "SELECT sid, MIN(ABS(t2-?)) as tdiff FROM W WHERE t2<=? AND v2<>0 "
      + "GROUP BY sid"
      + ") as c ON a.sid=c.sid AND ABS(a.t2-?)=c.tdiff AND a.t2<=?");
@ %def S128
<<S60>>=
this.lu_pstr.put("S60", SEL+"t, v FROM r_server WHERE sid=? ORDER BY t ASC");
@ %def S60
<<S129>>=
this.lu_pstr.put("S129", SEL+"t, v FROM r_server WHERE sid=? AND t>? ORDER BY t ASC");
@ %def S129
<<S61>>=
this.lu_pstr.put("S61", SEL+"t, v, Ls, Lr FROM r_server WHERE sid=?"
      + "AND (Ls IS NOT NULL OR Lr IS NOT NULL) ORDER BY t ASC");
@ %def S61
Need to join CQ in order to sort by order number [[o2]]. This query has
worse performance after W (r\_server), CQ, PD grow.
<<S69>>=
this.lu_pstr.put("S69", SEL+"t, v, Ls, Lr "
      + "FROM r_server LEFT JOIN CQ ON t=t2 and v=v2 and Lr=rid "
      + "WHERE r_server.sid=?"
      + "   AND (t>? OR v=0)"
      + "   AND (Ls IS NOT NULL OR Lr IS NOT NULL)"
      + "ORDER BY t ASC, o2 ASC");
@ %def S69
<<S68>>=
// A "timeout" of 30 seconds is hard-coded here
this.lu_pstr.put("S68", SEL+"* FROM R WHERE re<=? AND ?<=re+30 AND rid NOT IN  "
      + "(SELECT rid FROM assignments_r)");
@ %def S68
<<S85>>=
this.lu_pstr.put("S85", SEL+"uq FROM UQ WHERE uid=?");
@ %def S85
<<S86>>=
this.lu_pstr.put("S86", SEL+"tp, td FROM CPD WHERE rid=?");
@ %def S86
<<S73>>=
this.lu_pstr.put("S73", SEL+"q2 FROM CQ WHERE sid=? AND t2<=? "
      + "ORDER BY t2 DESC, q2 DESC FETCH FIRST ROW ONLY");
@ %def S73
<<S87>>=
this.lu_pstr.put("S87", SEL+"t2, q2, o2 FROM CQ WHERE sid=? AND t2<=? "
      + "ORDER BY t2 DESC, o2 DESC FETCH FIRST ROW ONLY");
@ %def S87
<<S100>>=
this.lu_pstr.put("S100", SEL+"rid FROM assignments WHERE t>? AND sid=?");
@ %def S100
<<S101>>=
this.lu_pstr.put("S101", SEL+"rid FROM assignments WHERE t<=? AND sid=?");
@ %def S101
<<S102>>=
this.lu_pstr.put("S102", SEL+"* FROM service_rate");
@ %def S102
<<S103>>=
this.lu_pstr.put("S103", SEL+"* FROM dist_base");
@ %def S103
<<S104>>=
this.lu_pstr.put("S104", SEL+"val FROM dist_s_travel WHERE sid=?");
@ %def S104
<<S105>>=
this.lu_pstr.put("S105", SEL+"SUM (val) FROM dist_s_travel");
@ %def S105
<<S106>>=
this.lu_pstr.put("S106", SEL+"val FROM dist_s_cruising WHERE sid=?");
@ %def S106
<<S107>>=
this.lu_pstr.put("S107", SEL+"SUM (val) FROM dist_s_cruising");
@ %def S107
<<S108>>=
this.lu_pstr.put("S108", SEL+"val FROM dist_s_service WHERE sid=?");
@ %def S108
<<S109>>=
this.lu_pstr.put("S109", SEL+"SUM (val) FROM dist_s_service");
@ %def S109
<<S110>>=
this.lu_pstr.put("S110", SEL+"val FROM dist_s_base");
@ %def S110
<<S111>>=
this.lu_pstr.put("S111", SEL+"val FROM dist_r_base");
@ %def S111
<<S112>>=
this.lu_pstr.put("S112", SEL+"val FROM dist_r_detour WHERE rid=?");
@ %def S112
<<S113>>=
this.lu_pstr.put("S113", SEL+"SUM (val) FROM dist_r_detour");
@ %def S113
<<S114>>=
this.lu_pstr.put("S114", SEL+"val FROM dist_r_transit WHERE rid=?");
@ %def S114
<<S115>>=
this.lu_pstr.put("S115", SEL+"SUM (val) FROM dist_r_transit");
@ %def S115
<<S116>>=
this.lu_pstr.put("S116", SEL+"val FROM dur_s_travel WHERE sid=?");
@ %def S116
<<S117>>=
this.lu_pstr.put("S117", SEL+"SUM (val) FROM dur_s_travel");
@ %def S117
<<S118>>=
this.lu_pstr.put("S118", SEL+"val FROM dur_r_pickup WHERE rid=?");
@ %def S118
<<S119>>=
this.lu_pstr.put("S119", SEL+"SUM (val) FROM dur_r_pickup");
@ %def S119
<<S120>>=
this.lu_pstr.put("S120", SEL+"val FROM dur_r_transit WHERE rid=?");
@ %def S120
<<S121>>=
this.lu_pstr.put("S121", SEL+"SUM (val) FROM dur_r_transit");
@ %def S121
<<S122>>=
this.lu_pstr.put("S122", SEL+"val FROM dur_r_travel WHERE rid=?");
@ %def S122
<<S123>>=
this.lu_pstr.put("S123", SEL+"SUM (val) FROM dur_r_travel");
@ %def S123
<<S124>>=
this.lu_pstr.put("S124", SEL+"val FROM t_r_depart WHERE rid=?");
@ %def S124
<<S125>>=
this.lu_pstr.put("S125", SEL+"val FROM t_s_depart WHERE sid=?");
@ %def S125
<<S126>>=
this.lu_pstr.put("S126", SEL+"val FROM t_r_arrive WHERE rid=?");
@ %def S126
<<S127>>=
this.lu_pstr.put("S127", SEL+"val FROM t_s_arrive WHERE sid=?");
@ %def S127
<<S133>>=
this.lu_pstr.put("S133", SEL+"val FROM f_status WHERE rid=? AND t<=? "
    + "ORDER BY t DESC FETCH FIRST ROW ONLY");
@ %def S133
<<S134>>=
this.lu_pstr.put("S134", SEL+"sid, te FROM CW WHERE se<=? AND (?<te OR (ve=0 AND sl>?))");
@ %def S134
<<S135>>=
this.lu_pstr.put("S135", SEL+"t2, v2 FROM W WHERE sid=? AND t2=("
    + "SELECT t1 FROM W WHERE sid=? AND t1 <= ? AND ? < t2)");
@ %def S135
<<S136>>=
this.lu_pstr.put("S136", SEL+"* FROM V");
@ %def S136
<<S137>>=
this.lu_pstr.put("S137", SEL+"* FROM E");
@ %def S137
<<S138>>=
this.lu_pstr.put("S138", SEL+"val FROM dist_r_unassigned");
@ %def S138
<<S139>>=
this.lu_pstr.put("S139", UPD+"CPD SET te=? WHERE sid=?");
@ %def S139
<<S140>>=
this.lu_pstr.put("S140", UPD+"CQ SET tp=?, td=? WHERE rid=?");
@ %def S140
<<S141>>=
this.lu_pstr.put("S141", SEL+"* FROM r_user");
@ %def S141
<<S142>>=
this.lu_pstr.put("S142", SEL+"SUM (dd) FROM W WHERE sid=? AND t2>?");
@ %def S142
<<S143>>=
this.lu_pstr.put("S143", SEL+"* FROM R WHERE re<=? AND ?<=re+?");
@ %def S143
<<S144>>=
this.lu_pstr.put("S144", SEL+"t2, v2, rid FROM CQ WHERE sid=? AND t2>? ORDER BY o2 ASC");
@ %def S144
<<S145>>=
this.lu_pstr.put("S145", SEL+"te, ve FROM CW WHERE sid=?");
@ %def S145
<<S147>>=
this.lu_pstr.put("S147", SEL+"t2, v2 FROM W WHERE sid=? AND t2=("
    + "SELECT t1 FROM W WHERE sid=? AND v2=0)");
@ %def S147
<<S148>>=
this.lu_pstr.put("S148", SEL+"1 FROM assignments_r WHERE rid=?");
@ %def S148
<<S149>>=
this.lu_pstr.put("S149", SEL+"t2, v2 FROM W WHERE sid=? ORDER BY t2 ASC");
@ %def S149
<<S150>>=
this.lu_pstr.put("S150", SEL+"sid, val FROM violations_t_s");
@ %def S150
<<S151>>=
this.lu_pstr.put("S151", SEL+"rid, val FROM violations_t_r");
@ %def S151

\subsection{\texttt{PS}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[PS]]}(2) returns a JDBC [[PreparedStatement]] for the
statement string identified by [[k]] (param. 2) on the connection given in
param. 1.  A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Connection [[conn]] (param. 1):&a JDBC connection.\\
String [[k]] (param. 2):&statement identifier.\\
\end{tabular}\\
\textbf{Returns:} a prepared statement on the connection in param. 1 of the
statement string identified by param. 2.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: PS(2)>>=
PreparedStatement PS(final Connection conn, final String k) throws SQLException {
  PreparedStatement p = null;
  try {
    p = conn.prepareStatement(lu_pstr.get(k),
      ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    p.clearBatch();
    p.clearParameters();
  } catch (SQLException e) {
    throw e;
  }
  return p;
}
@ %def PS

\subsection{\texttt{PSAdd}(2..)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[PSAdd]]}(2..) adds a prepared statement to
the execution batch.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Prepared statement [[p]] (param. 1):&a prepared statement.\\
Integer... [[values]] (param. 2..):&values to use in the statement, in order of appearance.\\
\end{tabular}\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} adds to the execution batch for the statement in param. 1.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: PSAdd(2..)>>=
void PSAdd(PreparedStatement p, final Integer... values) throws SQLException {
  p.clearParameters();
  <<Set statement values>>
  try {
    p.addBatch();
  } catch (SQLException e) {
    throw e;
  }
}
@ %def PSAdd

\subsection{\texttt{PSSubmit}(1..)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[PSSubmit]]}(1..) executes a prepared statement's batch.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Prepared statement [[p]] (param. 1..):&prepared statements.
\end{tabular}\\
\textbf{Returns:} nothing.\\
\textbf{Side Effects:} may modify tables in the Jargo database.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Admin: PSSubmit(1..)>>=
void PSSubmit(PreparedStatement... statements) throws SQLException {
  try {
    for (PreparedStatement p : statements) {
      p.executeBatch();
      p.close();
    }
  } catch (SQLException e) {
    throw e;
  }
}
@ %def PSSubmit

\section{Methods: Settings}

\subsection{\texttt{setRequestTimeout}(1)}
<<Setting: setRequestTimeout(1)>>=
void setRequestTimeout(final int t) {
  this.REQUEST_TIMEOUT = t;
}
@ %def setRequestTimeout

\section{Methods: Glue}

