\chapter{Read Operations}
\label{read}

\section{Chunks}

\subsection{Flatten results}
<<Flatten results>>=
output = new int[(ncols*res.getRow())];
res.first();
do {
  for (int j = 1; j <= ncols; j++) {
    output[((res.getRow() - 1)*ncols + (j - 1))] = res.getInt(j);
  }
} while (res.next());
@

\section{Methods: General}

\subsection{\texttt{DBQuery}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQuery]]}(2) executes an arbitrary [[SELECT]]
query against the Jargo database instance.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
String [[sql]] (param. 1):&[[SELECT]] statement to execute.\\
Integer [[ncols]] (param. 2):&number of columns $n$ in the selection.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node {...};
 &\node[draw] {$in+j:\textrm{value at column $j$, row $i$ of the result set}$};
 &\node {...};\\
};
\end{tikzpicture}

where $i$, $j$ start from 0.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQuery(2)>>=
int[] DBQuery(final String sql, final int ncols) throws SQLException {
  int[] output = new int[] { };
  try (<<Open [[conn]]>>) {
    Statement stmt = conn.createStatement(
      ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    ResultSet res = stmt.executeQuery(sql);
    if (res.last()) {
      <<Flatten results>>
    }
    conn.close();
  } catch (SQLException e) {
    throw e;
  }
  return output;
}
@ %def DBQuery
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[query]]}(2) wraps [[DBQuery]](2).\\
\bottomrule
\end{tabular}
<<Read: query(2)>>=
int[] query(final String sql, final int ncols) throws SQLException {
  return this.storage.DBQuery(sql, ncols);
}
@ %def query

\section{Methods: Read Road Network}

\subsection{\texttt{DBQueryMBR}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMBR]]}(0) returns the minimum-bounding
rectangle of the road network.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{min. longitude}$};
 &\node {$1:\textrm{max. longitude}$};
 &\node {$2:\textrm{min. latitude}$};
 &\node {$3:\textrm{max. latitude}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMBR(0)>>=
int[] DBQueryMBR() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S64", 4);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMBR
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMBR]]}(0) wraps [[DBQueryMBR]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMBR(0)>>=
int[] queryMBR() throws SQLException {
  return this.storage.DBQueryMBR();
}
@ %def queryMBR

\subsection{\texttt{DBQueryVertex}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryVertex]]}(1) returns the longitude and
latitude coordinates of the given vertex. If the vertex does not exist,
a [[VertexNotFoundException]] is thrown.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[v]] (param. 1):&vertex identifier.
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{longitude of }\texttt{v}$};
 &\node {$1:\textrm{latitude of }\texttt{v}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[VertexNotFoundException]] if vertex does not exist\\
\bottomrule
\end{tabular}
<<Read: DBQueryVertex(1)>>=
int[] DBQueryVertex(final int v) throws VertexNotFoundException {
  if (!this.lu_vertices.containsKey(v)) {
    throw new VertexNotFoundException("Vertex "+v+" not found.");
  }
  int[] output = this.lu_vertices.get(v).clone();
  return new int[] { output[0], output[1], (int) Storage.CSHIFT };
}
@ %def DBQueryVertex
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryVertex]]}(1) wraps [[DBQueryVertex]](1).\\
\bottomrule
\end{tabular}
<<Read: queryVertex(1)>>=
int[] queryVertex(final int v) throws VertexNotFoundException, SQLException {
  return this.storage.DBQueryVertex(v);
}
@ %def queryVertex

\subsection{\texttt{DBQueryVertices}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryVertices]]}(0) returns all rows in Table V.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{vertex identifier}$};
 &\node {$1:\textrm{longitude of the vertex}$};
 &\node {$2:\textrm{latitude of the vertex}$};
 &\node {...};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryVertices(0)>>=
int[] DBQueryVertices() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S136", 3);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryVertices
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryVertices]]}(2) wraps [[DBQueryVertices]](2).\\
\bottomrule
\end{tabular}
<<Read: queryVertices(0)>>=
int[] queryVertices() throws SQLException {
  return this.storage.DBQueryVertices();
}
@ %def queryVertices

\subsection{\texttt{DBQueryVerticesCount}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryVerticesCount]]}(0) returns the total number
of vertices in Table V.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{number of vertices in Table V}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryVerticesCount(0)>>=
int[] DBQueryVerticesCount() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S62", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryVerticesCount
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryVerticesCount]]}(0) wraps [[DBQueryVerticesCount]](0).\\
\bottomrule
\end{tabular}
<<Read: queryVerticesCount(0)>>=
int[] queryVerticesCount() throws SQLException {
  return this.storage.DBQueryVerticesCount();
}
@ %def queryVerticesCount

\subsection{\texttt{DBQueryEdge}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryEdge]]}(2) returns the distance and
maximum free-flow speed along the given edge.
An [[EdgeNotFoundException]] is thrown if the edge does not exist.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[v1]] (param. 1):&source vertex identifier $v_1$\\
Integer [[v2]] (param. 2):&target vertex identifier $v_2$
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:d(v_1,v_2)$}; & \node {$1:v^\textrm{max}(v_1,v_2)$}; \\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[EdgeNotFoundException]] if edge does not exit.\\
\bottomrule
\end{tabular}
<<Read: DBQueryEdge(2)>>=
int[] DBQueryEdge(final int v1, final int v2) throws EdgeNotFoundException {
  if (!(this.lu_edges.containsKey(v1) && this.lu_edges.get(v1).containsKey(v2))) {
    throw new EdgeNotFoundException("Edge ("+v1+", "+v2+") not found.");
  }
  return this.lu_edges.get(v1).get(v2).clone();
}
@ %def DBQueryEdge
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryEdge]]}(2) wraps [[DBQueryEdge]](2).\\
\bottomrule
\end{tabular}
<<Read: queryEdge(2)>>=
int[] queryEdge(final int v1, final int v2) throws EdgeNotFoundException, SQLException {
  return this.storage.DBQueryEdge(v1, v2);
}
@ %def queryEdge

\subsection{\texttt{DBQueryEdges}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryEdges]]}(0) returns all rows in Table E.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{source vertex identifier $v_1$}$};
 &\node {$1:\textrm{target vertex identifier $v_2$}$};
 &\node {$2:d(v_1,v_2)$};
 &\node {$3:v^\textrm{max}(v_1,v_2)$};
 &\node {...};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryEdges(0)>>=
int[] DBQueryEdges() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S137", 4);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryEdges
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryEdges]]}(2) wraps [[DBQueryEdges]](2).\\
\bottomrule
\end{tabular}
<<Read: queryEdges(0)>>=
int[] queryEdges() throws SQLException {
  return this.storage.DBQueryEdges();
}
@ %def queryEdges

\subsection{\texttt{DBQueryEdgesCount}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryEdgesCount]]}(0) returns the total number
of vertices in Table V.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{number of edges in Table E}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryEdgesCount(0)>>=
int[] DBQueryEdgesCount() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S63", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryEdgesCount
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryEdgesCount]]}(0) wraps [[DBQueryEdgesCount]](0).\\
\bottomrule
\end{tabular}
<<Read: queryEdgesCount(0)>>=
int[] queryEdgesCount() throws SQLException {
  return this.storage.DBQueryEdgesCount();
}
@ %def queryEdgesCount

\subsection{\texttt{DBQueryEdgeStatistics}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryEdgeStatistics]]}(0) returns some edge statistics.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{min. weight}$};
 &\node {$1:\textrm{max. weight}$};
 &\node {$2:\textrm{avg. weight}$};
 &\node {$3:\textrm{min. speed}$};
 &\node {$4:\textrm{max. speed}$};
 &\node {$5:\textrm{avg. speed}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryEdgeStatistics(0)>>=
int[] DBQueryEdgeStatistics() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S65", 6);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryEdgeStatistics

\section{Methods: Read User Properties}

\subsection{\texttt{DBQueryUser}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryUser]]}(0) returns the properties of the
given user.
A [[UserNotFoundException]] is thrown if the user does not exist.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[uid]] (param. 1):&user identifier for user $u$
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{user identifier}$};
 &\node {$1:u_\texttt{q}$};
 &\node {$2:u_\texttt{e}$};
 &\node {$3:u_\texttt{l}$};
 &\node {$4:u_\texttt{o}$};
 &\node {$5:u_\texttt{d}$};
 &\node {$6:d_u$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[UserNotFoundException]] if user does not exist.\\
\bottomrule
\end{tabular}
<<Read: DBQueryUser(1)>>=
int[] DBQueryUser(final int uid)
throws UserNotFoundException {
  if (!this.lu_users.containsKey(uid)) {
    throw new UserNotFoundException("User "+uid+" not found.");
  }
  return this.lu_users.get(uid).clone();
}
@ %def DBQueryUser
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryUser]]}(1) wraps [[DBQueryUser]](1).\\
\bottomrule
\end{tabular}
<<Read: queryUser(1)>>=
int[] queryUser(final int rid) throws UserNotFoundException, SQLException {
  return storage.DBQueryUser(rid);
}
@ %def queryUser

\subsection{\texttt{DBQueryUsers}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryUsers]]}(0) returns all rows in view [[r_user]].
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{user identifier for user $u$}$};
 &\node {$1:u_\texttt{q}$};
 &\node {$2:u_\texttt{e}$};
 &\node {$3:u_\texttt{l}$};
 &\node {$4:u_\texttt{o}$};
 &\node {$5:u_\texttt{d}$};
 &\node {$6:d_u$};
 &\node {...};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryUsers(0)>>=
int[] DBQueryUsers() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S141", 7);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryUsers

\subsection{\texttt{DBQueryRequestStatus}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestStatus]]}(0) returns the status of
the given request at the given time (Eq.~\ref{eq:status}).
A [[UserNotFoundException]] is thrown if the user does not exist.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&user identifier for request $r$\\
Integer [[t]] (param. 2):&a time
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{status of $r$ at time $t$}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[UserNotFoundException]] if user does not exist, or
[[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestStatus(2)>>=
int[] DBQueryRequestStatus(final int rid, final int t)
throws UserNotFoundException, SQLException {
  if (!this.lu_users.containsKey(rid)) {
    throw new UserNotFoundException("User "+rid+" not found.");
  }
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S133", 1, rid, t);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestStatus
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryEdgeStatistics]]}(0) wraps [[DBQueryEdgeStatistics]](0).\\
\bottomrule
\end{tabular}
<<Read: queryEdgeStatistics(0)>>=
int[] queryEdgeStatistics() throws SQLException {
  return storage.DBQueryEdgeStatistics();
}
@ %def queryEdgeStatistics

\subsection{\texttt{DBQueryRequestIsAssigned}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestIsAssigned]]}(1) returns a
positive-length array if the given request is assigned (even if the request is
not yet picked-up), or [[null]] if the request is not.  A
[[UserNotFoundException]] is thrown if the user does not exist.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&user identifier for request $r$
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:1$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[UserNotFoundException]] if user does not exist, or
[[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestIsAssigned(1)>>=
int[] DBQueryRequestIsAssigned(final int rid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S148", 1, rid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestIsAssigned

\subsection{\texttt{DBQueryRequestDistanceDetour}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestDistanceDetour]]}(1) returns the
detour distance $D^\textrm{detour}(\mathcal{X},r)$
(Eq.~\ref{eq:detour-distance}) of the given request.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&request identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:D^\textrm{detour}(\mathcal{X},r)$};\\
};
\end{tikzpicture}

where $r$ is the request identified by [[rid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestDistanceDetour(1)>>=
int[] DBQueryRequestDistanceDetour(final int rid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S112", 1, rid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestDistanceDetour

\subsection{\texttt{DBQueryRequestDistanceTransit}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestDistanceTransit]]}(1) returns the
transit distance $D^\textrm{transit}(\mathcal{X},r)$
(Eq.~\ref{eq:transit-distance}) of the given request.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&request identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:D^\textrm{transit}(\mathcal{X},r)$};\\
};
\end{tikzpicture}

where $r$ is the request identified by [[rid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestDistanceTransit(1)>>=
int[] DBQueryRequestDistanceTransit(final int rid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S114", 1, rid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestDistanceTransit

\subsection{\texttt{DBQueryRequestDurationPickup}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestDurationPickup]]}(1) returns the
pickup delay $\delta^\textrm{pickup}(\mathcal{X},r)$
(Eq.~\ref{eq:pick-up delay}) of the given request.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&request identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\delta^\textrm{pickup}(\mathcal{X},r)$};\\
};
\end{tikzpicture}

where $r$ is the request identified by [[rid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestDurationPickup(1)>>=
int[] DBQueryRequestDurationPickup(final int rid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S118", 1, rid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestDurationPickup

\subsection{\texttt{DBQueryRequestDurationTransit}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestDurationTransit]]}(1) returns the
transit duration $\delta^\textrm{transit}(\mathcal{X},r)$
(Eq.~\ref{eq:transit-duration}) of the given request.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&request identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\delta^\textrm{transit}(\mathcal{X},r)$};\\
};
\end{tikzpicture}

where $r$ is the request identified by [[rid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestDurationTransit(1)>>=
int[] DBQueryRequestDurationTransit(final int rid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S120", 1, rid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestDurationTransit

\subsection{\texttt{DBQueryRequestDurationTravel}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestDurationTravel]]}(1) returns the
travel duration $\delta^\textrm{travel}(\mathcal{X},r)$
(Eq.~\ref{eq:travel-duration}) of the given request.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&request identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\delta^\textrm{travel}(\mathcal{X},r)$};\\
};
\end{tikzpicture}

where $r$ is the request identified by [[rid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestDurationTravel(1)>>=
int[] DBQueryRequestDurationTravel(final int rid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S122", 1, rid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestDurationTravel

\subsection{\texttt{DBQueryRequestTimeOfDeparture}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestTimeOfDeparture]]}(1) returns the
departure time $t^\textrm{depart}(\mathcal{X},r)$
(Eq.~\ref{eq:departure-time}) of the given request.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&request identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:t^\textrm{depart}(\mathcal{X},r)$};\\
};
\end{tikzpicture}

where $r$ is the request identified by [[rid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestTimeOfDeparture(1)>>=
int[] DBQueryRequestTimeOfDeparture(final int rid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S124", 1, rid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestTimeOfDeparture
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryRequestTimeOfDeparture]]}(1) wraps [[DBQueryRequestTimeOfDeparture]](1).\\
\bottomrule
\end{tabular}
<<Read: queryRequestTimeOfDeparture(1)>>=
int[] queryRequestTimeOfDeparture(final int rid) throws SQLException {
  return storage.DBQueryRequestTimeOfDeparture(rid);
}
@ %def queryRequestTimeOfDeparture

\subsection{\texttt{DBQueryRequestTimeOfArrival}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestTimeOfArrival]]}(1) returns the
arrival time $t^\textrm{arrive}(\mathcal{X},r)$
(Eq.~\ref{eq:arrival-time}) of the given request.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[rid]] (param. 1):&request identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:t^\textrm{arrive}(\mathcal{X},r)$};\\
};
\end{tikzpicture}

where $r$ is the request identified by [[rid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestTimeOfArrival(1)>>=
int[] DBQueryRequestTimeOfArrival(final int rid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S126", 1, rid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestTimeOfArrival
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryRequestTimeOfArrival]]}(1) wraps [[DBQueryRequestTimeOfArrival]](1).\\
\bottomrule
\end{tabular}
<<Read: queryRequestTimeOfArrival(1)>>=
int[] queryRequestTimeOfArrival(final int rid) throws SQLException {
  return storage.DBQueryRequestTimeOfArrival(rid);
}
@ %def queryRequestTimeOfArrival

\subsection{\texttt{DBQueryRequestsCount}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestsCount]]}(0) returns the total number
of requests in Table R.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{number of requests in Table R}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestsCount(0)>>=
int[] DBQueryRequestsCount() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S67", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryRequestsCount
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryRequestsCount]]}(0) wraps [[DBQueryRequestsCount]](0).\\
\bottomrule
\end{tabular}
<<Read: queryRequestsCount(0)>>=
int[] queryRequestsCount() throws SQLException {
  return storage.DBQueryRequestsCount();
}
@ %def queryRequestsCount

\subsection{\texttt{DBQueryRequestsQueued}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryRequestsQueued]]}(1) returns the requests
eligible for assignment at the given time. A request $r$ is ``eligible'' if it
is not assigned at the given time, and if the given time is between the
request's early time $r_\texttt{e}$ and
$(r_\texttt{e}+\texttt{REQUEST\_TIMEOUT})$.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[t]] (param. 1):&a time
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{user identifier for user $u$}$};
 &\node {$1:u_\texttt{q}$};
 &\node {$2:u_\texttt{e}$};
 &\node {$3:u_\texttt{l}$};
 &\node {$4:u_\texttt{o}$};
 &\node {$5:u_\texttt{d}$};
 &\node {$6:d_u$};
 &\node {...};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryRequestsQueued(1)>>=
int[] DBQueryRequestsQueued(final int t) throws SQLException {
  try (<<Open [[conn]]>>) {
@ %def DBQueryRequestsQueued
{\small Our approach is to first select all requests where $t$ is between the
request's early time $r_\texttt{e}$ and
$r_\texttt{e}+\texttt{REQUEST\_TIMEOUT}$.  Then, we return a filtered subset of
these requests that are unassigned. As we don't know how many requests will
returned in the end, we initialize a temporary array [[temp1]] to hold the
pre-filter number of requests.}
<<Read: DBQueryRequestsQueued(1)>>=
    final int[] output = this.PSQuery(conn, "S143", 7, t, t, REQUEST_TIMEOUT);
    int[] temp1 = new int[output.length];
    int j = 0;
    for (int i = 0; i < (output.length - 6); i += 7) {
      if (this.lu_rstatus.get(output[i]) == false) {
        temp1[(j + 0)] = output[(i + 0)];
        temp1[(j + 1)] = output[(i + 1)];
        temp1[(j + 2)] = output[(i + 2)];
        temp1[(j + 3)] = output[(i + 3)];
        temp1[(j + 4)] = output[(i + 4)];
        temp1[(j + 5)] = output[(i + 5)];
        temp1[(j + 6)] = output[(i + 6)];
        j += 7;
      }
    }
@
<<Read: DBQueryRequestsQueued(1)>>=
    return Arrays.copyOf(temp1, j);
  } catch (SQLException e) {
    throw e;
  }
}
@
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryRequestsQueued]]}(1) wraps [[DBQueryRequestsQueued]](1).\\
\bottomrule
\end{tabular}
<<Read: queryRequestsQueued(1)>>=
int[] queryRequestsQueued(final int t) throws SQLException {
  return storage.DBQueryRequestsQueued(t);
}
@ %def queryRequestsQueued

\subsection{\texttt{DBQueryServerRoute}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerRoute]]}(1) returns the route for the
given server identified by [[sid]] (param. 1) at time $t$ (param. 2).
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node {...};
 &\node[draw] {$2(i-1):\pi_\texttt{t}(w_i)$};
 &\node[draw] {$2(i-1)+1:\pi_\texttt{v}(w_i)$};
 &\node {...};\\
};
\end{tikzpicture}

where $1\leq i\leq |w|$ and $w$ is the route for the given server
identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerRoute(1)>>=
int[] DBQueryServerRoute(final int sid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S60", 2, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerRoute
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerRoute]]}(1) wraps [[DBQueryServerRoute]](1).\\
\bottomrule
\end{tabular}
<<Read: queryServerRoute(1)>>=
int[] queryServerRoute(final int sid) throws SQLException {
  return storage.DBQueryServerRoute(sid);
}
@ %def queryServerRoute

\subsection{\texttt{DBQueryServerRouteRemaining}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerRouteRemaining]]}(2) returns the
remaining route for the given server at the given time.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
Integer [[t]] (param. 2):&a time.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node {...};
 &\node[draw] {$2(i-1):\pi_\texttt{t}({(w_{>t}})_i)$};
 &\node[draw] {$2(i-1)+1:\pi_\texttt{v}({(w_{>t}})_i)$};
 &\node {...};\\
};
\end{tikzpicture}

where $1\leq i\leq |w_{>t}|$ and $w_{>t}$ is the remaining route for the
given server identified by [[sid]] (param. 1) at time $t$ (param. 2).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerRouteRemaining(2)>>=
int[] DBQueryServerRouteRemaining(final int sid, final int t) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S129", 2, sid, t);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerRouteRemaining
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerRouteRemaining]]}(2) wraps [[DBQueryServerRouteRemaining]](2).\\
\bottomrule
\end{tabular}
<<Read: queryServerRouteRemaining(2)>>=
int[] queryServerRouteRemaining(final int sid, final int t) throws SQLException {
  return this.storage.DBQueryServerRouteRemaining(sid, t);
}
@ %def queryServerRouteRemaining

\subsection{\texttt{DBQueryServerSchedule}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerSchedule]]}(1) returns the schedule
for the given server.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\scriptsize
\matrix[nodes={}] {
  \node {...};
 &\node[draw] {$4(j-1):\pi_\texttt{t}(b_j)$};
 &\node[draw] {$4(j-1)+1:\pi_\texttt{v}(b_j)$};
 &\node[draw] {$4(j-1)+2:\textrm{a server ID in }\pi_\texttt{L}(b_j)$};
 &\node[draw] {$4(j-1)+3:\textrm{a request ID in }\pi_\texttt{L}(b_j)$};
 &\node {...};\\
};
\end{tikzpicture}

where $1\leq j\leq |b|$ and $b$ is the schedule for the
given server  identified by [[sid]] (param. 1).
If a label is empty (\textit{e.g.} not all waypoints will have a server
identifier in their label set), the element will be 0. If a waypoint has
multiple labels, the waypoint will be written once for each of the labels.
The returned sequence is in time-ascending order but \textbf{is not guaranteed}
to be in the same order as the actual pick-ups and drop-offs, \textit{e.g.} if a
waypoint has multiple labels with some indicating pick-ups and some indicating
drop-offs, the ordering of these waypoints is uncertain.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerSchedule(1)>>=
int[] DBQueryServerSchedule(final int sid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S61", 4, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerSchedule
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerSchedule]]}(1) wraps [[DBQueryServerSchedule]](1).\\
\bottomrule
\end{tabular}
<<Read: queryServerSchedule(1)>>=
int[] queryServerSchedule(final int sid) throws SQLException {
  return storage.DBQueryServerSchedule(sid);
}
@ %def queryServerSchedule

\subsection{\texttt{DBQueryServerScheduleRemaining}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerScheduleRemaining]]}(2) returns the
remaining schedule for the given server at the given time.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
Integer [[t]] (param. 2):&a time.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\scriptsize
\matrix[nodes={}] {
  \node {...};
 &\node[draw] {$4(j-1):\pi_\texttt{t}((b_{>t})_j)$};
 &\node[draw] {$4(j-1)+1:\pi_\texttt{v}((b_{>t})_j)$};
 &\node[draw] {$4(j-1)+2:\textrm{a server ID in }\pi_\texttt{L}((b_{>t})_j)$};
 &\node[draw] {$4(j-1)+3:\textrm{a request ID in }\pi_\texttt{L}((b_{>t})_j)$};
 &\node {...};\\
};
\end{tikzpicture}

where $1\leq j\leq |b_{>t}|$ and $b_{>t}$ is the remaining schedule for the
given server identified by [[sid]] (param. 1) at time $t$ (param. 2).
If a label is empty (\textit{e.g.} not all waypoints will have a server
identifier in their label set), the element will be 0. If a waypoint has
multiple labels, the waypoint will be written once for each of the labels.
The returned sequence is in time-ascending order and \textbf{is guaranteed}
to be in the same order as the actual pick-ups and drop-offs.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerScheduleRemaining(2)>>=
int[] DBQueryServerScheduleRemaining(final int sid, final int t)
throws SQLException {
  int[] output = new int[] { };
  try (<<Open [[conn]]>>) {
    int[] temp = PSQuery(conn, "S144", 3, sid, t);
    output = new int[(4*temp.length/3 + 4)];
    int j = 0;
    for (int i = 0; i < (temp.length - 2); i += 3) {
      output[(j + 0)] = temp[(i + 0)];
      output[(j + 1)] = temp[(i + 1)];
      output[(j + 2)] = 0;
      output[(j + 3)] = temp[(i + 2)];
      j += 4;
    }
    temp = PSQuery(conn, "S145", 2, sid);
    output[(j + 0)] = temp[0];
    output[(j + 1)] = temp[1];
    output[(j + 2)] = sid;
    output[(j + 3)] = 0;
  } catch (SQLException e) {
    throw e;
  }
  return output;
}
@ %def DBQueryServerScheduleRemaining
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerScheduleRemaining]]}(2) wraps [[DBQueryServerScheduleRemaining]](2).\\
\bottomrule
\end{tabular}
<<Read: queryServerScheduleRemaining(2)>>=
int[] queryServerScheduleRemaining(final int sid, final int t) throws SQLException {
  return this.storage.DBQueryServerScheduleRemaining(sid, t);
}
@ %def queryServerScheduleRemaining

\subsection{\texttt{DBQueryServerLoadMax}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerLoadMax]]}(2) returns the maximum load
for the given server at the given time. The ``maximum load'' is equal to the
load burden $Q(\mathcal{X},s,t)$ \emph{plus} the sum of the loads of the
requests that are dropped off by the server at $t$. In other words it is the
number of occupied seats at $t$ before any drop-offs happen.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
Integer [[t]] (param. 2):&a time.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{maximum load on the server}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerLoadMax(2)>>=
int[] DBQueryServerLoadMax(final int sid, final int t) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S73", 1, sid, t);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerLoadMax
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerLoadMax]]}(2) wraps [[DBQueryServerLoadMax]](2).\\
\bottomrule
\end{tabular}
<<Read: queryServerLoadMax(2)>>=
int[] queryServerLoadMax(final int sid, final int t) throws SQLException {
  return this.storage.DBQueryServerLoadMax(sid, t);
}
@ %def queryServerLoadMax

\subsection{\texttt{DBQueryServerDistance}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerDistance]]}(1) returns the
travel distance $D(w)$ of the given server.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:D(w)$};\\
};
\end{tikzpicture}

where $w$ is the route of the given server identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerDistance(1)>>=
int[] DBQueryServerDistance(final int sid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S104", 1, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerDistance

\subsection{\texttt{DBQueryServerDistanceRemaining}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerDistanceRemaining]]}(2) returns the
remaining distance $D(w_{>t})$ for the given server at the given time.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
Integer [[t]] (param. 2):&a time.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:D(w_{>t})$};\\
};
\end{tikzpicture}

where $w_{>t}$ is the remaining route for the given server identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerDistanceRemaining(2)>>=
int[] DBQueryServerDistanceRemaining(final int sid, final int t)
throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S142", 1, sid, t);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerDistanceRemaining
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerDistanceRemaining]]}(2) wraps [[DBQueryServerDistanceRemaining]](2).\\
\bottomrule
\end{tabular}
<<Read: queryServerDistanceRemaining(2)>>=
int[] queryServerDistanceRemaining(final int sid, final int t) throws SQLException {
  return this.storage.DBQueryServerDistanceRemaining(sid, t);
}
@ %def queryServerDistanceRemaining

\subsection{\texttt{DBQueryServerDistanceCruising}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerDistanceCruising]]}(1) returns the
cruising distance $D^\textrm{cruise}(\mathcal{X},s)$
(Eq.~\ref{eq:cruising-distance}) of the given server.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:D^\textrm{cruise}(\mathcal{X},s)$};\\
};
\end{tikzpicture}

where $s$ is the server identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerDistanceCruising(1)>>=
int[] DBQueryServerDistanceCruising(final int sid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S106", 1, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerDistanceCruising

\subsection{\texttt{DBQueryServerDistanceService}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerDistanceService]]}(1) returns the
service distance $D^\textrm{service}(\mathcal{X},s)$
(Eq.~\ref{eq:service-distance}) of the given server.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:D^\textrm{service}(\mathcal{X},s)$};\\
};
\end{tikzpicture}

where $s$ is the server identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerDistanceService(1)>>=
int[] DBQueryServerDistanceService(final int sid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S108", 1, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerDistanceService

\subsection{\texttt{DBQueryServerDurationRemaining}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerDurationRemaining]]}(2) returns the
remaining duration $\delta(w_{>t})$ for the given server at the given time.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
Integer [[t]] (param. 2):&a time.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\delta(w_{>t})$};\\
};
\end{tikzpicture}

where $w_{>t}$ is the remaining route for the given server identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerDurationRemaining(2)>>=
int[] DBQueryServerDurationRemaining(final int sid, final int t)
throws SQLException {
  try (<<Open [[conn]]>>) {
    int[] output = PSQuery(conn, "S127", 1, sid, t);
    if (output != null) {
      output[0] -= t;
    }
    return output;
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerDurationRemaining
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerDurationRemaining]]}(2) wraps [[DBQueryServerDurationRemaining]](2).\\
\bottomrule
\end{tabular}
<<Read: queryServerDurationRemaining(2)>>=
int[] queryServerDurationRemaining(final int sid, final int t) throws SQLException {
  return this.storage.DBQueryServerDurationRemaining(sid, t);
}
@ %def queryServerDurationRemaining

\subsection{\texttt{DBQueryServerDurationTravel}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerDurationTravel]]}(1) returns the
travel duration $\delta^\textrm{travel}(\mathcal{X},r)$
(Eq.~\ref{eq:travel-duration}) of the given server.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\delta^\textrm{travel}(\mathcal{X},s)$};\\
};
\end{tikzpicture}

where $s$ is the server identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerDurationTravel(1)>>=
int[] DBQueryServerDurationTravel(final int sid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S116", 1, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerDurationTravel

\subsection{\texttt{DBQueryServerTimeOfDeparture}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerTimeOfDeparture]]}(1) returns the
departure time $t^\textrm{depart}(\mathcal{X},s)$
(Eq.~\ref{eq:departure-time}) of the given server.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:t^\textrm{depart}(\mathcal{X},s)$};\\
};
\end{tikzpicture}

where $s$ is the server identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerTimeOfDeparture(1)>>=
int[] DBQueryServerTimeOfDeparture(final int sid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S125", 1, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerTimeOfDeparture
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerTimeOfDeparture]]}(1) wraps [[DBQueryServerTimeOfDeparture]](1).\\
\bottomrule
\end{tabular}
<<Read: queryServerTimeOfDeparture(1)>>=
int[] queryServerTimeOfDeparture(final int sid) throws SQLException {
  return storage.DBQueryServerTimeOfDeparture(sid);
}
@ %def queryServerTimeOfDeparture


\subsection{\texttt{DBQueryServerTimeOfArrival}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerTimeOfArrival]]}(1) returns the
arrival time $t^\textrm{arrive}(\mathcal{X},s)$
(Eq.~\ref{eq:arrival-time}) of the given server.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:}\\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:t^\textrm{arrive}(\mathcal{X},s)$};\\
};
\end{tikzpicture}

where $s$ is the request identified by [[sid]] (param. 1).\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerTimeOfArrival(1)>>=
int[] DBQueryServerTimeOfArrival(final int sid) throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S127", 1, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerTimeOfArrival
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServerTimeOfArrival]]}(1) wraps [[DBQueryServerTimeOfArrival]](1).\\
\bottomrule
\end{tabular}
<<Read: queryServerTimeOfArrival(1)>>=
int[] queryServerTimeOfArrival(final int sid) throws SQLException {
  return storage.DBQueryServerTimeOfArrival(sid);
}
@ %def queryServerTimeOfArrival

\subsection{\texttt{DBQueryServerAssignmentsPending}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerAssignmentsPending]]}(2) returns the
requests that will be picked up by the given server beyond the given time.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
Integer [[t]] (param. 2):&a time.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node {...};
 &\node[draw] {$i:\textrm{identifier for request }r_i$};
 &\node {...};\\
};
\end{tikzpicture}

where $1\leq i\leq |R^\textrm{pending}(\mathcal{X}, s, t)|$,
$r_i\in R^\textrm{pending}(\mathcal{X}, s, t)$, and
$R^\textrm{pending}(\mathcal{X}, s, t)= (R(\mathcal{X},s,H)\setminus R(\mathcal{X},s,t))$ for
time horizon $H$, server $s$ identified by [[sid]] (param. 1), and time $t$ given by param. 2.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerAssignmentsPending(2)>>=
int[] DBQueryServerAssignmentsPending(final int sid, final int t)
throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S100", 1, t, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerAssignmentsPending

\subsection{\texttt{DBQueryServerAssignmentsCompleted}(2)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServerAssignmentsCompleted]]}(2) returns the
requests that have been dropped off by the given server on or before the given time,
in other words $R(\mathcal{X},s,t)$ (Eq.~\ref{eq:R(X,s,t)}).
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[sid]] (param. 1):&server identifier.\\
Integer [[t]] (param. 2):&a time.\\
\end{tabular}
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node {...};
 &\node[draw] {$i:\textrm{identifier for request }r_i$};
 &\node {...};\\
};
\end{tikzpicture}

where $1\leq i\leq |R(\mathcal{X},s,t)|$ and
$r_i\in R(\mathcal{X},s,t)$ for server $s$ identified by [[sid]] (param. 1)
at time $t$ given by param. 2.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServerAssignmentsCompleted(2)>>=
int[] DBQueryServerAssignmentsCompleted(final int sid, final int t)
throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S101", 1, t, sid);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServerAssignmentsCompleted

\subsection{\texttt{DBQueryServersCount}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryCountSevers]]}(0) returns the total number
of servers in Table S.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{number of servers in Table S}$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServersCount(0)>>=
int[] DBQueryServersCount() throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S66", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServersCount
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServersCount]]}(0) wraps [[DBQueryServersCount]](0).\\
\bottomrule
\end{tabular}
<<Read: queryServersCount(0)>>=
int[] queryServersCount() throws SQLException {
  return storage.DBQueryServersCount();
}
@ %def queryServersCount

\subsection{\texttt{DBQueryServersActive}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServersActive]]}(1) returns the identifiers
of the active servers at the given time. A server is ``active'' if its
service has not ended.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[t]] (param. 1):&a time
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{a server identifier}$};
 &\node {...};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServersActive(1)>>=
int[] DBQueryServersActive(final int t) throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S134", 1, t, t, t);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServersActive

\subsection{\texttt{DBQueryServersLocations}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryServersLocations]]}(1) returns the
last-known locations of all servers (including inactive servers) at the given
time. The ``last-known location'' is the waypoint in the server's route $w$
with a time component closest to but not exceeding the given time, in other
words ${w_{\leq t}}_{|w_{\leq t}|}$.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[t]] (param. 1):&a time
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{a server identifier}$};
 &\node {$1:\textrm{time of last-known location}$};
 &\node {$2:\textrm{vertex of last-known location}$};
 &\node {...};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServersLocations(1)>>=
int[] DBQueryServersLocations(final int t) throws SQLException {
  try (<<Open [[conn]]>>) {
    return this.PSQuery(conn, "S59", 3, t, t, t, t);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryServersLocations

\subsection{\texttt{DBQueryServersLocationsActive}(1)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
SINGLE-THREAD ONLY. Method \textcolor{blue}{[[DBQueryServersLocationsActive]]}(1) returns the
last-known locations of all active servers at the given time. A server is
``active'' if its service has not ended, in other words it has not arrived
at its own destination.
The ``last-known location'' is the waypoint in the server's route $w$
with a time component closest to but not exceeding the given time, in other
words ${w_{\leq t}}_{|w_{\leq t}|}$.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} \\
\begin{tabular}{lp{116mm}}
Integer [[t]] (param. 1):&a time
\end{tabular}\\
\textbf{Returns:} results of the query flattened into an integer array, or
[[null]] if no results.

\begin{tikzpicture}
\scriptsize
\matrix[nodes={minimum size=6mm}] {
  \node {...};
 &\node[draw] {$3(i-1):\textrm{identifier for server $s_i$}$};
 &\node[draw] {$3(i-1)+1:\pi_\texttt{t}\textrm{ of last-known location of $s_i$}$};
 &\node[draw] {$3(i-1)+2:\pi_\texttt{v}\textrm{ of last-known location of $s_i$}$};
 &\node {...};\\
};
\end{tikzpicture}\\

where $1\leq i\leq |\mathcal{S}^\textrm{active}|$,
$s_i\in \mathcal{S}^\textrm{active}$, and
$\mathcal{S}^\textrm{active}= \{s\in\mathcal{S}\mid t^\textrm{arrive}(\mathcal{X},s)>t\}|$
for $t$ given by param. 1.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryServersLocationsActive(1)>>=
int[] DBQueryServersLocationsActive(final int t) throws SQLException {
  int[] output = new int[] { };
  try (<<Open [[conn]]>>) {
    int j = 0;
@ %def DBQueryServersLocationsActive
{\small Our approach is to first use statement [[S134]] to get the active
servers. Then for each active server, we use either statement [[S135]] or
[[S147]] to get its last-known location.}
<<Read: DBQueryServersLocationsActive(1)>>=
    // Query S134 selects from CW. The query time is not expected to grow
    // because Table CW does not grow as we pre-load all the servers when we
    // load the problem instance.
    final int[] temp1 = this.PSQuery(conn, "S134", 2, t, t, t);  // <-- 10 ms/call
    output = new int[(3*(temp1.length/2))];
    for (int i = 0; i < temp1.length - 1; i += 2) {
      final int sid = temp1[(i + 0)];
      final int  te = temp1[(i + 1)];
      // Query S135 selects from W. The query time is expected to grow
      // O(log(|W|)) because we have indexes on the relevant columns,
      // implemented in Derby as B+trees (https://db.apache.org/derby/papers/btree_package.html).
      // The subquery in S135 is a range query with a tight range.
      // Query S147 is a key-lookup and also grows O(log(|W|)).
      final int lvt = this.lu_lvt.get(sid);
      final int[] temp2 = (t < te
        ? this.PSQuery(conn, "S135", 2, sid, sid, lvt, t, t)
        : this.PSQuery(conn, "S147", 2, sid, sid));
      output[(j + 0)] = sid;
      output[(j + 1)] = temp2[0];
      output[(j + 2)] = temp2[1];
      this.lu_lvt.put(sid, temp2[0]);
      j += 3;
    }
  } catch (SQLException e) {
    throw e;
  }
  return output;
}
@
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryServersLocationsActive]]}(1) wraps [[DBQueryServersLocationsActive]](1).\\
\bottomrule
\end{tabular}
<<Read: queryServersLocationsActive(1)>>=
int[] queryServersLocationsActive(final int t) throws SQLException {
  return this.storage.DBQueryServersLocationsActive(t);
}
@ %def queryServersLocationsActive

\section{Methods: Read Metrics}

\subsection{\texttt{DBQueryMetricServiceRate}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricServiceRate]]}(0) returns the
service rate $\mu$ (Eq.~\ref{eq:service-rate}).
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\mu\times 10^4$};\\
};
\end{tikzpicture}

Note that the service rate is \textbf{multiplied by $10^4$} so that it can be
returned as an integer with 2 decimal points precision, for example if
$\mu=.1234$, then [[DBQueryMetricServiceRate]](0) returns $1234$.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricServiceRate(0)>>=
int[] DBQueryMetricServiceRate() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S102", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricServiceRate
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricServiceRate]]}(0) wraps [[DBQueryMetricServiceRate]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricServiceRate(0)>>=
int[] queryMetricServiceRate() throws SQLException {
  return storage.DBQueryMetricServiceRate();
}
@ %def queryMetricServiceRate

\subsection{\texttt{DBQueryMetricUserDistanceBaseTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricUserDistanceBaseTotal]]}(0) returns the
base distance $D^\textrm{base}(\mathcal{U})$ (Eq.~\ref{eq:base-distance}).
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:D^\textrm{base}(\mathcal{U})$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricUserDistanceBaseTotal(0)>>=
int[] DBQueryMetricUserDistanceBaseTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S103", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricUserDistanceBaseTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricUserDistanceBaseTotal]]}(0) wraps [[DBQueryMetricUserDistanceBaseTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricUserDistanceBaseTotal(0)>>=
int[] queryMetricUserDistanceBaseTotal() throws SQLException {
  return storage.DBQueryMetricUserDistanceBaseTotal();
}
@ %def queryMetricUserDistanceBaseTotal

\subsection{\texttt{DBQueryMetricServerDistanceTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricServerDistanceTotal]]}(0) returns the
total travel distance of all the servers.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{s\in\mathcal{S}}D(W(\mathcal{X},s))$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricServerDistanceTotal(0)>>=
int[] DBQueryMetricServerDistanceTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S105", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricServerDistanceTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricServerDistanceTotal]]}(0) wraps [[DBQueryMetricServerDistanceTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricServerDistanceTotal(0)>>=
int[] queryMetricServerDistanceTotal() throws SQLException {
  return storage.DBQueryMetricServerDistanceTotal();
}
@ %def queryMetricServerDistanceTotal

\subsection{\texttt{DBQueryMetricServerDistanceBaseTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricServerDistanceBaseTotal]]}(0) returns the
base distance of all the servers.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{s\in\mathcal{S}}d_s$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricServerDistanceBaseTotal(0)>>=
int[] DBQueryMetricServerDistanceBaseTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S110", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricServerDistanceBaseTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricServerDistanceBaseTotal]]}(0) wraps [[DBQueryMetricServerDistanceBaseTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricServerDistanceBaseTotal(0)>>=
int[] queryMetricServerDistanceBaseTotal() throws SQLException {
  return storage.DBQueryMetricServerDistanceBaseTotal();
}
@ %def queryMetricServerDistanceBaseTotal

\subsection{\texttt{DBQueryMetricServerDistanceCruisingTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricServerDistanceCruisingTotal]]}(0) returns the
total cruising distance of all servers.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{s\in\mathcal{S}}D^\textrm{cruise}(\mathcal{X},s)$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricServerDistanceCruisingTotal(0)>>=
int[] DBQueryMetricServerDistanceCruisingTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S107", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricServerDistanceCruisingTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricServerDistanceCruisingTotal]]}(0) wraps [[DBQueryMetricServerDistanceCruisingTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricServerDistanceCruisingTotal(0)>>=
int[] queryMetricServerDistanceCruisingTotal() throws SQLException {
  return storage.DBQueryMetricServerDistanceCruisingTotal();
}
@ %def queryMetricServerDistanceCruisingTotal

\subsection{\texttt{DBQueryMetricServerDistanceServiceTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricServerDistanceServiceTotal]]}(0) returns the
total service distance of all servers.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{s\in\mathcal{S}}D^\textrm{service}(\mathcal{X},s)$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricServerDistanceServiceTotal(0)>>=
int[] DBQueryMetricServerDistanceServiceTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S109", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricServerDistanceServiceTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricServerDistanceServiceTotal]]}(0) wraps [[DBQueryMetricServerDistanceServiceTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricServerDistanceServiceTotal(0)>>=
int[] queryMetricServerDistanceServiceTotal() throws SQLException {
  return storage.DBQueryMetricServerDistanceServiceTotal();
}
@ %def queryMetricServerDistanceServiceTotal

\subsection{\texttt{DBQueryMetricServerDurationTravelTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricServerDurationTravelTotal]]}(0) returns the
total travel duration of all servers.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{s\in\mathcal{S}}\delta^\textrm{travel}(\mathcal{X},s)$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricServerDurationTravelTotal(0)>>=
int[] DBQueryMetricServerDurationTravelTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S117", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricServerDurationTravelTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricServerDurationTravelTotal]]}(0) wraps [[DBQueryMetricServerDurationTravelTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricServerDurationTravelTotal(0)>>=
int[] queryMetricServerDurationTravelTotal() throws SQLException {
  return storage.DBQueryMetricServerDurationTravelTotal();
}
@ %def queryMetricServerDurationTravelTotal

\subsection{\texttt{DBQueryMetricServerTWViolationsTotal}(0)}
<<Read: DBQueryMetricServerTWViolationsTotal(0)>>=
int[] DBQueryMetricServerTWViolationsTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S150", 2);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricServerTWViolationsTotal
<<Read: queryMetricServerTWViolationsTotal(0)>>=
int[] queryMetricServerTWViolationsTotal() throws SQLException {
  return storage.DBQueryMetricServerTWViolationsTotal();
}
@ %def queryMetricServerTWViolationsTotal

\subsection{\texttt{DBQueryMetricRequestDistanceBaseTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricRequestDistanceBaseTotal]]}(0) returns the
base distance of all the requests.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{r\in\mathcal{R}}d_r$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricRequestDistanceBaseTotal(0)>>=
int[] DBQueryMetricRequestDistanceBaseTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S111", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricRequestDistanceBaseTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricRequestDistanceBaseTotal]]}(0) wraps [[DBQueryMetricRequestDistanceBaseTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricRequestDistanceBaseTotal(0)>>=
int[] queryMetricRequestDistanceBaseTotal() throws SQLException {
  return storage.DBQueryMetricRequestDistanceBaseTotal();
}
@ %def queryMetricRequestDistanceBaseTotal

\subsection{\texttt{DBQueryMetricRequestDistanceBaseUnassignedTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricRequestDistanceBaseUnassignedTotal]]}(0) returns the
base distance of all the unassigned requests.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{r\in R^{ko}(\mathcal{X},H)}d_r$};\\
};
\end{tikzpicture}

where $H$ is the time horizon.\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricRequestDistanceBaseUnassignedTotal(0)>>=
int[] DBQueryMetricRequestDistanceBaseUnassignedTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S138", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricRequestDistanceBaseUnassignedTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricRequestDistanceBaseUnassignedTotal]]}(0) wraps [[DBQueryMetricRequestDistanceBaseUnassignedTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricRequestDistanceBaseUnassignedTotal(0)>>=
int[] queryMetricRequestDistanceBaseUnassignedTotal() throws SQLException {
  return storage.DBQueryMetricRequestDistanceBaseUnassignedTotal();
}
@ %def queryMetricRequestDistanceBaseUnassignedTotal

\subsection{\texttt{DBQueryMetricRequestDistanceDetourTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricRequestDistanceDetourTotal]]}(0) returns the
total detour distance of all requests.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{r\in\mathcal{R}}D^\textrm{detour}(\mathcal{X},r)$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricRequestDistanceDetourTotal(0)>>=
int[] DBQueryMetricRequestDistanceDetourTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S113", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricRequestDistanceDetourTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricRequestDistanceDetourTotal]]}(0) wraps [[DBQueryMetricRequestDistanceDetourTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricRequestDistanceDetourTotal(0)>>=
int[] queryMetricRequestDistanceDetourTotal() throws SQLException {
  return storage.DBQueryMetricRequestDistanceDetourTotal();
}
@ %def queryMetricRequestDistanceDetourTotal

\subsection{\texttt{DBQueryMetricRequestDistanceTransitTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricRequestDistanceTransitTotal]]}(0) returns the
total transit distance of all requests.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{r\in\mathcal{R}}D^\textrm{transit}(\mathcal{X},r)$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricRequestDistanceTransitTotal(0)>>=
int[] DBQueryMetricRequestDistanceTransitTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S115", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricRequestDistanceTransitTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricRequestDistanceTransitTotal]]}(0) wraps [[DBQueryMetricRequestDistanceTransitTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricRequestDistanceTransitTotal(0)>>=
int[] queryMetricRequestDistanceTransitTotal() throws SQLException {
  return storage.DBQueryMetricRequestDistanceTransitTotal();
}
@ %def queryMetricRequestDistanceTransitTotal

\subsection{\texttt{DBQueryMetricRequestDurationPickupTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricRequestDurationPickupTotal]]}(0) returns the
total pickup delay of all requests.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{r\in\mathcal{R}}\delta^\textrm{pickup}(\mathcal{X},r)$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricRequestDurationPickupTotal(0)>>=
int[] DBQueryMetricRequestDurationPickupTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S119", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricRequestDurationPickupTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricRequestDurationPickupTotal]]}(0) wraps [[DBQueryMetricRequestDurationPickupTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricRequestDurationPickupTotal(0)>>=
int[] queryMetricRequestDurationPickupTotal() throws SQLException {
  return storage.DBQueryMetricRequestDurationPickupTotal();
}
@ %def queryMetricRequestDurationPickupTotal

\subsection{\texttt{DBQueryMetricRequestDurationTransitTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricRequestDurationTransitTotal]]}(0) returns the
total transit duration of all requests.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{r\in\mathcal{R}}\delta^\textrm{transit}(\mathcal{X},r)$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricRequestDurationTransitTotal(0)>>=
int[] DBQueryMetricRequestDurationTransitTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S121", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricRequestDurationTransitTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricRequestDurationTransitTotal]]}(0) wraps [[DBQueryMetricRequestDurationTransitTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricRequestDurationTransitTotal(0)>>=
int[] queryMetricRequestDurationTransitTotal() throws SQLException {
  return storage.DBQueryMetricRequestDurationTransitTotal();
}
@ %def queryMetricRequestDurationTransitTotal

\subsection{\texttt{DBQueryMetricRequestDurationTravelTotal}(0)}
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[DBQueryMetricRequestDurationTravelTotal]]}(0) returns the
total travel duration of all requests.
A [[SQLException]] is thrown in case of database failure.\\
\midrule
\textbf{Parameters:} none.\\
\textbf{Returns:} results of the query flattened into an integer array,
or [[null]] if no results.

\begin{tikzpicture}
\small
\matrix[nodes={minimum size=6mm}] {
  \node[draw] {$0:\sum_{r\in\mathcal{R}}\delta^\textrm{travel}(\mathcal{X},r)$};\\
};
\end{tikzpicture}\\
\textbf{Side Effects:} none.\\
\textbf{Throws:} [[SQLException]] if database failure is encountered.\\
\bottomrule
\end{tabular}
<<Read: DBQueryMetricRequestDurationTravelTotal(0)>>=
int[] DBQueryMetricRequestDurationTravelTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S123", 1);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricRequestDurationTravelTotal
\begin{tabular}{p{\textwidth}}
\toprule
\rowcolor{TableTitle}
Method \textcolor{blue}{[[queryMetricRequestDurationTravelTotal]]}(0) wraps [[DBQueryMetricRequestDurationTravelTotal]](0).\\
\bottomrule
\end{tabular}
<<Read: queryMetricRequestDurationTravelTotal(0)>>=
int[] queryMetricRequestDurationTravelTotal() throws SQLException {
  return storage.DBQueryMetricRequestDurationTravelTotal();
}
@ %def queryMetricRequestDurationTravelTotal

\subsection{\texttt{DBQueryMetricRequestTWViolationsTotal}(0)}
<<Read: DBQueryMetricRequestTWViolationsTotal(0)>>=
int[] DBQueryMetricRequestTWViolationsTotal() throws SQLException {
  try (<<Open [[conn]]>>) {
    return PSQuery(conn, "S151", 2);
  } catch (SQLException e) {
    throw e;
  }
}
@ %def DBQueryMetricRequestTWViolationsTotal
<<Read: queryMetricRequestTWViolationsTotal(0)>>=
int[] queryMetricRequestTWViolationsTotal() throws SQLException {
  return storage.DBQueryMetricRequestTWViolationsTotal();
}
@ %def queryMetricRequestTWViolationsTotal
