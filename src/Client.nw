\chapter{Class: Client}
\label{client}

<<Client.java>>=
<<Client.java preamble>>
public abstract class Client {
  <<[[Client]] member variables>>
  <<[[Client]] constructor>>
  <<[[Client]] methods>>
}
@

We supply an abstract base class for developing Jargo client ridesharing
algorithms. The class provides a standard interface for interacting with the
simulation engine (Figure~\ref{fig:client}). Algorithm developers extend the
base class to add specific customer-to-vehicle matching and vehicle routing
functionality.

\section{Preamble}
The preamble declares the package and imports dependencies.
<<Client.java preamble>>=
package com.github.jargors;
@
We import [[Communicator]] so we can interact with the simulated world,
and we import [[LocalDateTime]] so we can query the physical time for
logging purposes.
<<Client.java preamble>>=
import com.github.jargors.Communicator;
import com.github.jargors.Tools;
import com.github.jargors.exceptions.ClientException;
import com.github.jargors.exceptions.ClientFatalException;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.io.FileNotFoundException;
@

\section{Member Variables}
<<[[Client]] member variables>>=
protected ConcurrentLinkedQueue<int[]> queue = new ConcurrentLinkedQueue<int[]>();
protected int r_collection_period = 1;  // how many sec before collecting new req?
protected int r_handling_period = 1;  // how many msec before handling queued req?
protected int s_collection_period = 10;
protected Communicator communicator;
protected Tools tools = new Tools();
protected final boolean DEBUG =
    "true".equals(System.getProperty("jargors.client.debug"));
@

\section{Constructor}
<<[[Client]] constructor>>=
public Client() { }
@

\section{Methods}

\subsection{\texttt{notifyNew}(0)}
<<notifyNew(0)>>=
void notifyNew() throws ClientException, ClientFatalException {
  while (!this.queue.isEmpty()) {
    this.handleRequest(this.queue.remove());
  }
}
@ %def notifyNew

\subsection{\texttt{collectRequest}(1)}
<<collectRequest(1)>>=
void collectRequest(final int[] r) {
  this.queue.add(r);
}
@ %def addRequest

\subsection{\texttt{collectServerLocations}(1)}
Array [[src]] =

\noindent
\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server }s$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};
 &\node[minimum width=12mm] {...};\\
};
\end{tikzpicture}

\noindent If locations are polled for and stored into [[src]] at $t'$ world
time, then formally the last location for server $s$ is defined as waypoint
$(t,v)$ that satisfies $t=\textrm{argmin}_{(t,v)\in w_{\leq t'}} (t-t')$, where
$w_{\leq t'}$ is the server's traveled route.  In other words the last location
is the waypoint in the server's traveled route that is nearest $t'$.  After
copying [[src]] into [[locations]], the [[endCollectServerLocations]](0) method
is executed.
<<collectServerLocations(1)>>=
void collectServerLocations(final int[] src) {
  this.endCollectServerLocations(src.clone());
}
@ %def collectServerLocations


\subsection{\texttt{registerCommunicator}(1)}
<<registerCommunicator(1)>>=
void registerCommunicator(final Communicator src) {
  this.communicator = src;
}
@ %def registerCommunicator

\subsection{\texttt{getRequestCollectionPeriod}(0)}
<<getRequestCollectionPeriod(0)>>=
int getRequestCollectionPeriod() {
  return this.r_collection_period;
}
@ %def getRequestCollectionPeriod

\subsection{\texttt{setRequestCollectionPeriod}(1)}
<<setRequestCollectionPeriod(1)>>=
void setRequestCollectionPeriod(final int t) {
  this.r_collection_period = t;
}
@ %def setRequestCollectionPeriod

\subsection{\texttt{getRequestHandlingPeriod}(0)}
<<getRequestHandlingPeriod(0)>>=
int getRequestHandlingPeriod() {
  return this.r_handling_period;
}
@ %def getRequestHandlingPeriod

\subsection{\texttt{setRequestHandlingPeriod}(1)}
<<setRequestHandlingPeriod(1)>>=
void setRequestHandlingPeriod(final int t) {
  this.r_handling_period = t;
}
@ %def setRequestHandlingPeriod

\subsection{\texttt{getServerLocationCollectionPeriod}(0)}
<<getServerLocationCollectionPeriod(0)>>=
int getServerLocationCollectionPeriod () {
  return this.s_collection_period;
}
@ %def getServerLocationCollectionPeriod

\subsection{\texttt{setServerLocationCollectionPeriod}(1)}
<<setServerLocationCollectionPeriod(1)>>=
void setServerLocationCollectionPeriod(final int t) {
  this.s_collection_period = t;
}
@ %def setServerLocationCollectionPeriod


\subsection{\texttt{registerRoadNetwork}(0)}
<<registerRoadNetwork(0)>>=
void registerRoadNetwork() {
  this.tools.registerVertices(this.communicator.forwardReferenceVerticesCache());
  this.tools.registerEdges(this.communicator.forwardReferenceEdgesCache());
}
@ %def registerRoadNetwork

\subsection{\texttt{registerUsers}(0)}
<<registerUsers(0)>>=
void registerUsers() {
  this.tools.registerUsers(this.communicator.forwardReferenceUsersCache());
}
@ %def registerUsers

\subsection{\texttt{endCollectServerLocations}(1)}
<<endCollectServerLocations(1)>>=
void endCollectServerLocations(final int[] locations) {
  for (int i = 0; i < (locations.length - 2); i += 3) {
    this.handleServerLocation(new int[] {
      locations[i],
      locations[(i + 1)],
      locations[(i + 2)]
    });
  }
}
@ %def endCollectServerLocations

\subsection{\texttt{end}(0)}
<<end(0)>>=
void end() { }
@ %def end

\subsection{\texttt{handleRequest}(1)}
Array [[r]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[rid]] of request $r$}$};
 &\node {$1:r_q$}; & \node {$2:r_e$}; & \node {$3:r_l$};
 &\node {$4:r_o$}; & \node {$5:r_d$}; & \node {$6:d_r$};\\
};
\end{tikzpicture}

<<handleRequest(1)>>=
void handleRequest(final int[] r) throws ClientException, ClientFatalException { }
@ %def handleRequest

\subsection{\texttt{handleServerLocation}(1)}
Array [[loc]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server $s$}$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};\\
};
\end{tikzpicture}

<<handleServerLocation(1)>>=
void handleServerLocation(final int[] loc) { }
@ %def handleServerLocation

