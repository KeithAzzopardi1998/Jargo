\documentclass{article}

\usepackage{noweb}
\noweboptions{smallcode,longchunks}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{colortbl}
\usepackage[colorlinks=true]{hyperref}
\usepackage{tikz}

\newcommand{\hi}[1]{\noindent {\bf #1}}     % Define a handy paragraph opener

\def\nwendcode{\endtrivlist \endgroup}      % Remove noweb page break penalty
\let\nwdocspar=\par

\title{Jargo Client\footnote{
    \url{https://github.com/jargors/Client}}}
\author{James J. Pan\\
  \small{\href{mailto:pan-j16@mails.tsinghua.edu.cn}{pan-j16@mails.tsinghua.edu.cn}}}

\begin{document}
\maketitle
\pagestyle{noweb}

\tableofcontents

\section{Introduction}
\label{sec:introduction}
We supply an abstract base class for developing Jargo client ridesharing
algorithms. The class provides a standard interface for interacting with the
simulation engine (Figure~\ref{fig:client}). Algorithm developers extend the
base class to add specific customer-to-vehicle matching and vehicle routing
functionality.  The base class is developed using the
Noweb\footnote{\url{https://www.cs.tufts.edu/~nr/noweb/}} literate
programming\footnote{\url{http://literateprogramming.com/}} tool.  This file
([[src/Client.nw]]) is the source for both the documentation
([[doc/Client.tex]]) and the Java code (Client.java)\footnote{See the
[[Makefile]] for build details.}.

\begin{figure}[h]
\centering
\includegraphics[width=150mm]{src/fig/client-fig}
\caption{Client within the Jargo stack.}
\label{fig:client}
\end{figure}

\section{Implementation Overview}
<<Client.java>>=
  <<Client.java preamble>>
  <<[[Client]] definition>>
@

\subsection{Preamble}
The preamble declares the package and imports dependencies.
<<Client.java preamble>>=
package com.github.jargors;
@
We import [[Communicator]] so we can interact with the simulated world,
and we import [[LocalDateTime]] so we can query the physical time for
logging purposes.
<<Client.java preamble>>=
import com.github.jargors.Communicator;
import com.github.jargors.Tools;
import java.util.function.Supplier;
import java.time.LocalDateTime;
@

\subsection{Class Definition}
The [[Client]] class consists of member variables, a constructor, and
public and protected methods. Note the [[abstract]] keyword indicates the class
cannot be used directly.
<<[[Client]] definition>>=
public abstract class Client {
  <<[[Client]] member variables>>
  <<[[Client]] constructor>>
  <<[[Client]] public methods>>
  <<[[Client]] protected methods>>
}
@

\subsection{Member Variables}
We define two containers for requests and server locations obtained from the
simulation engine. We also define the collection periods, in seconds. By
default, requests and server locations are collected every second.
<<[[Client]] member variables>>=
protected int[] requests;
protected int[] locations;
protected int r_collection_period = 1;
protected int s_collection_period = 10;
protected Communicator simulator;
protected Tools distance = new Tools();
@ %def requests locations r_collection_period s_collection_period simulator distance

\subsection{Constructor}
An actual algorithm might override the default constructor to perform
preprocessing tasks such as building a road network index.
<<[[Client]] constructor>>=
public Client() { }
@

\section{Public Methods}
<<[[Client]] public methods>>=
  <<Collect requests>>
  <<Collect server locations>>
  <<Set simulation interface>>
  <<Get/set request collection period>>
  <<Get/set server location collection period>>
  <<Compute haversine>>
@

\subsection{Obtaining Requests and Server Locations}
To obtain unassigned customer requests and server locations, we depend on
the simulation engine to push the data to the client. The [[collectRequests]](1)
and [[collectServerLocations]](1) methods simply copy [[src]] into
the client's working memory.

\subsubsection{[[collectRequests]](1)}
Array [[src]] =

\noindent
\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[rid]] of request }r$};
 &\node {$1:r_q$}; & \node {$2:r_e$}; & \node {$3:r_l$};
 &\node {$4:r_o$}; & \node {$5:r_d$}; & \node {$6:d_r$};
 &\node[minimum width=12mm] {...};\\
};
\end{tikzpicture}

\noindent containing all $r$ queued to be assigned\footnote{See
\url{https://github.com/jargors/Storage} to learn about Jargo's data model.}.
After copying [[src]] into [[requests]], the [[endCollectRequests]](0) method
is executed.
<<Collect requests>>=
public void collectRequests(int[] src) {
  requests = src.clone();
  endCollectRequests();
}
@ %def collectRequests

\subsubsection{[[collectServerLocations]](1)}
Array [[src]] =

\noindent
\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server }s$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};
 &\node[minimum width=12mm] {...};\\
};
\end{tikzpicture}

\noindent If locations are polled for and stored into [[src]] at $t'$ world
time, then formally the last location for server $s$ is defined as waypoint
$(t,v)$ that satisfies $t=\textrm{argmin}_{(t,v)\in w_{\leq t'}} (t-t')$, where
$w_{\leq t'}$ is the server's traveled route.  In other words the last location
is the waypoint in the server's traveled route that is nearest $t'$.  After
copying [[src]] into [[locations]], the [[endCollectServerLocations]](0) method
is executed.
<<Collect server locations>>=
public void collectServerLocations(int[] src) {
  locations = src.clone();
  endCollectServerLocations();
}
@ %def collectServerLocations

\subsection{Getters and Setters}

\subsubsection{[[setCommunicator]](1)}
<<Set simulation interface>>=
public void setCommunicator(Communicator src) {
  simulator = src;
}
@ %def setCommunicator

\subsubsection{[[getRequestCollectionPeriod]](0)}
<<Get/set request collection period>>=
public int getRequestCollectionPeriod() {
  return r_collection_period;
}
@ %def getRequestCollectionPeriod

\subsubsection{[[setRequestCollectionPeriod]](1)}
<<Get/set request collection period>>=
public void setRequestCollectionPeriod(int t) {
  r_collection_period = t;
}
@ %def setRequestCollectionPeriod

\subsubsection{[[getServerLocationCollectionPeriod]](0)}
<<Get/set server location collection period>>=
public int getServerLocationCollectionPeriod () {
  return s_collection_period;
}
@ %def getServerLocationCollectionPeriod

\subsubsection{[[setServerLocationCollectionPeriod]](1)}
<<Get/set server location collection period>>=
public void setServerLocationCollectionPeriod(int t) {
  s_collection_period = t;
}
@ %def setServerLocationCollectionPeriod

\subsubsection{[[computeHaversine]](2)}
<<Compute haversine>>=
public int computeHaversine(int u, int v) {
  int[] U = simulator.queryVertex(u);
  int[] V = simulator.queryVertex(v);
  return distance.computeHaversine(U[0], U[1], V[0], V[1]);
}
@ %def computeHaversine

\section{Private Methods}
<<[[Client]] protected methods>>=
  <<End collect requests>>
  <<End collect server locations>>
  <<Handle request>>
  <<Handle server location>>
  <<Print a message>>

@

\subsection{[[endCollectRequests]](0)}
After requests are collected, [[handleRequest]](1) is executed on each one.
<<End collect requests>>=
protected void endCollectRequests() {
  for (int i = 0; i < (requests.length - 6); i += 7) {
    handleRequest(new int[] {
      requests[i],
      requests[(i + 1)],
      requests[(i + 2)],
      requests[(i + 3)],
      requests[(i + 4)],
      requests[(i + 5)],
      requests[(i + 6)]
    });
  }
}
@ %def endCollectRequests

\subsection{[[endCollectServerLocations]](0)}
After server locations are collected, [[handleServerLocation]](1) is executed
on each one.
<<End collect server locations>>=
protected void endCollectServerLocations() {
  for (int i = 0; i < (locations.length - 2); i += 3) {
    handleServerLocation(new int[] {
      locations[i],
      locations[(i + 1)],
      locations[(i + 2)]
    });
  }
}
@ %def endCollectServerLocations

\subsection{[[handleRequest]](1)}
Array [[r]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[rid]] of request $r$}$};
 &\node {$1:r_q$}; & \node {$2:r_e$}; & \node {$3:r_l$};
 &\node {$4:r_o$}; & \node {$5:r_d$}; & \node {$6:d_r$};\\
};
\end{tikzpicture}

<<Handle request>>=
protected void handleRequest(int[] r) { }
@ %def handleRequest

\subsection{[[handleServerLocation]](1)}
Array [[loc]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server $s$}$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};\\
};
\end{tikzpicture}

<<Handle server location>>=
protected void handleServerLocation(int[] loc) { }
@ %def handleServerLocation

\subsection{[[Print]](1)}
<<Print a message>>=
protected void Print(String msg) {
  System.out.println("[Client]["+LocalDateTime.now()+"]"
    + "[t="+simulator.getSimulationWorldTime()+"] "+msg);
}
@ %def Print

\appendix

\section{Appendix: List of Chunks}
\label{ap:list-of-chunks}
\nowebchunks

\section{Appendix: List of Identifiers}
\label{ap:list-of-identifiers}
\nowebindex

\end{document}

