\chapter{Class: Client}
\label{client}

<<Client.java>>=
<<Client.java preamble>>
public abstract class Client {
  <<[[Client]] member variables>>
  <<[[Client]] constructor>>
  <<[[Client]] methods>>
}
@

We supply an abstract base class for developing Jargo client ridesharing
algorithms. The class provides a standard interface for interacting with the
simulation engine (Figure~\ref{fig:client}). Algorithm developers extend the
base class to add specific customer-to-vehicle matching and vehicle routing
functionality.

\section{Preamble}
The preamble declares the package and imports dependencies.
<<Client.java preamble>>=
package com.github.jargors;
@
We import [[Communicator]] so we can interact with the simulated world,
and we import [[LocalDateTime]] so we can query the physical time for
logging purposes.
<<Client.java preamble>>=
import com.github.jargors.Communicator;
import com.github.jargors.Tools;
import com.github.jargors.exceptions.ClientException;
import com.github.jargors.exceptions.ClientFatalException;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.io.FileNotFoundException;
@
<<Client.java preamble>>=
import com.github.jargors.jmx.ClientMonitor;
import java.lang.management.*;
import javax.management.*;
@

\section{Member Variables}
<<[[Client]] member variables>>=
protected ConcurrentLinkedQueue<int[]> queue = new ConcurrentLinkedQueue<int[]>();
protected Communicator communicator;
protected Tools tools = new Tools();
protected final boolean DEBUG =
    "true".equals(System.getProperty("jargors.client.debug"));
@
\section{Constructor}
<<[[Client]] constructor>>=
public Client() {
  <<[[Client]] register JMX monitor>>
}
@

\section{Methods}

\subsection{\texttt{notifyNew}(0)}
<<notifyNew(0)>>=
void notifyNew() throws ClientException, ClientFatalException {
  while (!this.queue.isEmpty()) {
    long A0 = System.currentTimeMillis();
    this.handleRequest(this.queue.remove());
    <<Stats: clientHandleRequest>>
  }
}
@ %def notifyNew

\subsection{\texttt{addRequest}(1)}
<<addRequest(1)>>=
void addRequest(final int[] r) {
  this.queue.add(r);
}
@ %def addRequest

\subsection{\texttt{dropRequests}(1)}
<<dropRequests(1)>>=
int dropRequests(final int deadline) {
  final int temp = this.queue.size();
  this.queue.removeIf((r) -> { return r[2] < deadline; });
  return Math.max(0, temp - this.queue.size());
}
@ %def dropRequests

\subsection{\texttt{collectServerLocations}(1)}
Array [[src]] =

\noindent
\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server }s$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};
 &\node[minimum width=12mm] {...};\\
};
\end{tikzpicture}

\noindent If locations are polled for and stored into [[src]] at $t'$ world
time, then formally the last location for server $s$ is defined as waypoint
$(t,v)$ that satisfies $t=\textrm{argmin}_{(t,v)\in w_{\leq t'}} (t-t')$, where
$w_{\leq t'}$ is the server's traveled route.  In other words the last location
is the waypoint in the server's traveled route that is nearest $t'$.  After
copying [[src]] into [[locations]], the [[endCollectServerLocations]](0) method
is executed.
<<collectServerLocations(1)>>=
void collectServerLocations(final int[] src) {
  this.endCollectServerLocations(src.clone());
}
@ %def collectServerLocations


\subsection{\texttt{endCollectServerLocations}(1)}
<<endCollectServerLocations(1)>>=
void endCollectServerLocations(final int[] locations) {
  for (int i = 0; i < (locations.length - 2); i += 3) {
    this.handleServerLocation(new int[] {
      locations[i],
      locations[(i + 1)],
      locations[(i + 2)]
    });
  }
}
@ %def endCollectServerLocations

\subsection{\texttt{end}(0)}
<<end(0)>>=
void end() { }
@ %def end

\subsection{\texttt{handleRequest}(1)}
Array [[r]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[rid]] of request $r$}$};
 &\node {$1:r_q$}; & \node {$2:r_e$}; & \node {$3:r_l$};
 &\node {$4:r_o$}; & \node {$5:r_d$}; & \node {$6:d_r$};\\
};
\end{tikzpicture}

<<handleRequest(1)>>=
void handleRequest(final int[] r) throws ClientException, ClientFatalException { }
@ %def handleRequest

\subsection{\texttt{handleServerLocation}(1)}
Array [[loc]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server $s$}$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};\\
};
\end{tikzpicture}

<<handleServerLocation(1)>>=
void handleServerLocation(final int[] loc) { }
@ %def handleServerLocation

