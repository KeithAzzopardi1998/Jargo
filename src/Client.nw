\documentclass{article}

\usepackage{noweb}
\noweboptions{smallcode,longchunks}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{colortbl}
\usepackage[colorlinks=true]{hyperref}
\usepackage{tikz}

\newcommand{\hi}[1]{\noindent {\bf #1}}     % Define a handy paragraph opener

\def\nwendcode{\endtrivlist \endgroup}      % Remove noweb page break penalty
\let\nwdocspar=\par

\title{Jargo Client\footnote{
    \url{https://github.com/jargors/Client}}}
\author{James J. Pan\\
  \small{\href{mailto:pan-j16@mails.tsinghua.edu.cn}{pan-j16@mails.tsinghua.edu.cn}}}

\begin{document}
\maketitle
\pagestyle{noweb}

\tableofcontents

\section{Introduction}
\label{sec:introduction}
We supply an abstract base class for developing Jargo client ridesharing
algorithms. The class provides a standard interface for interacting with the
simulation engine (Figure~\ref{fig:client}). Algorithm developers extend the
base class to add specific customer-to-vehicle matching and vehicle routing
functionality.  The base class is developed using the
Noweb\footnote{\url{https://www.cs.tufts.edu/~nr/noweb/}} literate
programming\footnote{\url{http://literateprogramming.com/}} tool.  This file
([[src/Client.nw]]) is the source for both the documentation
([[doc/Client.tex]]) and the Java code (Client.java)\footnote{See the
[[Makefile]] for build details.}.

\begin{figure}[h]
\centering
\includegraphics[width=150mm]{src/fig/client-fig}
\caption{Client within the Jargo stack.}
\label{fig:client}
\end{figure}

\section{Implementation Overview}
<<Client.java>>=
<<Client.java preamble>>
<<[[Client]] definition>>
@

\subsection{Preamble}
The preamble declares the package and imports dependencies.
<<Client.java preamble>>=
package com.github.jargors;
@
We import [[Communicator]] so we can interact with the simulated world,
and we import [[LocalDateTime]] so we can query the physical time for
logging purposes.
<<Client.java preamble>>=
import com.github.jargors.Communicator;
import com.github.jargors.Tools;
import java.util.function.Supplier;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.time.LocalDateTime;
@

\subsection{Class Definition}
The [[Client]] class consists of member variables, a constructor, and
public and protected methods. Note the [[abstract]] keyword indicates the class
cannot be used directly.
<<[[Client]] definition>>=
public abstract class Client {
  <<[[Client]] member variables>>
  <<[[Client]] constructor>>
  <<[[Client]] public methods>>
  <<[[Client]] protected methods>>
}
@

\subsection{Member Variables}
<<[[Client]] member variables>>=
protected ConcurrentLinkedQueue<int[]> queue = new ConcurrentLinkedQueue();
protected int r_collection_period = 1;  // how many sec before collecting new req?
protected int r_handling_period = 1;  // how many msec before handling queued req?
protected int s_collection_period = 10;
protected Communicator communicator;
protected Tools tools = new Tools();
protected boolean DEBUG = false;
@ %def queue r_collection_period r_handling_period s_collection_period communicator tools DEBUG

\subsection{Constructor}
<<[[Client]] constructor>>=
public Client() { }
@

\section{Public Methods}
<<[[Client]] public methods>>=
  <<Notify new requests>>
  <<Collect request into queue>>
  <<Collect server locations>>
  <<Set simulation interface>>
  <<Set debug flag>>
  <<Get/set request collection period>>
  <<Get/set request handling period>>
  <<Get/set server location collection period>>
  <<Load GTree>>
  <<Register road network>>
  <<Register users>>
@

\subsection{Obtaining Requests and Server Locations}

\subsubsection{[[notifyNew]](0)}
<<Notify new requests>>=
public void notifyNew() throws RuntimeException {
  if (!queue.isEmpty()) {
    try {
      handleRequest(queue.remove());
    } catch (RuntimeException e) {
      throw e;
    }
  }
}
@ %def notifyNew

\subsubsection{[[collectRequest]](1)}
<<Collect request into queue>>=
public void collectRequest(int[] r) {
  queue.add(r);
}
@ %def addRequest

\subsubsection{[[collectServerLocations]](1)}
Array [[src]] =

\noindent
\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server }s$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};
 &\node[minimum width=12mm] {...};\\
};
\end{tikzpicture}

\noindent If locations are polled for and stored into [[src]] at $t'$ world
time, then formally the last location for server $s$ is defined as waypoint
$(t,v)$ that satisfies $t=\textrm{argmin}_{(t,v)\in w_{\leq t'}} (t-t')$, where
$w_{\leq t'}$ is the server's traveled route.  In other words the last location
is the waypoint in the server's traveled route that is nearest $t'$.  After
copying [[src]] into [[locations]], the [[endCollectServerLocations]](0) method
is executed.
<<Collect server locations>>=
public void collectServerLocations(int[] src) {
  int[] locations = src.clone();
  endCollectServerLocations(locations);
}
@ %def collectServerLocations

\subsection{Getters and Setters}

\subsubsection{[[setCommunicator]](1)}
<<Set simulation interface>>=
public void setCommunicator(Communicator src) {
  communicator = src;
}
@ %def setCommunicator

\subsubsection{[[setDebug]](1)}
<<Set debug flag>>=
public void setDebug(boolean flag) {
  DEBUG = flag;
}
@ %def setDebug

\subsubsection{[[getRequestCollectionPeriod]](0)}
<<Get/set request collection period>>=
public int getRequestCollectionPeriod() {
  return r_collection_period;
}
@ %def getRequestCollectionPeriod

\subsubsection{[[setRequestCollectionPeriod]](1)}
<<Get/set request collection period>>=
public void setRequestCollectionPeriod(int t) {
  r_collection_period = t;
}
@ %def setRequestCollectionPeriod

\subsubsection{[[getRequestHandlingPeriod]](1)}
<<Get/set request handling period>>=
public int getRequestHandlingPeriod() {
  return r_handling_period;
}
@ %def getRequestHandlingPeriod

\subsubsection{[[setRequestHandlingPeriod]](0)}
<<Get/set request handling period>>=
public void setRequestHandlingPeriod(int t) {
  r_handling_period = t;
}
@ %def setRequestHandlingPeriod

\subsubsection{[[getServerLocationCollectionPeriod]](0)}
<<Get/set server location collection period>>=
public int getServerLocationCollectionPeriod () {
  return s_collection_period;
}
@ %def getServerLocationCollectionPeriod

\subsubsection{[[setServerLocationCollectionPeriod]](1)}
<<Get/set server location collection period>>=
public void setServerLocationCollectionPeriod(int t) {
  s_collection_period = t;
}
@ %def setServerLocationCollectionPeriod

\subsubsection{[[loadGTree]](1)}
<<Load GTree>>=
public void loadGTree(String p) {
  tools.loadGTree(p);
}
@ %def loadGTree

\subsubsection{[[registerRoadNetwork]](0)}
<<Register road network>>=
public void registerRoadNetwork() {
  tools.registerVertices(communicator.getReferenceVerticesCache());
  tools.registerEdges(communicator.getReferenceEdgesCache());
}
@ %def registerRoadNetwork

\subsubsection{[[registerUsers]](0)}
<<Register users>>=
public void registerUsers() {
  tools.registerUsers(communicator.getReferenceUsersCache());
}
@ %def registerUsers

\section{Private Methods}
<<[[Client]] protected methods>>=
  <<End collect server locations>>
  <<End simulation>>
  <<Handle request>>
  <<Handle server location>>
  <<Print a message>>
@

\subsection{[[endCollectServerLocations]](0)}
After server locations are collected, [[handleServerLocation]](1) is executed
on each one.
<<End collect server locations>>=
protected void endCollectServerLocations(int[] locations) {
  for (int i = 0; i < (locations.length - 2); i += 3) {
    handleServerLocation(new int[] {
      locations[i],
      locations[(i + 1)],
      locations[(i + 2)]
    });
  }
}
@ %def endCollectServerLocations

\subsection{[[end]](0)}
<<End simulation>>=
protected void end() { }
@ %def end

\subsection{[[handleRequest]](1)}
Array [[r]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[rid]] of request $r$}$};
 &\node {$1:r_q$}; & \node {$2:r_e$}; & \node {$3:r_l$};
 &\node {$4:r_o$}; & \node {$5:r_d$}; & \node {$6:d_r$};\\
};
\end{tikzpicture}

<<Handle request>>=
protected void handleRequest(int[] r) throws RuntimeException { }
@ %def handleRequest

\subsection{[[handleServerLocation]](1)}
Array [[loc]] =

\begin{tikzpicture}
\small
\matrix[nodes={draw,minimum size=6mm}] {
  \node {$0:\textrm{[[sid]] of server $s$}$};
 &\node {$1:\textrm{time of $s$'s last location}$};
 &\node {$2:\textrm{vertex of $s$'s last location}$};\\
};
\end{tikzpicture}

<<Handle server location>>=
protected void handleServerLocation(int[] loc) { }
@ %def handleServerLocation

\subsection{[[Print]](1)}
<<Print a message>>=
protected void Print(String msg) {
  if (DEBUG) {
    System.out.println("[Client]["+LocalDateTime.now()+"]"
      + "[t="+communicator.getSimulationWorldTime()+"] "+msg);
  }
}
@ %def Print

\appendix

\section{Appendix: List of Chunks}
\label{ap:list-of-chunks}
\nowebchunks

\section{Appendix: List of Identifiers}
\label{ap:list-of-identifiers}
\nowebindex

\end{document}

