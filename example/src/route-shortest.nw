\part{Routing}
\label{part-routing}

\chapter{Shortest Path}
\label{route-shortest}

In the previous chapters, we saw some scheduling procedures for ridesharing
algorithms. Now we will take a look at routing procedures. We'll start with
Shortest Path. This procedure calculates \textit{consecutive shortest paths
between events in a schedule in sequence}. We will use the [[Tools]] class to
quickly calculate shortest paths using a G-tree index of the road network
graph.

We will need some other memory objects. We will need the schedule to route
through, [[bnew]], produced using some scheduling procedure such as Prepend.
We will also need a container to store the computed route, [[wnew]].
Finally, we need an \textit{initial waypoint} [[wbeg]] to start off the route.
Recall that scheduling procedures do not fill in event times because these
times depend on the routing. After we find the route here, we'll be able to
update [[bnew]] by filling in the event times.

\begin{center}
\begin{tabular}{|p{74mm}|p{74mm}|}
\hline
\textbf{Required Memory Values} & \textbf{Side Effects} \\
\hline
\begin{itemize}[leftmargin=*]
\item [[Tools this.tools]]: Jargo utility functions
\item [[int[] bnew]]: schedule to route through, with empty time components
\item [[int[] wbeg]]: first $(t,v)$ waypoint in the new route
\item [[int[] wnew]]: (empty)
\end{itemize} &
\begin{itemize}[leftmargin=*]
\item [[int[] bnew]]: time components added
\item [[int[] wnew]]: the computed route
\end{itemize} \\
\hline
\end{tabular}
\end{center}

The procedure takes four steps. In the first step, we'll initialize some memory
structures. In the second step, we'll compute shortest paths between adjacent
events. In the third step, we'll join the paths into a single route. In the
last step, we'll fill in the event times into [[bnew]].

<<Routing: Shortest Path>>=
{
  <<Debug: echo shortest path>>
  <<Shortest: Step 1: Initialize>>
  <<Shortest: Step 2: Compute>>
  <<Shortest: Step 3: Join>>
  <<Shortest: Step 4: Fill>>
}
@

\section{Step 1: Initialize}

Let's initialize the memory.  We'll need some place to store the individual
paths as they are computed, call it [[legs]]. A path by itself is an array of
integer vertices, so [[legs]] will be an array of integer arrays. For each
event, there is a path traveling to the event. The first path travels from
[[wbeg]] to the first event, the second path travels from the first event to
the second event, and so on. The number of events in [[bnew]] is its length
divided by three. The [[legs]] array will need to hold this many paths. We'll
store the number into [[p]] and use [[p]] to initialize [[legs]].

The first path is slightly different then the rest because it starts from
[[wbeg]]. We'll go ahead and compute the first path now. We'll use the
[[computeRoute]] method on the [[Tools]] class to find the shortest path.  The
arguments in order are: starting vertex, ending vertex, and \textit{initial
time}. The time is needed because [[computeRoute]] returns a sequence of
waypoints, with time components next to each vertex. The duration between each
adjacent vertex pair is the shortest duration needed to travel between the two
vertices. This duration is computed using the maximum free-flow speed
information in the road network. (TODO! Right now the speed is hard-coded to be
10 m/s for all edges.)

After we get the first path, we'll remember its length [[n]] and ending time
[[t]] and then store it into [[legs]]. We will need [[n]] and [[t]] later.

<<Shortest: Step 1: Initialize>>=
final int p = (bnew.length/3);
final int[][] legs = new int[p][];
<<Debug: initialize legs container>>

int[] leg = this.tools.computeRoute(wbeg[1], bnew[1], wbeg[0]);
int n = leg.length;
int t = leg[(n - 2)];
<<Debug: set route length and time>>

legs[0] = leg;
<<Debug: set first leg>>
@

\section{Step 2: Compute}

Now we can compute each of the paths. For each event in [[bnew]], we'll compute
the path to the event traveling from the previous event. The starting time of
each path is the ending time of the previous path. We'll store each path into
[[legs]] and update [[n]] and [[t]] as we go along.

<<Shortest: Step 2: Compute>>=
for (int i = 1; i < p; i++) {
  // Extract vertices
  final int u = bnew[(3*i - 2)];
  final int v = bnew[(3*i + 1)];
  // Compute path and store into legs
  leg = this.tools.computeRoute(u, v, t);
  legs[i] = leg;
  <<Debug: set leg>>
  // Update n and t
  n += (leg.length - 2);
  t = leg[leg.length - 2];
  <<Debug: set route length and time>>
}
@

\section{Step 3: Join}

After the paths have been computed, we can join them together into [[wnew]].
Until now, we've added to [[n]] each path length as each path is computed.
When we updated [[n]], we left out one waypoint to prevent double-counting,
for example paths $A\rightarrow B$ and $B\rightarrow C$ have a joined length
of three, not four. We can use [[n]] now to initialize the size of [[wnew]].

Next, we simply loop through each of the paths in [[legs]], copying each
element into [[wnew]]. We'll remember the last copy position using [[k]].
Then we'll use [[i]] to slide over [[legs]] and [[j]] to slide through each
path, copying into [[wnew[k]]] as we go along. To avoid double-counting the
ends, we'll skip the last waypoint in each path, except if it is the last
path in [[legs]].

<<Shortest: Step 3: Join>>=
wnew = new int[n];
int k = 0;
for (int i = 0; i < legs.length; i++) {
  int rend = (legs[i].length - (i == (legs.length - 1) ? 0 : 2));
  for (int j = 0; j < rend; j++) {
    wnew[k] = legs[i][j];
    <<Debug: join route components>>
    k++;
  }
}
@

\section{Step 4: Fill}

Finally, we can go back and fill in the event times into [[bnew]]. As each path
travels from one event to the next, all we need to do is extract the time
component of the first waypoint of each path, located in the 0th position of
the path, and copy it into [[bnew]]. The second path in [[legs]] starts from
the first event, so we'll initialize our [[i]] counter to one instead of zero.
Then when we copy into [[bnew]], we'll shift the position to the left by three
elements because the first event in [[bnew]] starts from position 0.

<<Shortest: Step 4: Fill>>=
for (int i = 1; i < legs.length; i++) {
  bnew[(3*i - 3)] = legs[i][0];
  <<Debug: set schedule time>>
}
bnew[(3*p - 3)] = t;
<<Debug: set vehicle end time>>
@

\section{Full Code}

Here is the full code.

\begin{verbatim}
{
  final int p = (bnew.length/3);
  final int[][] legs = new int[p][];

  int[] leg = this.tools.computeRoute(wbeg[1], bnew[1], wbeg[0]);
  int n = leg.length;
  int t = leg[(n - 2)];

  legs[0] = leg;
  for (int i = 1; i < p; i++) {
    // Extract vertices
    final int u = bnew[(3*i - 2)];
    final int v = bnew[(3*i + 1)];
    // Compute path and store into legs
    leg = this.tools.computeRoute(u, v, t);
    legs[i] = leg;
    // Update n and t
    n += (leg.length - 2);
    t = leg[leg.length - 2];
  }
  wnew = new int[n];
  int k = 0;
  for (int i = 0; i < legs.length; i++) {
    int rend = (legs[i].length - (i == (legs.length - 1) ? 0 : 2));
    for (int j = 0; j < rend; j++) {
      wnew[k] = legs[i][j];
      k++;
    }
  }
  for (int i = 1; i < legs.length; i++) {
    bnew[(3*i - 3)] = legs[i][0];
  }
  bnew[(3*p - 3)] = t;
}
\end{verbatim}

\section{Debug}

\subsection{Debug: Echo Shortest Path}

<<Debug: echo shortest path>>=
if (DEBUG) {
  System.out.printf("shortest path\n");
}
@

\subsection{Debug: Initialize Legs Container}

<<Debug: initialize legs container>>=
if (DEBUG) {
  System.out.printf("init legs={ }\n");
}
@

\subsection{Debug: Set Route Length and Time}

<<Debug: set route length and time>>=
if (DEBUG) {
  System.out.printf("set n=%d\n", n);
  System.out.printf("set t=%d\n", t);
}
@

\subsection{Debug: Set First Leg}

<<Debug: set first leg>>=
if (DEBUG) {
  System.out.printf("set legs[0]={ %d, %d, ..., %d, %d  }\n",
      legs[0][0], legs[0][1], legs[0][legs[0].length - 2], legs[0][legs[0].length - 1]);
}
@

\subsection{Debug: Set Leg}

<<Debug: set leg>>=
if (DEBUG) {
  System.out.printf("set legs[%d]={ %d, %d, ..., %d, %d  }\n", i,
      legs[i][0], legs[i][1], legs[i][legs[i].length - 2], legs[i][legs[i].length - 1]);
}
@

\subsection{Debug: Join Route Components}

<<Debug: join route components>>=
if (DEBUG) {
  System.out.printf("set wnew[%d]=%d\n", k, wnew[k]);
}
@

\subsection{Debug: Set Schedule Time}

<<Debug: set schedule time>>=
if (DEBUG) {
  System.out.printf("set bnew[%d]=%d\n", (3*i - 3), bnew[(3*i - 3)]);
}
@

\subsection{Debug: Set Vehicle End Time}

<<Debug: set vehicle end time>>=
if (DEBUG) {
  System.out.printf("set bnew[%d]=%d\n", (3*p - 3), bnew[(3*p - 3)]);
}
@

