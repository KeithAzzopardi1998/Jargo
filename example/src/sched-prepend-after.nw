\chapter{Prepend After}
\label{sched-prepend-after}

The second scheduling procedure is a variation of Prepend called Prepend After.
In this variation, the pick-up and drop-off are prepended \textit{after the
first event} in the remaining schedule. The idea is to let the vehicle complete
its next event before servicing the new events. The memory table for
Prepend After is the same as for Prepend.

\begin{center}
\begin{tabular}{|p{74mm}|p{74mm}|}
\hline
\textbf{Required Memory Values} & \textbf{Side Effects} \\
\hline
\begin{itemize}[leftmargin=*]
\item [[int[] brem]]: server's remaining schedule
\item [[int[] bnew]]: (empty)
\item [[int rid]]: request identifier
\item [[int ro]]: request origin vertex
\item [[int rd]]: request destination vertex
\end{itemize} &
\begin{itemize}[leftmargin=*]
\item [[int[] bnew]]: schedule after prepend
\end{itemize} \\
\hline
\end{tabular}
\end{center}

The first step, initialization, is the same here as in Prepend.

<<Scheduling: Prepend After>>=
{
  <<Debug: echo prepend after>>
  <<Prepend: Step 1: Initialize>>
  <<Prepend: Step 2: Prepend After>>
  <<Prepend: Step 3: Copy After>>
}
@

\section{Step 2: Prepend After}

In the second step, the request pick-up and drop-off events are placed in
elements [[bnew[3..5]]] and [[bnew[6..8]]], respectively. Again, as event
times are not known until routing, we'll leave out the time components
at the 3rd and 6th indices.

<<Prepend: Step 2: Prepend After>>=
bnew[4] = ro;
bnew[5] = rid;
bnew[7] = rd;
bnew[8] = rid;
<<Debug: prepend after>>
@

\section{Step 3: Copy After}

In the third step, we'll once again copy events in [[brem]] into [[bnew]].
This time, the first event is copied without any positional shift, while later
events are shifted again by six positions.

<<Prepend: Step 3: Copy After>>=
for (int i = 0; i < m; i++) {
  // Extract vertex and labels
  final int bv = brem[(4*i + 1)];
  final int ls = brem[(4*i + 2)];
  final int lr = brem[(4*i + 3)];
  // Copy into bnew and shift if not first event
  bnew[(3*i + (i < 1 ? 1 : 7))] = bv;
  bnew[(3*i + (i < 1 ? 2 : 8))] = (ls == 0 ? lr : ls);
  <<Debug: copy after>>
}
@

\section{Example}

Here is an example of the procedure in action. (TODO)

\section{Full Code}

Here is the full code.

\begin{verbatim}
{
  final int m = (brem.length/4);
  bnew = new int[(3*(m + 2))];
  bnew[4] = ro;
  bnew[5] = rid;
  bnew[7] = rd;
  bnew[8] = rid;
  for (int i = 0; i < m; i++) {
    // Extract vertex and labels
    final int bv = brem[(4*i + 1)];
    final int ls = brem[(4*i + 2)];
    final int lr = brem[(4*i + 3)];
    // Copy into bnew and shift if not first event
    bnew[(3*i + (i < 1 ? 1 : 7))] = bv;
    bnew[(3*i + (i < 1 ? 2 : 8))] = (ls == 0 ? lr : ls);
  }
}
\end{verbatim}

\section{Debug}

The below print statements can be used to inspect [[bnew]] as its contents
change.

\subsection{Debug: Echo Prepend After}

<<Debug: echo prepend after>>=
if (DEBUG) {
  System.out.printf("prepend after\n");
}
@

\subsection{Debug: Prepend After}

<<Debug: prepend after>>=
if (DEBUG) {
  System.out.printf("set bnew[4]=%d\n", bnew[4]);
  System.out.printf("set bnew[5]=%d\n", bnew[5]);
  System.out.printf("set bnew[7]=%d\n", bnew[7]);
  System.out.printf("set bnew[8]=%d\n", bnew[8]);
}
@

\subsection{Debug: Copy After}

<<Debug: copy after>>=
if (DEBUG) {
  if (i < 1) {
    System.out.printf("set bnew[%d]=%d\n", (3*i + 1), bnew[(3*i + 1)]);
    System.out.printf("set bnew[%d]=%d\n", (3*i + 2), bnew[(3*i + 2)]);
  } else {
    System.out.printf("set bnew[%d]=%d\n", (3*i + 7), bnew[(3*i + 7)]);
    System.out.printf("set bnew[%d]=%d\n", (3*i + 8), bnew[(3*i + 8)]);
  }
}
@

