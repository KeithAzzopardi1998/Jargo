\chapter{Client: Nearest B}
\label{client-nearest-b}

The Nearest B algorithm uses prepend-after for scheduling. There are two
differences from Nearest A.

<<NearestB.java>>=
<<NearestA: preamble>>
public class NearestB extends Client {
  <<NearestA: member variables>>
  protected <<NearestB: handleRequest(1)>>
  protected <<NearestA: handleServerLocation(1)>>
}
@

<<NearestB: handleRequest(1)>>=
void handleRequest(int[] r) throws ClientException, ClientFatalException {
  <<Debug: handle request>>
  final int rid = r[0];
  final int ro  = r[4];
  final int rd  = r[5];
  try {
    <<NearestA: Step 1: Initialize>>
    <<NearestA: Step 2: Map and Filter>>
    <<NearestA: Step 3: Reduce>>
    if (min != null) {
      //NearestA: Step 4: Prepare Scheduling
      //Scheduling: Prepend After
      //NearestB: Step 5: Prepare Routing
      //Routing: Shortest Path
      //NearestA: Step 6: Submit
    }
  } catch (Exception e) {
    throw new ClientException(e);
  }
}
@

For Nearest A, the time for the initial waypoint for the new route is at the
simulation world time. But because we do prepend-after here, we don't need to
recompute the first leg of the route. So we set the initial waypoint to the
next immediate event, if it exists. Otherwise, same as Nearest A.

<<NearestB: Step 5: Prepare Routing>>=
<<NearestA: Step 5: Prepare Routing>>
if (m > 1) {
    wbeg[0] = brem[0];
    wbeg[1] = brem[1];
}
@

\section{Reference}

{
\small
\begin{verbatim}
package com.github.jargors.client;
import com.github.jargors.sim.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
public class NearestB extends Client {
  final int MAX_DELTA = 300;  // seconds from last vehicle location update
  final int MAX_RANGE = 600;  // meters from last vehicle position
  final ConcurrentHashMap<Integer, int[]> locations =
    new ConcurrentHashMap<Integer, int[]>();
  protected void handleRequest(int[] r) throws ClientException, ClientFatalException {
    final int rid = r[0];
    final int ro  = r[4];
    final int rd  = r[5];
    try {
      final int now = this.communicator.retrieveClock();

      final Map<Integer, Integer> candidates = new HashMap<Integer, Integer>();
      for (final Integer sid : locations.keySet()) {
        final int t = locations.get(sid)[0];
        final int v = locations.get(sid)[1];

        final boolean in_delta = (t >= now - MAX_DELTA);
        if (!in_delta)
          continue;

        final int range = this.tools.computeHaversine(v, ro);
        final boolean in_range = (0 != range && range <= MAX_RANGE);
        if (!in_range)
          continue;

        candidates.put(sid, range);
      }
      Entry<Integer, Integer> min = null;
      for (final Entry<Integer, Integer> entry : candidates.entrySet()) {
        if (min == null || min.getValue() > entry.getValue()) {
          min = entry;
        }
      }
      if (min != null) {
        final int sid = min.getKey();
        final int[] brem = this.communicator.queryServerScheduleRemaining(sid, now);
        final int m = (brem.length/4);
        final int p = (m + 2);

        final int[] bnew = new int[(3*p)];
        if (m == 1) {
          bnew[1] = ro;
          bnew[2] = rid;
          bnew[4] = rd;
          bnew[5] = rid;
          for (int i = 0; i < m; i++) {
            final int bv = brem[(4*i + 1)];
            final int ls = brem[(4*i + 2)];
            final int lr = brem[(4*i + 3)];
            bnew[(3*i + 7)] = bv;
            bnew[(3*i + 8)] = (ls == 0 ? lr : ls);
          }
        } else {
          bnew[4] = ro;
          bnew[5] = rid;
          bnew[7] = rd;
          bnew[8] = rid;
          for (int i = 0; i < m; i++) {
            final int bv = brem[(4*i + 1)];
            final int ls = brem[(4*i + 2)];
            final int lr = brem[(4*i + 3)];
            bnew[(3*i + (i < 1 ? 1 : 7))] = bv;
            bnew[(3*i + (i < 1 ? 2 : 8))] = (ls == 0 ? lr : ls);
          }
        }
        final int[][] legs = new int[p][];

        int[] leg = this.tools.computeRoute(locations.get(sid)[1], ro, now);
        int n = leg.length;
        int t = leg[n - 2];

        leg[0] = locations.get(sid)[0];
        legs[0] = leg;
        for (int i = 1; i < p; i++) {
          final int u = bnew[(3*i - 2)];
          final int v = bnew[(3*i + 1)];
          leg = this.tools.computeRoute(u, v, t);
          legs[i] = leg;

          n += (leg.length - 2);
          t = leg[leg.length - 2];
        }
        final int[] wnew = new int[n];
        {
          int k = 0;
          for (int i = 0; i < legs.length; i++) {
            int rend = (legs[i].length - (i == (legs.length - 1) ? 0 : 2));
            for (int j = 0; j < rend; j++) {
              wnew[k] = legs[i][j];
              k++;
            }
          }
        }
        for (int i = 1; i < legs.length; i++) {
          bnew[(3*i - 3)] = legs[i][0];
        }

        bnew[(3*p - 3)] = t;
        this.communicator.updateServerService(sid, wnew, bnew,
            new int[] { rid }, new int[] { });
      }
    } catch (Exception e) {
      throw new ClientException(e);
    }
  }
  protected void handleServerLocation(int[] s) {
    this.locations.put(s[0], new int[] { s[1], s[2] });
  }
}
\end{verbatim}
}


