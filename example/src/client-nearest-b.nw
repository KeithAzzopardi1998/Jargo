\chapter{Client: Nearest B}
\label{client-nearest-b}

The Nearest B algorithm uses prepend-after for scheduling. There are two
differences from Nearest A.

<<NearestB.java>>=
<<NearestA: preamble>>
public class NearestB extends Client {
  <<NearestA: member variables>>
  protected <<NearestB: handleRequest(1)>>
  protected <<NearestA: handleServerLocation(1)>>
}
@

<<NearestB: handleRequest(1)>>=
void handleRequest(int[] r) throws ClientException, ClientFatalException {
  <<Debug: handle request>>
  final int rid = r[0];
  final int ro  = r[4];
  final int rd  = r[5];
  try {
    <<NearestA: Step 1: Initialize>>
    <<NearestA: Step 2: Map and Filter>>
    <<NearestA: Step 3: Reduce>>
    if (min != null) {
      //NearestA: Step 4: Prepare Scheduling
      //Scheduling: Prepend After
      //NearestB: Step 5: Prepare Routing
      //Routing: Shortest Path
      //NearestA: Step 6: Submit
    }
  } catch (Exception e) {
    throw new ClientException(e);
  }
}
@

For Nearest A, the time for the initial waypoint for the new route is at the
simulation world time. But because we do prepend-after here, we don't need to
recompute the first leg of the route. So we set the initial waypoint to the
next immediate event, if it exists. Otherwise, same as Nearest A.

<<NearestB: Step 5: Prepare Routing>>=
<<NearestA: Step 5: Prepare Routing>>
if (m > 1) {
    wbeg[0] = brem[0];
    wbeg[1] = brem[1];
}
@

\section{Reference}

