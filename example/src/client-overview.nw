\part{Client Algorithms}
\label{part-client}

\chapter{Overview}
\label{client-overview}

\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

This chapter lists an overview of each of the client algorithms. Go to the page
next to each method name to go directly to the method definition.
Tables~\ref{tab:search-algorithms}~and~\ref{tab:join-algorithms} summarize some
features of the algorithms.

\begin{table}[h]
\begin{center}
\caption{Summary of Search-Based Algorithms}
\label{tab:search-algorithms}
\begin{tabular}{|l|l|l|l|l|}
\hline
Ch. & Algorithm & Selection Predicate & Scheduling Strategy & Routing Strategy \\
\hline
Ch.~\ref{client-nearest} & Nearest Neighbor & Minimum proximity & Prepend to front & Shortest-path \\
Ch.~\ref{client-greedy} & Greedy Insertion & Minimum routing cost & Insertion heuristic & Shortest-path \\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\caption{Summary of Join-Based Algorithms}
\label{tab:join-algorithms}
\begin{tabular}{|l|l|l|l|l|}
\hline
Ch. & Algorithm & Join Predicate & Scheduling Strategy & Routing Strategy \\
\hline
\end{tabular}
\end{center}
\end{table}

Ridesharing algorithms can be classified as search-based or join-based.
Search-based algorithms use a selection predicate to decide which vehicle
should be assigned to a particular customer. Join-based algorithms aim to group
vehicles and customers together, with each vehicle serving all the customers in
its group. Both algorithms may use various schedule and routing strategies.  A
scheduling strategy is a method of arranging the future pick-ups and drop-offs
that a vehicle is assigned to complete. A routing strategy is a method of
computing the route that a vehicle should follow in order to go to the pick-ups
and drop-offs in the scheduled order.

For search-based algorithms, usually the predicate aims to minimize some sort
of cost. The minimum-proximity predicate finds the vehicle that minimizes
Euclidean or Haversine distance. The minimum-routing-cost predicate aims to
minimize the extra routing distance that becomes necessary due to assignment to
the customer.

For join-based algorithms...

Several scheduling strategies exist. The prepend-to-front strategy
simply arranges the customer's pick-up and drop-off at the front of the
assigned vehicle's schedule. The insertion-heuristic strategy aims to
find the best position to insert the pick-up and drop-off without
rearranging the existing pick-ups and drop-offs in the schedule.

For routing strategies, the most common is shortest-path. This strategy
simply finds the shortest path through all the pick-ups and drop-offs in a
vehicle's schedule.

\section{NearestNeighbor}

The nearest-neighbor algorithm is a search-based algorithm that uses
minimum-proximity as its selection predicate. It can be implemented using two
methods. The [[handleRequest]](1) method will search for and assign the
minimum-proximity vehicle to given customer requests. The
[[handleServerLocation]](1) method will store new vehicle locations as they are
updated.

<<[[NearestNeighbor]] methods>>=
protected <<NearestNeighbor: handleRequest(1)>>
protected <<NearestNeighbor: handleServerLocation(1)>>
@

\section{GreedyInsertion}

The greedy-insertion algorithm...

<<[[GreedyInsertion]] methods>>=
protected <<GreedyInsertion: handleRequest(1)>>
protected <<GreedyInsertion: endCollectServerLocations(1)>>
protected <<GreedyInsertion: end(0)>>
@

<<[[GreedyInsertion]] methods>>=
private <<GreedyInsertion: computeCost(6)>>
@

