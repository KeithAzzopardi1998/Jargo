\chapter{Maps and Filters}
\label{search-filters}

Each server can be mapped to a quantitative value indicating its ``fitness''
for a given request.  If the fitness is low, the server can be removed
immediately from further consideration. This chapter implements some example
map and filter functions for determining fitness and whether or not to keep a
server.

% \section{Last Event Time}
% \section{Upcoming Event Time}
% \section{Upcoming Event Distance}

\section{Schedule Length}

A server with a very long schedule can be difficult to evaluate because there
will be more scheduling possibilities. Filtering these servers out may improve
the speed performance.

<<Map/Filter: Schedule Length>>=
for (final int sid : candidates.keySet()) {
  final int val = this.communicator.queryServerScheduleRemaining(sid,
      this.communicator.retrieveClock()).length / 4;
  if (val <= MAX_SCHEDULE_LENGTH)
    results.put(sid, val);
}
@

% \section{Total Travel Duration}
% \section{Total Travel Distance}
% \section{Total Cruising Duration}
% \section{Total Cruising Distance}
% \section{Total Service Duration}
% \section{Total Service Distance}

\section{Proximity}

Proximity is easy to compute and can be used to approximate actual pick-up
distance. In the filter, we disregard zero proximities due to Limitation \#4.

<<Map/Filter: Proximity>>=
for (final int sid : candidates.keySet()) {
  final int val = this.tools.computeHaversine(luv.get(sid), ro);
  if (0 < val && val <= MAX_PROXIMITY)
    results.put(sid, val);
}
@

% \section{Road Proximity}

\section{Routing Cost}

% \section{Number of Assignments}
% \section{Profit}

