\chapter{Prepend}
\label{sched-prepend}

\begin{center}
\begin{tabular}{|p{74mm}|p{74mm}|}
\hline
\textbf{Required Memory Values} & \textbf{Side Effects} \\
\hline
\begin{itemize}[leftmargin=*]
\item [[int[] brem]]: server's remaining schedule
\item [[int[] bnew]]: (empty)
\item [[int rid]]: request identifier
\item [[int ro]]: request origin vertex
\item [[int rd]]: request destination vertex
\end{itemize} &
\begin{itemize}[leftmargin=*]
\item [[int[] bnew]]: schedule after prepend
\end{itemize} \\
\hline
\end{tabular}
\end{center}

The Prepend procedure copies schedule [[brem]] into schedule [[bnew]],
\textit{but with request [[rid]]'s pick-up and drop-off events prepended to the
front}. As event times cannot be known until the route is constructed through the
schedule, [[bnew]] has empty time components (the 0th, 3rd, 6th, ... indices).

The procedure has three steps. We don't want to pollute the memory space, so
we'll wrap the entire procedure in braces.

<<Scheduling: Prepend>>=
{
  <<Debug: echo prepend>>
  <<Prepend: Step 1: Initialize>>
  <<Prepend: Step 2: Prepend>>
  <<Prepend: Step 3: Copy>>
}
@

\section{Step 1: Initialize}

First we'll initialize [[bnew]] to the correct size. The correct size is
calculated as follows. In Jargo, a server's remaining schedule is returned as a
4-tuple flattened array of $(t,v,Ls,Lr)$ components. Each 4-tuple is one event.
To get the number of events, we divide the length of the remaining schedule
[[brem]] by four...

<<Prepend: Step 1: Initialize>>=
final int m = (brem.length/4);
bnew = new int[(4*(m + 2))];
<<Debug: initialize>>
@

\section{Step 2: Prepend}

Now we'll do the prepend by populating the first six elements in [[bnew]].
Elements [[bnew[0..3]]] represent the request pick-up event, and elements
[[bnew[4..7]]] represent the request drop-off event. As event times are
unknown, we'll leave out the 0th and 4th indices.

<<Prepend: Step 2: Prepend>>=
bnew[1] = ro;
bnew[2] = 0;
bnew[3] = rid;
bnew[5] = rd;
bnew[6] = 0;
bnew[7] = rid;
<<Debug: prepend>>
@

\section{Step 3: Copy}

Just like that, we're almost done. In the third step, we'll simply copy over
[[brem]] into [[bnew]] while shifting the destination indice by eight. We shift
by eight to account for the two 4-tuples we inserted in Step 2.

<<Prepend: Step 3: Copy>>=
for (int i = 0; i < m; i++) {
  // Extract vertex and labels
  final int bv = brem[(4*i + 1)];
  final int ls = brem[(4*i + 2)];
  final int lr = brem[(4*i + 3)];
  // Copy into bnew
  bnew[(4*i +  9)] = bv;
  bnew[(4*i + 10)] = ls;
  bnew[(4*i + 11)] = lr;
  <<Debug: copy>>
}
@

\section{Example}

Here is an example of the procedure in action. (TODO)

\section{Full Code}

Here is the full code.

\begin{verbatim}
{
}
\end{verbatim}

\section{Debug}

Printing debugging messages to screen can be useful for tracking execution of
the procedure. The below print statements can be used to inspect [[bnew]] as
its contents change.

\subsection{Debug: Echo Prepend}

<<Debug: echo prepend>>=
if (DEBUG) {
  System.out.printf("prepend\n");
}
@

\subsection{Debug: Initialize}

<<Debug: initialize>>=
if (DEBUG) {
  System.out.printf("init bnew={ }, length=%d\n", bnew.length);
}
@

\subsection{Debug: Prepend}

<<Debug: prepend>>=
if (DEBUG) {
  System.out.printf("set bnew[1]=%d\n", bnew[1]);
  System.out.printf("set bnew[3]=%d\n", bnew[3]);
  System.out.printf("set bnew[5]=%d\n", bnew[5]);
  System.out.printf("set bnew[7]=%d\n", bnew[7]);
}
@

\subsection{Debug: Copy}

<<Debug: copy>>=
if (DEBUG) {
  System.out.printf("set bnew[%d]=%d\n", (4*i +  9), bnew[(4*i +  9)]);
  System.out.printf("set bnew[%d]=%d\n", (4*i + 10), bnew[(4*i + 10)]);
  System.out.printf("set bnew[%d]=%d\n", (4*i + 11), bnew[(4*i + 11)]);
}
@

