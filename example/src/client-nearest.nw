\chapter{Client: NearestNeighbor}
\label{client-nearest}

Here is a basic implementation of the nearest-neighbor algorithm. See
Chapter~\ref{client-overview: nearest} for an overview of the methods.  This
implementation doesn't check capacity or time-window constraints If capacity is
violated, Jargo automatically rejects the submission. If a time window is
violated, Jargo records the violation. Time windows are considered to be
``soft'' constraints because they are hard to guarantee due to traffic.

Let's start. We'll write a [[NearestNeighbor]] class extending Jargo's base
[[Client]] class. Angle brackets indicate a code chunk. Go to the page number
next to the chunk to see the code body. A triple bar ($\equiv$) after angle
brackets means we're defining a new chunk. Here, we're defining the
NearestNeighbor.java chunk. This is a special ``root'' chunk that gets written
to disk as Java source.

<<NearestNeighbor.java>>=
<<NearestNeighbor.java preamble>>
public class NearestNeighbor extends Client {
  <<[[NearestNeighbor]] member variables>>
  <<[[NearestNeighbor]] methods>>
}
@

\section{Preamble}
\label{NearestNeighbor: preamble}


First we'll tell Java which package to put our class.

<<NearestNeighbor.java preamble>>=
package com.github.jargors.client;
@

Next we'll import Jargo [[sim]] components and some standard Java utilities.
The $+\equiv$ symbol after the angle brackets means we're adding to an existing
chunk.

<<NearestNeighbor.java preamble>>=
import com.github.jargors.sim.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
@

\section{Member Variables}
\label{client-nearest: member-variables}

Now we'll define the member variables. This implementation uses two filters to
narrow down the nearest vehicle. We'll set their thresholds as member
variables. For each vehicle, integer [[MAX_DELTA]] gives the maximum seconds
from the vehicle's last update for the vehicle to be considered a candidate.
Integer [[MAX_RANGE]] gives the maximum proximity, in meters, from the
vehicle's last-known location. We'll also initialize a [[locations]] map for
storing vehicle locations.

<<[[NearestNeighbor]] member variables>>=
final int MAX_DELTA = 300;  // seconds from last vehicle location update
final int MAX_RANGE = 600;  // meters from last vehicle position
final ConcurrentHashMap<Integer, int[]> locations =
  new ConcurrentHashMap<Integer, int[]>();
@

\section{Chunks}
\label{NearestNeighbor: chunks}

Before writing the methods, we'll divide the functionality into easily
understood code chunks. The first chunk gets the current simulation world time.
This time is used to check how long ago was the last positional update for a
vehicle, to ask a vehicle what is its remaining schedule from this time
forward, and to compute future routes. Jargo routes have both time and vertex
components.

\subsection{Get Current Time}

The base [[Client]] class has a [[Communicator]] member object called
[[communicator]]. This object has methods for reading and writing the
simulation state. See the Jargo User Manual for more details.

<<Get current time>>=
final int now = this.communicator.retrieveClock();
<<Debug: get current time>>
@

\subsection{Initialize Candidates Container}

For each incoming request, we'll initialize an empty map of candidate vehicles
called [[candidates]]. The map key will be the vehicle's identifier and the
value will be distance to its last-known location.

<<Initialize candidates container>>=
final Map<Integer, Integer> candidates = new HashMap<Integer, Integer>();
<<Debug: initialize candidates container>>
@

\subsection{Apply Delta and Range Filters}

We'll apply the delta and range filters to narrow down the candidates. The
[[locations]] map maps vehicle identifiers to last-known location waypoints. A
Jargo waypoint is a $(t,v)$ pair. The $t$ component is a time and the $v$
component is a road network vertex. The stored last-known location waypoints
indicate the time and location of the last update. Due to Jargo Known Issue \#1,
we'll also set a non-zero criteria in the range filter.

The base [[Client]] class has a [[Tools]] member object called [[tools]] with
some convenience methods. Here we will use [[tools]] to compute Haversine.  See
the Jargo User Manual for more details.

<<Apply delta and range filters>>=
for (final Integer sid : locations.keySet()) {
  final int t = locations.get(sid)[0];
  final int v = locations.get(sid)[1];

  final boolean in_delta = (t >= now - MAX_DELTA);
  <<Debug: delta filter>>
  if (!in_delta)
    continue;

  final int range = this.tools.computeHaversine(v, r[4]);
  final boolean in_range = (0 != range && range <= MAX_RANGE);
  <<Debug: range filter>>
  if (!in_range)
    continue;

  candidates.put(sid, range);
  <<Debug: put candidate>>
}
@

\subsection{Find Minimum-Range Candidate}

To find the minimum-range candidate, we'll iterate over the candidates while
keeping the one with smaller range.

<<Find minimum-range candidate>>=
Entry<Integer, Integer> min = null;
for (final Entry<Integer, Integer> entry : candidates.entrySet()) {
  if (min == null || min.getValue() > entry.getValue()) {
    min = entry;
    <<Debug: find minimum-range candidate>>
  }
}
@

\subsection{Submit Minimum-Range Candidate}

After we've found the minimum-range candidate, we'll use [[Communicator]]'s
[[updateServerService]](5) method to submit the assignment into the Jargo
simulator. This method mimics the functionality of a service provider sending a
job update to a ridesharing vehicle. To update the job, the vehicle needs to
know the new schedule and the new route. The below chunk will compute these two
things. It's the most complicated chunk, so we'll divide it into several
sub-chunks.

To begin, we'll only submit something if a minimum-range candidate [[min]] was
found.

<<Submit minimum-range candidate>>=
if (min != null) {
@

If so, then we'll perform the following steps.

\begin{enumerate}

\item First we'll get [[min]]'s remaining schedule, count the number of
pick-up and drop-off events in the schedule, and use the number to initialize
a new schedule.

<<Submit minimum-range candidate>>=
  <<Get remaining schedule>>
  <<Get number of events>>
  <<Initialize new schedule>>
@ %
%
\item Next we'll populate the new schedule with vertices and labels. In a Jargo
schedule, each customer pick-up or drop-off event is labeled with a request
identifier to indicate which customer is getting picked up or dropped off.
As we're using the prepend-to-front scheduling strategy, we'll
put the request's pick-up and drop-off to the front of the new schedule.

<<Submit minimum-range candidate>>=
  <<Prepend request vertices>>
  <<Set initial labels>>
  <<Set remaining vertices and labels>>
@ %
%
\item Then we'll compute the shortest paths through the pick-up and drop-off
events in sequence in order to get the new route. First we'll compute the first
``leg'' of the route, from [[min]]'s last-known location to the request's
pick-up location. We'll record this leg, along with the length of the leg and
the duration of the leg.

<<Submit minimum-range candidate>>=
  <<Initialize legs container>>
  <<Set first leg>>
  <<Initialize route length and time>>
@ %
%
\item We'll then compute the remaining legs of the route. Once we've got all
the legs, we can go set the time components of the new schedule. The
times correspond to when each leg begins and ends.

<<Submit minimum-range candidate>>=
  <<Set remaining legs>>
  <<Set schedule times>>
  <<Set vehicle end time>>
@ %
%
\item We'll join all the schedule components and route legs into single
flattened arrays for submission.

<<Submit minimum-range candidate>>=
  <<Join schedule components>>
  <<Join route components>>
@ %
%
\item Finally, we'll submit our work.

<<Submit minimum-range candidate>>=
  <<Submit>>
}
@
\end{enumerate}

Now here are the details.

\subsubsection{Get Remaining Schedule}

We'll ask [[Communicator]] for [[min]]'s remaining schedule. Here, [[min]] is
actually a map entry of [[candidates]], so we'll use [[getKey]](0) to extract
the candidate's identifier. We'll store the remaining schedule into
variable [[brem]].

<<Get remaining schedule>>=
final int sid = min.getKey();
final int[] brem = this.communicator.queryServerScheduleRemaining(sid, now);
<<Debug: get remaining schedule>>
@

\subsubsection{Get Number of Events}

The returned schedule is a flattened 4-tuple array. The $i$th element is an
event's time; the $(i+1)$th element is the event's location vertex; the
$(i+2)$th element is the event's server label or 0 if it's not a server event;
and the $(i+3)$th element is the event's request label or 0 if it's not a
request event. The total number of events is the length of the schedule divided
by four. The number of events that will be in the new schedule is this number
plus two, one for the new pick-up and one for the new drop-off. Variable
[[p]] will store the number of events in the new schedule.

<<Get number of events>>=
final int m = brem.length/4;
final int p = m + 2;
<<Debug: get number of events>>
@

\subsubsection{Initialize New Schedule}

We'll initialize the new schedule [[bnew]] and also initialize its individual
components. The new-schedule parameter to [[updateServerService]](5) expects
the new schedule to be a flattened 3-tuple array. The $i$th element is a time,
the $(i+1)$th element is a vertex, and the $(i+2)th$ element is a server or
request label. We'll create arrays to store each of these three components.
Later, we'll join the arrays into [[bnew]]. Recall that [[p]] is the number
of events in the new schedule.

<<Initialize new schedule>>=
final int[] bnew = new int[3*p];
final int[] bnew_t = new int[p];
final int[] bnew_v = new int[p];
final int[] bnew_l = new int[p];
<<Debug: initialize new schedule>>
@

\subsubsection{Prepend Request Vertices}

As we're using the prepend-to-front scheduling strategy, we can add the request
pick-up and drop-off location vertices to [[bnew_v]] right off the bat. The
request is passed as argument [[r]] to [[handleRequest]](1) as an array. The
4th and 5th elements of the [[r]] array are the request pick-up and drop-off
location vertices, respectively.

<<Prepend request vertices>>=
bnew_v[0] = r[4];
bnew_v[1] = r[5];
<<Debug: prepend request vertices>>
@

\subsubsection{Set Initial Labels}

We can also label them with the request identifier. The 0th element of the
[[r]] array is the identifier.

<<Set initial labels>>=
bnew_l[0] = r[0];
bnew_l[1] = r[0];
<<Debug: set initial labels>>
@

\subsubsection{Set Remaining Vertices and Labels}

Now we'll loop over and add vertices and labels from [[brem]] events into
[[bnew_v]] and [[bnew_l]]. We can't add time components yet because we
don't know the new event times

<<Set remaining vertices and labels>>=
for (int i = 0; i < m; i++) {
  final int bv = brem[(i + 1)];
  final int ls = brem[(i + 2)];
  final int lr = brem[(i + 3)];
  bnew_v[(i + 2)] = bv;
  bnew_l[(i + 2)] = (ls == 0 ? lr : ls);
  <<Debug: set schedule vertex and label>>
}
@

\subsubsection{Initialize Legs Container}

We'll compute each leg of the route through the new schedule. We'll store
each leg into the [[legs]] multi-array.

<<Initialize legs container>>=
final int[][] legs = new int[p][];
int[] leg = null;
<<Debug: initialize legs container>>
@

\subsubsection{Set First Leg}

The first leg goes from [[min]]'s last-known location to the request pick-up
location. The [[tools]] object can be used to compute the shortest-path route
that makes up the leg.

The [[computeRoute]](3) methods takes the route start location, route end
location, and departure time from start as its three arguments. For the
departure time, we'll use the current time. That way, the arrival time at
[[r[4]]] is guaranteed to be sometime in the future.  If we used [[min]]'s last
update time, this arrival time could have already passed if the distance from
[[min]] to [[r[4]]] is very short!

When we go to submit the new route, Jargo searches for the first waypoint of
the new route in the vehicle's existing route in order to know where to start
splicing in the new route. The location of this waypoint in the existing route
is called the ``branch point''. As we've used [[now]] as the departure time of
the first leg, the first waypoint will differ from [[min]]'s last-known
location! We have to manually reset the time of the first waypoint to be the
time of the last-known location so that Jargo can find the branch point. Recall
that the last-known location is stored in the [[locations]] map, and that the
time component is the 0th element of the map value.

Once we're done, we'll store the leg in the [[legs]] multi-array.

<<Set first leg>>=
leg = this.tools.computeRoute(locations.get(sid)[1], r[4], now);
leg[0] = locations.get(sid)[0];
legs[0] = leg;
<<Debug: set first leg>>
@

\subsubsection{Initialize Route Length and Time}

We'll keep a running sum [[n]] of the leg lengths so that we can initialize the
new route to the correct size. We'll also accumulate the arrival times [[t]] at
the end of each leg so that we can set the correct departure times for
subsequent legs in calls to [[computeRoute]](3).

<<Initialize route length and time>>=
int n = leg.length;
int t = leg[n - 2];
<<Debug: set route length and time>>
@

\subsubsection{Set Remaining Legs}

Now we'll iterate over the remaining vertices in the new schedule and compute
the legs as we go. When we update [[n]], we subtract 2 from it because we don't
want to double count the leg endpoints. The endpoint of one leg is the starting
point of the next leg.

<<Set remaining legs>>=
for (int i = 1; i < p; i++) {
  final int u = bnew_v[(i - 1)];
  final int v = bnew_v[(i - 0)];
  leg = this.tools.computeRoute(u, v, t);
  legs[i] = leg;
  <<Debug: set remaining legs>>

  n += (leg.length - 2);
  t = leg[leg.length - 2];
  <<Debug: set route length and time>>
}
@

\subsubsection{Set Schedule Times}

After all the legs have been computed, we can go to update the schedule event
times. We'll put in all the departure times for all the events. Remember that
each leg is the route between two events, so we'll get just the first element
of each leg.

<<Set schedule times>>=
for (int i = 1; i < legs.length; i++) {
  bnew_t[(i - 1)] = legs[i][0];
  <<Debug: set schedule time>>
}
@

\subsubsection{Set Vehicle End Time}

Now we'll get the arrival time of the last leg, in other words the time of
the last event of the last leg. This event corresponds to the server's
own arrival.

<<Set vehicle end time>>=
bnew_t[(p - 1)] = t;
<<Debug: set vehicle end time>>
@

\subsubsection{Join Schedule Components}

We'll simply iterate through the schedule component arrays to join them
into [[bnew]].

<<Join schedule components>>=
for (int i = 0; i < p; i++) {
  bnew[(3*i + 0)] = bnew_t[i];
  bnew[(3*i + 1)] = bnew_v[i];
  bnew[(3*i + 2)] = bnew_l[i];
  <<Debug: join schedule components>>
}
@

\subsubsection{Join Route Components}

Simlarly, we'll join all the legs together to form the new route
[[wnew]]. We'll use [[n]] here to size the new route. To avoid doubling
up the events, we'll skip the last event of each leg, unless it is the last
leg.

<<Join route components>>=
final int[] wnew = new int[n];
int k = 0;
for (int i = 0; i < legs.length; i++) {
  int rend = (legs[i].length - (i == (legs.length - 1) ? 0 : 2));
  for (int j = 0; j < rend; j++) {
    wnew[k] = legs[i][j];
    <<Debug: join route components>>
    k++;
  }
}
@

\subsubsection{Submit}

Finally, we're ready to submit. The first argument to [[updateServerService]](5)
is [[min]]'s identifier; the next two are the new route and schedule. Following
that is an array containing identifiers of new requests to be serviced.
The last argument is an array containing identifiers of existing requests
that should be removed from the remaining schedule.

<<Submit>>=
this.communicator.updateServerService(sid, wnew, bnew,
    new int[] { r[0] }, new int[] { });
<<Debug: submit>>
@


\section{Methods}
\label{client-nearest: methods}

\subsection{\texttt{handleRequest}(1)}

Now we can write the body of [[handleRequest]](1).  The entire method is
wrapped in try/catch because some method calls can throw exceptions. If an
exception is caught, it gets bubbled up to Jargo via [[ClientException]].

<<NearestNeighbor: handleRequest(1)>>=
void handleRequest(int[] r) throws ClientException, ClientFatalException {
  <<Debug: handle request>>
  try {
    <<Get current time>>
    <<Initialize candidates container>>
    <<Apply delta and range filters>>
    <<Find minimum-range candidate>>
    <<Submit minimum-range candidate>>
  } catch (Exception e) {
    throw new ClientException(e);
  }
}
@

\subsection{\texttt{handleServerLocation}(1)}

Jargo automatically calls [[handleServerLocation]](1) for each server with
a position update. We will take the update and store it into our [[locations]]
array.

<<NearestNeighbor: handleServerLocation(1)>>=
void handleServerLocation(int[] s) {
  this.locations.put(s[0], new int[] { s[1], s[2] });
  <<Debug: put server location>>
}
@

\section{Debug}

Debugging can be turned on by passing the [[-Djargors.client.debug=true]]
runtime flag to the JVM when a Jargo simulation is started. If this flag is
true, the the [[DEBUG]] member variable is true. The following sections print
some helpful messages if debugging is turned on.

\subsection{Debug: Handle Request}

<<Debug: handle request>>=
if (DEBUG) {
  System.out.printf("got request={ id=%d, q=%d, e=%d, l=%d, o=%d, d=%d, b=%d }\n",
      r[0], r[1], r[2], r[3], r[4], r[5], r[6]);
}
@

\subsection{Debug: Get Current Time}

<<Debug: get current time>>=
if (DEBUG) {
  System.out.printf("got now=%d\n", now);
}
@

\subsection{Debug: Initialize Candidates Container}

<<Debug: initialize candidates container>>=
if (DEBUG) {
  System.out.printf("init candidates[]={ }\n");
}
@

\subsection{Debug: Delta Filter}

<<Debug: delta filter>>=
if (DEBUG) {
  System.out.printf("got %d in_delta=%s\n", sid, (in_delta ? "true" : "false"));
}
@

\subsection{Debug: Range Filter}

<<Debug: range filter>>=
if (DEBUG) {
  System.out.printf("got %d in_range=%s\n", sid, (in_range ? "true" : "false"));
}
@

\subsection{Debug: Put Candidate}

<<Debug: put candidate>>=
if (DEBUG) {
  System.out.printf("put candidates[], key=%d, val=%d\n", sid, range);
}
@

\subsection{Debug: Find Minimum-Range Candidate}

<<Debug: find minimum-range candidate>>=
if (DEBUG) {
  System.out.printf("set min={ %d, %d }\n", min.getKey(), min.getValue());
}
@

\subsection{Debug: Get Remaining Schedule}

<<Debug: get remaining schedule>>=
if (DEBUG) {
  System.out.printf("got brem: \n");
  for (int i = 0; i < (brem.length - 3); i+=4) {
    System.out.printf("  { t=%d, v=%d, ls=%d, lr=%d }\n",
        brem[i], brem[i+1], brem[i+2], brem[i+3]);
  }
}
@

\subsection{Debug: Get Number of Events}

<<Debug: get number of events>>=
if (DEBUG) {
  System.out.printf("got m=%d\n", m);
  System.out.printf("got p=%d\n", p);
}
@

\subsection{Debug: Initialize New Schedule}

<<Debug: initialize new schedule>>=
if (DEBUG) {
  System.out.printf("init bnew={ }\n");
  System.out.printf("init bnew_t={ }\n");
  System.out.printf("init bnew_v={ }\n");
  System.out.printf("init bnew_l={ }\n");
}
@

\subsection{Debug: Prepend Request Vertices}

<<Debug: prepend request vertices>>=
if (DEBUG) {
  System.out.printf("set bnew_v[0]=%d\n", bnew_v[0]);
  System.out.printf("set bnew_v[1]=%d\n", bnew_v[1]);
}
@

\subsection{Debug: Set Initial Labels}

<<Debug: set initial labels>>=
if (DEBUG) {
  System.out.printf("set bnew_l[0]=%d\n", bnew_l[0]);
  System.out.printf("set bnew_l[1]=%d\n", bnew_l[1]);
}
@

\subsection{Debug: Set Schedule Vertex and Label}

<<Debug: set schedule vertex and label>>=
if (DEBUG) {
  System.out.printf("set bnew_v[%d]=%d\n", (i + 2), bnew_v[(i + 2)]);
  System.out.printf("set bnew_l[%d]=%d\n", (i + 2), bnew_l[(i + 2)]);
}
@

\subsection{Debug: Set Schedule Time}

<<Debug: set schedule time>>=
if (DEBUG) {
  System.out.printf("set bnew_t[%d]=%d\n", (i - 1), bnew_t[(i - 1)]);
}
@

\subsection{Debug: Set Vehicle End Time}

<<Debug: set vehicle end time>>=
if (DEBUG) {
  System.out.printf("set bnew_t[%d]=%d\n", (p - 1), bnew_t[(p - 1)]);
}
@

\subsection{Debug: Join Schedule Components}

<<Debug: join schedule components>>=
if (DEBUG) {
  System.out.printf("set bnew[%d..%d]={ t=%d, v=%d, l=%d }\n",
      (3*i), (3*i + 2), bnew[(3*i + 0)], bnew[(3*i + 1)], bnew[(3*i + 2)]);
}
@

\subsection{Debug: Initialize Legs Container}

<<Debug: initialize legs container>>=
if (DEBUG) {
  System.out.printf("init legs={ }\n");
}
@

\subsection{Debug: Set First Leg}

<<Debug: set first leg>>=
if (DEBUG) {
  System.out.printf("set legs[0]={ %d, %d, ..., %d, %d  }\n",
      legs[0][0], legs[0][1], legs[0][legs[0].length - 2], legs[0][legs[0].length - 1]);
}
@

\subsection{Debug: Set Remaining Legs}

<<Debug: set remaining legs>>=
if (DEBUG) {
  System.out.printf("set legs[%d]={ %d, %d, ..., %d, %d  }\n", i,
      legs[i][0], legs[i][1], legs[i][legs[i].length - 2], legs[i][legs[i].length - 1]);
}
@

\subsection{Debug: Set Route Length and Time}

<<Debug: set route length and time>>=
if (DEBUG) {
  System.out.printf("set n=%d\n", n);
  System.out.printf("set t=%d\n", t);
}
@

\subsection{Debug: Join Route Components}

<<Debug: join route components>>=
if (DEBUG) {
  System.out.printf("set wnew[%d]=%d\n", k, wnew[k]);
}
@

\subsection{Debug: Submit}

<<Debug: submit>>=
if (DEBUG) {
  System.out.printf("submit:\n");
  System.out.printf("  server=%d\n", sid);
  System.out.printf("  wnew={ %d, %d, ..., %d, %d }\n",
      wnew[0], wnew[1], wnew[wnew.length - 2], wnew[wnew.length - 1]);
  System.out.printf("  bnew={ %d, %d, %d, ..., %d, %d, %d }\n",
      bnew[0], bnew[1], bnew[2],
      bnew[bnew.length - 3], bnew[bnew.length - 2], bnew[bnew.length - 1]);
  System.out.printf("  radd={ %d }\n", r[0]);
  System.out.printf("  rsub={ }\n");
}
@

\subsection{Debug: Put Server Location}

<<Debug: put server location>>=
if (DEBUG) {
  System.out.printf("put locations[%d]=[ %d, %d ]\n", s[0], s[1], s[2]);
}
@

\section{Reference Code}

Here is the full NearestNeighbor.java code, with debug sections removed.

{
\small
\begin{verbatim}
package com.github.jargors.client;
import com.github.jargors.sim.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
public class NearestNeighbor extends Client {
  final int MAX_DELTA = 300;  // seconds from last vehicle location update
  final int MAX_RANGE = 600;  // meters from last vehicle position
  final ConcurrentHashMap<Integer, int[]> locations =
    new ConcurrentHashMap<Integer, int[]>();
  protected void handleRequest(int[] r) throws ClientException, ClientFatalException {
    try {
      final int now = this.communicator.retrieveClock();
      final Map<Integer, Integer> candidates = new HashMap<Integer, Integer>();
      for (final Integer sid : locations.keySet()) {
        final int t = locations.get(sid)[0];
        final int v = locations.get(sid)[1];

        final boolean in_delta = (t >= now - MAX_DELTA);
        if (!in_delta)
          continue;

        final int range = this.tools.computeHaversine(v, r[4]);
        final boolean in_range = (0 != range && range <= MAX_RANGE);
        if (!in_range)
          continue;

        candidates.put(sid, range);
      }
      Entry<Integer, Integer> min = null;
      for (final Entry<Integer, Integer> entry : candidates.entrySet()) {
        if (min == null || min.getValue() > entry.getValue()) {
          min = entry;
        }
      }
      if (min != null) {
        final int sid = min.getKey();
        final int[] brem = this.communicator.queryServerScheduleRemaining(sid, now);
        final int m = brem.length/4;
        final int p = m + 2;
        final int[] bnew = new int[3*p];
        final int[] bnew_t = new int[p];
        final int[] bnew_v = new int[p];
        final int[] bnew_l = new int[p];
        bnew_v[0] = r[4];
        bnew_v[1] = r[5];
        bnew_l[0] = r[0];
        bnew_l[1] = r[0];
        for (int i = 0; i < m; i++) {
          final int bv = brem[(i + 1)];
          final int ls = brem[(i + 2)];
          final int lr = brem[(i + 3)];
          bnew_v[(i + 2)] = bv;
          bnew_l[(i + 2)] = (ls == 0 ? lr : ls);
        }
        final int[][] legs = new int[p][];
        int[] leg = null;
        leg = this.tools.computeRoute(locations.get(sid)[1], r[4], now);
        leg[0] = locations.get(sid)[0];
        legs[0] = leg;
        int n = leg.length;
        int t = leg[n - 2];
        for (int i = 1; i < p; i++) {
          final int u = bnew_v[(i - 1)];
          final int v = bnew_v[(i - 0)];
          leg = this.tools.computeRoute(u, v, t);
          legs[i] = leg;

          n += (leg.length - 2);
          t = leg[leg.length - 2];
        }
        for (int i = 1; i < legs.length; i++) {
          bnew_t[(i - 1)] = legs[i][0];
        }
        bnew_t[(p - 1)] = t;
        for (int i = 0; i < p; i++) {
          bnew[(3*i + 0)] = bnew_t[i];
          bnew[(3*i + 1)] = bnew_v[i];
          bnew[(3*i + 2)] = bnew_l[i];
        }
        final int[] wnew = new int[n];
        int k = 0;
        for (int i = 0; i < legs.length; i++) {
          int rend = (legs[i].length - (i == (legs.length - 1) ? 0 : 2));
          for (int j = 0; j < rend; j++) {
            wnew[k] = legs[i][j];
            k++;
          }
        }
        this.communicator.updateServerService(sid, wnew, bnew,
            new int[] { r[0] }, new int[] { });
      }
    } catch (Exception e) {
      throw new ClientException(e);
    }
  }
  protected void handleServerLocation(int[] s) {
    this.locations.put(s[0], new int[] { s[1], s[2] });
  }
}
\end{verbatim}
}

