\chapter{Client: Nearest A}
\label{client-nearest-a}

<<NearestA.java>>=
<<NearestA: preamble>>
public class NearestA extends Client {
  <<NearestA: member variables>>
  protected <<NearestA: handleRequest(1)>>
  protected <<NearestA: handleServerLocation(1)>>
}
@

<<NearestA: preamble>>=
package com.github.jargors.client;
import com.github.jargors.sim.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
@

<<NearestA: member variables>>=
final int MAX_DELTA = 300;  // seconds from last vehicle location update
final int MAX_RANGE = 600;  // meters from last vehicle position
final ConcurrentHashMap<Integer, int[]> locations =
  new ConcurrentHashMap<Integer, int[]>();
@

<<NearestA: handleRequest(1)>>=
void handleRequest(int[] r) throws ClientException, ClientFatalException {
  <<Debug: handle request>>
  try {
    <<NearestA: Step 1: Initialize>>
    <<NearestA: Step 2: Map and Filter>>
    while (<<NearestA: Go to Reduce?>>) {
      <<NearestA: Step 3: Reduce>>
      <<NearestA: Step 4: Prepare>>
      <<NearestA: Step 5: Schedule>>
      if (<<NearestA: Go to Submit?>>) {
        <<NearestA: Step 6: Route>>
        <<NearestA: Step 7: Submit>>
      } else {
        <<NearestA: Step 8: Reset>>
      }
    }
  } catch (Exception e) {
    throw new ClientException(e);
  }
}
@

<<NearestA: handleServerLocation(1)>>=
void handleServerLocation(int[] s) {
  this.locations.put(s[0], new int[] { s[1], s[2] });
  <<Debug: put server location>>
}
@

\section{Step 1: Initialize}

<<NearestA: Step 1: Initialize>>=
final Map<Integer, Integer> candidates = new HashMap<Integer, Integer>();
Entry<Integer, Integer> min = null;
final int now = this.communicator.retrieveClock();
final int rid = r[0];
final int rq  = r[1];
final int ro  = r[4];
final int rd  = r[5];
boolean ok = false;
<<Debug: initialize NearestA>>
@

\section{Step 2: Map and Filter}

<<NearestA: Step 2: Map and Filter>>=
for (final Integer sid : locations.keySet()) {
  final int t = locations.get(sid)[0];
  final int v = locations.get(sid)[1];

  final boolean in_delta = (t >= now - MAX_DELTA);
  <<Debug: delta filter>>
  if (!in_delta)
    continue;

  final int range = this.tools.computeHaversine(v, ro);
  final boolean in_range = (0 != range && range <= MAX_RANGE);
  <<Debug: range filter>>
  if (!in_range)
    continue;

  candidates.put(sid, range);
  <<Debug: put candidate>>
}
@

\section{Step 3: Reduce}

<<NearestA: Step 3: Reduce>>=
for (final Entry<Integer, Integer> entry : candidates.entrySet()) {
  if (min == null || min.getValue() > entry.getValue()) {
    min = entry;
    <<Debug: find minimum-range candidate>>
  }
}
@

\section{Step 4: Prepare}

<<NearestA: Step 4: Prepare>>=
final int sid = min.getKey();
final int[] brem = this.communicator.queryServerScheduleRemaining(sid, now);
final int[] wact = this.communicator.queryServerRouteActive(sid);
int[] bnew = new int[] { };
int[] wnew = new int[] { };
<<Debug: prepare scheduling and routing>>
@

\section{Step 5: Schedule}

Default case (3) is to check capacity and no cleanup. In special case 1,
no need for check capacity. In special case 2, need to do cleanup.

Capacity check is different for case 2 and 3. For case 2, start from time of
first event. For case 3, start from current time.

<<NearestA: Step 5: Schedule>>=
if (brem[2] == sid) {
  <<Debug: echo NearestA case 1>>
  <<NearestA: Step 5: Case 1>>
} else {
  if (brem[0] == wact[2]) {
    <<Debug: echo NearestA case 2>>
    <<NearestA: Step 5: Case 2>>
  } else {
    <<Debug: echo NearestA case 3>>
    <<NearestA: Step 5: Case 3>>
  }
}
@

\subsection{Step 5: Case 1}

In Case 1, the next event is the server's own destination. Do Prepend.

<<NearestA: Step 5: Case 1>>=
ok = true;
<<Debug: set ok>>
<<Scheduling: Prepend>>
@

\subsection{Step 5: Case 2}

In Cases 2 and 3, the next event is not the server's own destination. In Case
2, the server is already along an edge to the next event. In other words, the
next vertex it will visit is the event vertex. We must do Prepend After because
the server's current course to the next event cannot be altered (see Limitation
\#4). Afterward, we must remove this next event from the newly constructed
schedule (see Limitation \#5).

<<NearestA: Step 5: Case 2>>=
ok = (this.communicator.queryServerCapacityViolations(
    sid, rq, brem[0], brem[4])[0] == 0);
<<Debug: set ok>>
if (ok) {
  <<Scheduling: Prepend After>>
  int[] temp = new int[(bnew.length - 3)];
  for (int i = 0; i < temp.length; i++) {
    temp[i] = bnew[(i + 3)];
  }
  bnew = temp;
}
@

\subsection{Step 5: Case 3}

In Case 3, the next vertex the server will visit is not the next event and
is not the server's own destination. Check capacity, then do Prepend.

<<NearestA: Step 5: Case 3>>=
ok = (this.communicator.queryServerCapacityViolations(
    sid, rq, now, brem[0])[0] == 0);
<<Debug: set ok>>
if (ok) {
  <<Scheduling: Prepend>>
}
@

\section{Step 6: Route}

<<NearestA: Step 6: Route>>=
// start route from next waypoint (not last-visited)
final int[] wbeg = new int[] { wact[2], wact[3] };
if (wact[3] == 0) {
  // if next waypoint is vehicle destination, then start from (now, last-visited)
  wbeg[0] = now;
  wbeg[1] = wact[1];
}
<<Debug: set initial waypoint>>
<<Routing: Shortest Path>>
if (wact[3] == 0) {
  // if next waypoint is vehicle destination, reset route start time to last-visited time
  wnew[0] = locations.get(sid)[0];
}
<<Debug: finish routing>>
@

\section{Step 7: Submit}

<<NearestA: Step 7: Submit>>=
this.communicator.updateServerService(sid, wnew, bnew,
    new int[] { rid }, new int[] { });
<<Debug: submit assignment>>
@

\section{Step 8: Reset}

<<NearestA: Step 8: Reset>>=
min = null;
candidates.remove(sid);
<<Debug: reset>>
@

\section{Conditions for Continuing}

<<NearestA: Go to Reduce?>>=
ok == false && candidates.size() > 0
@

<<NearestA: Go to Submit?>>=
ok == true
@

\section{Debug}

\subsection{Debug: Handle Request}

<<Debug: handle request>>=
if (DEBUG) {
  System.out.printf("got request={ id=%d, q=%d, e=%d, l=%d, o=%d, d=%d, b=%d }\n",
      r[0], r[1], r[2], r[3], r[4], r[5], r[6]);
}
@

\subsection{Debug: Initialize NearestA}

<<Debug: initialize NearestA>>=
if (DEBUG) {
  System.out.printf("got now=%d\n", now);
  System.out.printf("init candidates[]={ }\n");
  System.out.printf("init min=null\n");
  System.out.printf("init ok=false\n");
}
@

\subsection{Debug: Delta Filter}

<<Debug: delta filter>>=
if (DEBUG) {
  System.out.printf("got %d in_delta=%s\n", sid, (in_delta ? "true" : "false"));
}
@

\subsection{Debug: Range Filter}

<<Debug: range filter>>=
if (DEBUG) {
  System.out.printf("got %d in_range=%s\n", sid, (in_range ? "true" : "false"));
}
@

\subsection{Debug: Put Candidate}

<<Debug: put candidate>>=
if (DEBUG) {
  System.out.printf("put candidates[], key=%d, val=%d\n", sid, range);
}
@

\subsection{Debug: Find Minimum-Range Candidate}

<<Debug: find minimum-range candidate>>=
if (DEBUG) {
  System.out.printf("set min={ %d, %d }\n", min.getKey(), min.getValue());
}
@

\subsection{Debug: Prepare Scheduling and Routing}
<<Debug: prepare scheduling and routing>>=
if (DEBUG) {
  System.out.printf("got brem: \n");
  for (int i = 0; i < (brem.length - 3); i+=4) {
    System.out.printf("  { t=%d, v=%d, ls=%d, lr=%d }\n",
        brem[i], brem[i+1], brem[i+2], brem[i+3]);
  }
  System.out.printf("got wact: \n");
  for (int i = 0; i < (wact.length - 1); i += 2) {
    System.out.printf("  { t=%d, v=%d },\n",
      wact[i], wact[i+1]);
  }
}
@

\subsection{Debug: Echo NearestA Case 1}

<<Debug: echo NearestA case 1>>=
if (DEBUG) {
  System.out.printf("goto case 1\n");
}
@

\subsection{Debug: Echo NearestA Case 2}

<<Debug: echo NearestA case 2>>=
if (DEBUG) {
  System.out.printf("goto case 2\n");
}
@

\subsection{Debug: Echo NearestA Case 3}

<<Debug: echo NearestA case 3>>=
if (DEBUG) {
  System.out.printf("goto case 3\n");
}
@

\subsection{Debug: Set Ok}

<<Debug: set ok>>=
if (DEBUG) {
  System.out.printf("set ok=%s\n", ok ? "true" : "false");
}
@

\subsection{Debug: Set Initial Waypoint}

<<Debug: set initial waypoint>>=
if (DEBUG) {
  System.out.printf("set wbeg[0..1]={%d, %d}\n", wbeg[0], wbeg[1]);
}
@

\subsection{Debug: Finish Routing}

<<Debug: finish routing>>=
if (DEBUG) {
  System.out.printf("set wnew[0]=%d\n", wnew[0]);
}
@

\subsection{Debug: Submit}

<<Debug: submit assignment>>=
if (DEBUG) {
  System.out.printf("submit:\n");
  System.out.printf("  server=%d\n", sid);
  System.out.printf("  wnew={ %d, %d, ..., %d, %d }\n",
      wnew[0], wnew[1], wnew[wnew.length - 2], wnew[wnew.length - 1]);
  System.out.printf("  bnew={ %d, %d, %d, ..., %d, %d, %d }\n",
      bnew[0], bnew[1], bnew[2],
      bnew[bnew.length - 3], bnew[bnew.length - 2], bnew[bnew.length - 1]);
  System.out.printf("  radd={ %d }\n", r[0]);
  System.out.printf("  rsub={ }\n");
}
@

\subsection{Debug: Reset}

<<Debug: reset>>=
if (DEBUG) {
  System.out.printf("set min=null, remove candidate %d\n", sid);
}
@

\subsection{Debug: Put Server Location}

<<Debug: put server location>>=
if (DEBUG) {
  System.out.printf("put locations[%d]=[ %d, %d ]\n", s[0], s[1], s[2]);
}
@

\section{Reference}

Here is the full NearestA.java code, with debug sections removed.

{
\small
\begin{verbatim}
package com.github.jargors.client;
import com.github.jargors.sim.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
public class NearestA extends Client {
  final int MAX_DELTA = 300;  // seconds from last vehicle location update
  final int MAX_RANGE = 600;  // meters from last vehicle position
  final ConcurrentHashMap<Integer, int[]> locations =
    new ConcurrentHashMap<Integer, int[]>();
  protected void handleRequest(int[] r) throws ClientException, ClientFatalException {
    final int rid = r[0];
    final int ro  = r[4];
    final int rd  = r[5];
    try {
      final int now = this.communicator.retrieveClock();

      final Map<Integer, Integer> candidates = new HashMap<Integer, Integer>();
      for (final Integer sid : locations.keySet()) {
        final int t = locations.get(sid)[0];
        final int v = locations.get(sid)[1];

        final boolean in_delta = (t >= now - MAX_DELTA);
        if (!in_delta)
          continue;

        final int range = this.tools.computeHaversine(v, ro);
        final boolean in_range = (0 != range && range <= MAX_RANGE);
        if (!in_range)
          continue;

        candidates.put(sid, range);
      }
      Entry<Integer, Integer> min = null;
      for (final Entry<Integer, Integer> entry : candidates.entrySet()) {
        if (min == null || min.getValue() > entry.getValue()) {
          min = entry;
        }
      }
      if (min != null) {
        final int sid = min.getKey();
        final int[] brem = this.communicator.queryServerScheduleRemaining(sid, now);
        final int m = (brem.length/4);
        final int p = (m + 2);

        final int[] bnew = new int[(3*p)];
        bnew[1] = ro;
        bnew[2] = rid;
        bnew[4] = rd;
        bnew[5] = rid;
        for (int i = 0; i < m; i++) {
          final int bv = brem[(4*i + 1)];
          final int ls = brem[(4*i + 2)];
          final int lr = brem[(4*i + 3)];
          bnew[(3*i + 7)] = bv;
          bnew[(3*i + 8)] = (ls == 0 ? lr : ls);
        }
        final int[][] legs = new int[p][];

        int[] leg = this.tools.computeRoute(locations.get(sid)[1], ro, now);
        int n = leg.length;
        int t = leg[n - 2];

        leg[0] = locations.get(sid)[0];
        legs[0] = leg;
        for (int i = 1; i < p; i++) {
          final int u = bnew[(3*i - 2)];
          final int v = bnew[(3*i + 1)];
          leg = this.tools.computeRoute(u, v, t);
          legs[i] = leg;

          n += (leg.length - 2);
          t = leg[leg.length - 2];
        }
        final int[] wnew = new int[n];
        {
          int k = 0;
          for (int i = 0; i < legs.length; i++) {
            int rend = (legs[i].length - (i == (legs.length - 1) ? 0 : 2));
            for (int j = 0; j < rend; j++) {
              wnew[k] = legs[i][j];
              k++;
            }
          }
        }
        for (int i = 1; i < legs.length; i++) {
          bnew[(3*i - 3)] = legs[i][0];
        }

        bnew[(3*p - 3)] = t;
        this.communicator.updateServerService(sid, wnew, bnew,
            new int[] { rid }, new int[] { });
      }
    } catch (Exception e) {
      throw new ClientException(e);
    }
  }
  protected void handleServerLocation(int[] s) {
    this.locations.put(s[0], new int[] { s[1], s[2] });
  }
}
\end{verbatim}
}

