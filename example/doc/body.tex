\part{Client Algorithms}% ===> this file was generated automatically by noweave --- better not edit it
\label{part-client}

\chapter{Overview}
\label{client-overview}

\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

This chapter lists an overview of the example client algorithms. Go to
the page next to each method name to go directly to the method definition.
Tables~\ref{tab:search-algorithms}~and~\ref{tab:join-algorithms} summarize some
features of the algorithms.

\begin{table}[h]
\begin{center}
\caption{Summary of Search-Based Algorithms}
\label{tab:search-algorithms}
\begin{tabular}{|l|l|l|l|l|}
\hline
Ch. & Algorithm & Selection Predicate & Scheduling Strategy & Routing Strategy \\
\hline
Ch.~\ref{client-nearest} & Nearest Neighbor & Minimum proximity & Prepend to front & Shortest-path \\
Ch.~\ref{client-greedy} & Greedy Insertion & Minimum routing cost & Insertion heuristic & Shortest-path \\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\caption{Summary of Join-Based Algorithms (TODO: Implement some join algorithms)}
\label{tab:join-algorithms}
\begin{tabular}{|l|l|l|l|l|}
\hline
Ch. & Algorithm & Join Strategy & Scheduling Strategy & Routing Strategy \\
\hline
\end{tabular}
\end{center}
\end{table}

Ridesharing algorithms can be classified as search-based or join-based.
Search-based algorithms use selection predicates to decide which vehicles to
assign to which customers. Join-based algorithms aim to group vehicles and
customers together, with each vehicle serving all the customers in its group.
Both types perform scheduling and routing.  Scheduling means to arrange the
future pick-ups and drop-offs that a vehicle is assigned to complete. Routing
means to compute the route that a vehicle should follow in order to go to the
pick-ups and drop-offs in the scheduled order.

For search-based algorithms, the predicate usually minimizes a cost. The
minimum-proximity predicate finds the vehicle that minimizes Euclidean or
Haversine distance. The minimum-routing-cost predicate minimizes the extra
routing distance from assignment to the customer.

For join-based algorithms... TODO

Several scheduling strategies exist. The prepend-to-front strategy simply
arranges the customer's pick-up and drop-off at the front of the assigned
vehicle's schedule. The insertion-heuristic strategy finds the best position to
insert the pick-up and drop-off without rearranging the existing pick-ups and
drop-offs in the schedule.

For routing strategies, the most common is shortest-path. This strategy
simply finds the shortest path through all the pick-ups and drop-offs in a
vehicle's schedule.

\section{NearestNeighbor}
\label{client-overview: nearest}

The nearest-neighbor algorithm is a search-based algorithm that uses
minimum-proximity as its selection predicate. It is implemented with two Jargo
methods. Method {\Tt{}handleRequest\nwendquote}(1) searches for and assigns the
minimum-proximity vehicle to a given customer request. Method
{\Tt{}handleServerLocation\nwendquote}(1) stores new vehicle locations in the algorithm's
local cache as they are updated. Turn to the page next to the method name
to see details.

\nwfilename{src/client-overview.nw}\nwbegincode{1}\sublabel{NW3eY1Ju-3yym9S-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3eY1Ju-3yym9S-1}}}\moddef{\code{}NearestNeighbor\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-3yym9S-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-QNBZk-1}}\nwenddeflinemarkup
protected \LA{}NearestNeighbor: handleRequest(1)~{\nwtagstyle{}\subpageref{NW2MZpIA-16KpI3-1}}\RA{}
protected \LA{}NearestNeighbor: handleServerLocation(1)~{\nwtagstyle{}\subpageref{NW2MZpIA-fLFsG-1}}\RA{}
\nwused{\\{NW2MZpIA-QNBZk-1}}\nwendcode{}

\nwixlogsorted{c}{{\code{}GreedyInsertion\edoc{} member variables}{NWkwPRG-jESV1-1}{\nwixu{NWkwPRG-1Tuf6f-1}\nwixd{NWkwPRG-jESV1-1}}}%
\nwixlogsorted{c}{{\code{}GreedyInsertion\edoc{} methods}{NW3eY1Ju-2B0O1t-1}{\nwixd{NW3eY1Ju-2B0O1t-1}\nwixd{NW3eY1Ju-2B0O1t-2}\nwixu{NWkwPRG-1Tuf6f-1}}}%
\nwixlogsorted{c}{{\code{}NearestNeighbor\edoc{} member variables}{NW2MZpIA-4N5YZL-1}{\nwixu{NW2MZpIA-QNBZk-1}\nwixd{NW2MZpIA-4N5YZL-1}}}%
\nwixlogsorted{c}{{\code{}NearestNeighbor\edoc{} methods}{NW3eY1Ju-3yym9S-1}{\nwixd{NW3eY1Ju-3yym9S-1}\nwixu{NW2MZpIA-QNBZk-1}}}%
\nwixlogsorted{c}{{Accept server solution}{NWkwPRG-1EyDWB-1}{\nwixd{NWkwPRG-1EyDWB-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Accept single solution}{NWkwPRG-47ILqi-1}{\nwixu{NWkwPRG-4dVkBS-1}\nwixu{NWkwPRG-22IadP-1}\nwixd{NWkwPRG-47ILqi-1}}}%
\nwixlogsorted{c}{{Apply delta and range filters}{NW2MZpIA-1hztkR-1}{\nwixd{NW2MZpIA-1hztkR-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{Broadway.java}{NW1QgbvE-3asg0V-1}{\nwixd{NW1QgbvE-3asg0V-1}}}%
\nwixlogsorted{c}{{Case 1: server is idle or heading towards own destination}{NWkwPRG-4dVkBS-1}{\nwixd{NWkwPRG-4dVkBS-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Case 2: server is heading towards a customer}{NWkwPRG-22IadP-1}{\nwixd{NWkwPRG-22IadP-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Check capacity}{NWkwPRG-27P27q-1}{\nwixu{NWkwPRG-3KjiZY-1}\nwixd{NWkwPRG-27P27q-1}}}%
\nwixlogsorted{c}{{Check feasible cost}{NWkwPRG-UGv0L-1}{\nwixd{NWkwPRG-UGv0L-1}\nwixu{NWkwPRG-23iwWy-1}}}%
\nwixlogsorted{c}{{Check feasible time window}{NWkwPRG-4PssH0-1}{\nwixd{NWkwPRG-4PssH0-1}\nwixu{NWkwPRG-23iwWy-1}}}%
\nwixlogsorted{c}{{Compute sequence}{NWkwPRG-3KjiZY-1}{\nwixu{NWkwPRG-22IadP-1}\nwixd{NWkwPRG-3KjiZY-1}}}%
\nwixlogsorted{c}{{Construct w from cache}{NWkwPRG-4ACdbX-1}{\nwixu{NWkwPRG-29TDYN-1}\nwixd{NWkwPRG-4ACdbX-1}}}%
\nwixlogsorted{c}{{Debug: delta filter}{NW2MZpIA-2I20iB-1}{\nwixu{NW2MZpIA-1hztkR-1}\nwixd{NW2MZpIA-2I20iB-1}}}%
\nwixlogsorted{c}{{Debug: find minimum-range candidate}{NW2MZpIA-3aXcFM-1}{\nwixu{NW2MZpIA-2TDXjw-1}\nwixd{NW2MZpIA-3aXcFM-1}}}%
\nwixlogsorted{c}{{Debug: get current time}{NW2MZpIA-xqgdv-1}{\nwixu{NW2MZpIA-2qkQZx-1}\nwixd{NW2MZpIA-xqgdv-1}}}%
\nwixlogsorted{c}{{Debug: get number of events}{NW2MZpIA-1TMdCp-1}{\nwixu{NW2MZpIA-3D9vfA-1}\nwixd{NW2MZpIA-1TMdCp-1}}}%
\nwixlogsorted{c}{{Debug: get remaining schedule}{NW2MZpIA-2RxwyC-1}{\nwixu{NW2MZpIA-471Pa7-1}\nwixd{NW2MZpIA-2RxwyC-1}}}%
\nwixlogsorted{c}{{Debug: handle request}{NW2MZpIA-33A3UY-1}{\nwixu{NW2MZpIA-16KpI3-1}\nwixd{NW2MZpIA-33A3UY-1}}}%
\nwixlogsorted{c}{{Debug: initialize candidates container}{NW2MZpIA-3LGRX7-1}{\nwixu{NW2MZpIA-3doegf-1}\nwixd{NW2MZpIA-3LGRX7-1}}}%
\nwixlogsorted{c}{{Debug: initialize legs container}{NW2MZpIA-3R3yVH-1}{\nwixu{NW2MZpIA-2qHHby-1}\nwixd{NW2MZpIA-3R3yVH-1}}}%
\nwixlogsorted{c}{{Debug: initialize new schedule}{NW2MZpIA-GmK8M-1}{\nwixu{NW2MZpIA-3B4gix-1}\nwixd{NW2MZpIA-GmK8M-1}}}%
\nwixlogsorted{c}{{Debug: join route components}{NW2MZpIA-J6KjD-1}{\nwixu{NW2MZpIA-2lA6Dh-1}\nwixd{NW2MZpIA-J6KjD-1}}}%
\nwixlogsorted{c}{{Debug: join schedule components}{NW2MZpIA-qM9ER-1}{\nwixu{NW2MZpIA-4cHUFD-1}\nwixd{NW2MZpIA-qM9ER-1}}}%
\nwixlogsorted{c}{{Debug: prepend request vertices}{NW2MZpIA-2XKZtm-1}{\nwixu{NW2MZpIA-1cghJy-1}\nwixd{NW2MZpIA-2XKZtm-1}}}%
\nwixlogsorted{c}{{Debug: put candidate}{NW2MZpIA-1Lo26M-1}{\nwixu{NW2MZpIA-1hztkR-1}\nwixd{NW2MZpIA-1Lo26M-1}}}%
\nwixlogsorted{c}{{Debug: put server location}{NW2MZpIA-hcsfv-1}{\nwixu{NW2MZpIA-fLFsG-1}\nwixd{NW2MZpIA-hcsfv-1}}}%
\nwixlogsorted{c}{{Debug: range filter}{NW2MZpIA-4aukgD-1}{\nwixu{NW2MZpIA-1hztkR-1}\nwixd{NW2MZpIA-4aukgD-1}}}%
\nwixlogsorted{c}{{Debug: set first leg}{NW2MZpIA-1F8aiy-1}{\nwixu{NW2MZpIA-K9R8L-1}\nwixd{NW2MZpIA-1F8aiy-1}}}%
\nwixlogsorted{c}{{Debug: set initial labels}{NW2MZpIA-1sURxT-1}{\nwixu{NW2MZpIA-1geA7a-1}\nwixd{NW2MZpIA-1sURxT-1}}}%
\nwixlogsorted{c}{{Debug: set remaining legs}{NW2MZpIA-Zbf0J-1}{\nwixu{NW2MZpIA-h4XZK-1}\nwixd{NW2MZpIA-Zbf0J-1}}}%
\nwixlogsorted{c}{{Debug: set route length and time}{NW2MZpIA-3WOc2v-1}{\nwixu{NW2MZpIA-23lui7-1}\nwixu{NW2MZpIA-h4XZK-1}\nwixd{NW2MZpIA-3WOc2v-1}}}%
\nwixlogsorted{c}{{Debug: set schedule time}{NW2MZpIA-1EJRY4-1}{\nwixu{NW2MZpIA-2bjij9-1}\nwixd{NW2MZpIA-1EJRY4-1}}}%
\nwixlogsorted{c}{{Debug: set schedule vertex and label}{NW2MZpIA-1lkGjK-1}{\nwixu{NW2MZpIA-4F29O2-1}\nwixd{NW2MZpIA-1lkGjK-1}}}%
\nwixlogsorted{c}{{Debug: set vehicle end time}{NW2MZpIA-3ZHBo5-1}{\nwixu{NW2MZpIA-18NavW-1}\nwixd{NW2MZpIA-3ZHBo5-1}}}%
\nwixlogsorted{c}{{Debug: submit}{NW2MZpIA-2e4BPs-1}{\nwixu{NW2MZpIA-2gYtpS-1}\nwixd{NW2MZpIA-2e4BPs-1}}}%
\nwixlogsorted{c}{{Find minimum-range candidate}{NW2MZpIA-2TDXjw-1}{\nwixd{NW2MZpIA-2TDXjw-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{Get current time}{NW2MZpIA-2qkQZx-1}{\nwixd{NW2MZpIA-2qkQZx-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{Get number of events}{NW2MZpIA-3D9vfA-1}{\nwixu{NW2MZpIA-3sZXk2-2}\nwixd{NW2MZpIA-3D9vfA-1}}}%
\nwixlogsorted{c}{{Get remaining schedule}{NW2MZpIA-471Pa7-1}{\nwixu{NW2MZpIA-3sZXk2-2}\nwixd{NW2MZpIA-471Pa7-1}}}%
\nwixlogsorted{c}{{GreedyInsertion.java}{NWkwPRG-1Tuf6f-1}{\nwixd{NWkwPRG-1Tuf6f-1}}}%
\nwixlogsorted{c}{{GreedyInsertion.java preamble}{NWkwPRG-1neuor-1}{\nwixu{NWkwPRG-1Tuf6f-1}\nwixd{NWkwPRG-1neuor-1}}}%
\nwixlogsorted{c}{{GreedyInsertion: computeCost(6)}{NWkwPRG-23iwWy-1}{\nwixu{NW3eY1Ju-2B0O1t-2}\nwixd{NWkwPRG-23iwWy-1}}}%
\nwixlogsorted{c}{{GreedyInsertion: end(0)}{NWkwPRG-222iyz-1}{\nwixu{NW3eY1Ju-2B0O1t-1}\nwixd{NWkwPRG-222iyz-1}}}%
\nwixlogsorted{c}{{GreedyInsertion: endCollectServerLocations(1)}{NWkwPRG-1cMqeO-1}{\nwixu{NW3eY1Ju-2B0O1t-1}\nwixd{NWkwPRG-1cMqeO-1}}}%
\nwixlogsorted{c}{{GreedyInsertion: handleRequest(1)}{NWkwPRG-2OWvsM-1}{\nwixu{NW3eY1Ju-2B0O1t-1}\nwixd{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Initialize candidates container}{NW2MZpIA-3doegf-1}{\nwixd{NW2MZpIA-3doegf-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{Initialize global vars}{NWkwPRG-jOToH-1}{\nwixd{NWkwPRG-jOToH-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Initialize legs container}{NW2MZpIA-2qHHby-1}{\nwixu{NW2MZpIA-3sZXk2-4}\nwixd{NW2MZpIA-2qHHby-1}}}%
\nwixlogsorted{c}{{Initialize new schedule}{NW2MZpIA-3B4gix-1}{\nwixu{NW2MZpIA-3sZXk2-2}\nwixd{NW2MZpIA-3B4gix-1}}}%
\nwixlogsorted{c}{{Initialize route length and time}{NW2MZpIA-23lui7-1}{\nwixu{NW2MZpIA-3sZXk2-4}\nwixd{NW2MZpIA-23lui7-1}}}%
\nwixlogsorted{c}{{Initialize server vars}{NWkwPRG-3y7kuU-1}{\nwixd{NWkwPRG-3y7kuU-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Join route components}{NW2MZpIA-2lA6Dh-1}{\nwixu{NW2MZpIA-3sZXk2-6}\nwixd{NW2MZpIA-2lA6Dh-1}}}%
\nwixlogsorted{c}{{Join schedule components}{NW2MZpIA-4cHUFD-1}{\nwixu{NW2MZpIA-3sZXk2-6}\nwixd{NW2MZpIA-4cHUFD-1}}}%
\nwixlogsorted{c}{{NearestNeighbor.java}{NW2MZpIA-QNBZk-1}{\nwixd{NW2MZpIA-QNBZk-1}}}%
\nwixlogsorted{c}{{NearestNeighbor.java preamble}{NW2MZpIA-2sgckr-1}{\nwixu{NW2MZpIA-QNBZk-1}\nwixd{NW2MZpIA-2sgckr-1}\nwixd{NW2MZpIA-2sgckr-2}}}%
\nwixlogsorted{c}{{NearestNeighbor: handleRequest(1)}{NW2MZpIA-16KpI3-1}{\nwixu{NW3eY1Ju-3yym9S-1}\nwixd{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{NearestNeighbor: handleServerLocation(1)}{NW2MZpIA-fLFsG-1}{\nwixu{NW3eY1Ju-3yym9S-1}\nwixd{NW2MZpIA-fLFsG-1}}}%
\nwixlogsorted{c}{{Prepend request vertices}{NW2MZpIA-1cghJy-1}{\nwixu{NW2MZpIA-3sZXk2-3}\nwixd{NW2MZpIA-1cghJy-1}}}%
\nwixlogsorted{c}{{Set first leg}{NW2MZpIA-K9R8L-1}{\nwixu{NW2MZpIA-3sZXk2-4}\nwixd{NW2MZpIA-K9R8L-1}}}%
\nwixlogsorted{c}{{Set initial labels}{NW2MZpIA-1geA7a-1}{\nwixu{NW2MZpIA-3sZXk2-3}\nwixd{NW2MZpIA-1geA7a-1}}}%
\nwixlogsorted{c}{{Set remaining legs}{NW2MZpIA-h4XZK-1}{\nwixu{NW2MZpIA-3sZXk2-5}\nwixd{NW2MZpIA-h4XZK-1}}}%
\nwixlogsorted{c}{{Set remaining vertices and labels}{NW2MZpIA-4F29O2-1}{\nwixu{NW2MZpIA-3sZXk2-3}\nwixd{NW2MZpIA-4F29O2-1}}}%
\nwixlogsorted{c}{{Set schedule times}{NW2MZpIA-2bjij9-1}{\nwixu{NW2MZpIA-3sZXk2-5}\nwixd{NW2MZpIA-2bjij9-1}}}%
\nwixlogsorted{c}{{Set vehicle end time}{NW2MZpIA-18NavW-1}{\nwixu{NW2MZpIA-3sZXk2-5}\nwixd{NW2MZpIA-18NavW-1}}}%
\nwixlogsorted{c}{{Submit}{NW2MZpIA-2gYtpS-1}{\nwixu{NW2MZpIA-3sZXk2-7}\nwixd{NW2MZpIA-2gYtpS-1}}}%
\nwixlogsorted{c}{{Submit global solution}{NWkwPRG-29TDYN-1}{\nwixd{NWkwPRG-29TDYN-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Submit minimum-range candidate}{NW2MZpIA-3sZXk2-1}{\nwixd{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-3sZXk2-2}\nwixd{NW2MZpIA-3sZXk2-3}\nwixd{NW2MZpIA-3sZXk2-4}\nwixd{NW2MZpIA-3sZXk2-5}\nwixd{NW2MZpIA-3sZXk2-6}\nwixd{NW2MZpIA-3sZXk2-7}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwbegindocs{2}\nwdocspar

\section{GreedyInsertion}
\label{client-overview: greedy}

The greedy-insertion algorithm...

\nwenddocs{}\nwbegincode{3}\sublabel{NW3eY1Ju-2B0O1t-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-1}}}\moddef{\code{}GreedyInsertion\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-1Tuf6f-1}}\nwprevnextdefs{\relax}{NW3eY1Ju-2B0O1t-2}\nwenddeflinemarkup
protected \LA{}GreedyInsertion: handleRequest(1)~{\nwtagstyle{}\subpageref{NWkwPRG-2OWvsM-1}}\RA{}
protected \LA{}GreedyInsertion: endCollectServerLocations(1)~{\nwtagstyle{}\subpageref{NWkwPRG-1cMqeO-1}}\RA{}
protected \LA{}GreedyInsertion: end(0)~{\nwtagstyle{}\subpageref{NWkwPRG-222iyz-1}}\RA{}
\nwalsodefined{\\{NW3eY1Ju-2B0O1t-2}}\nwused{\\{NWkwPRG-1Tuf6f-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

\nwenddocs{}\nwbegincode{5}\sublabel{NW3eY1Ju-2B0O1t-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-2}}}\moddef{\code{}GreedyInsertion\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-1Tuf6f-1}}\nwprevnextdefs{NW3eY1Ju-2B0O1t-1}{\relax}\nwenddeflinemarkup
private \LA{}GreedyInsertion: computeCost(6)~{\nwtagstyle{}\subpageref{NWkwPRG-23iwWy-1}}\RA{}
\nwused{\\{NWkwPRG-1Tuf6f-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

\nwenddocs{}\nwfilename{src/client-nearest.nw}\nwbegindocs{0}\chapter{Client: NearestNeighbor}
\label{client-nearest}

Here is a basic implementation of the nearest-neighbor algorithm. See
Chapter~\ref{client-overview: nearest} for an overview of the methods.  This
implementation doesn't check capacity or time-window constraints If capacity is
violated, Jargo automatically rejects the submission. If a time window is
violated, Jargo records the violation. Time windows are considered to be
``soft'' constraints because they are hard to guarantee due to traffic.

Let's start. We'll write a {\Tt{}NearestNeighbor\nwendquote} class extending Jargo's base
{\Tt{}Client\nwendquote} class. Angle brackets indicate a code chunk. Go to the page number
next to the chunk to see the code body. A triple bar ($\equiv$) after angle
brackets means we're defining a new chunk. Here, we're defining the
NearestNeighbor.java chunk. This is a special ``root'' chunk that gets written
to disk as Java source.

\nwenddocs{}\nwbegincode{1}\sublabel{NW2MZpIA-QNBZk-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-QNBZk-1}}}\moddef{NearestNeighbor.java~{\nwtagstyle{}\subpageref{NW2MZpIA-QNBZk-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}NearestNeighbor.java preamble~{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-1}}\RA{}
public class NearestNeighbor extends Client \{
  \LA{}\code{}NearestNeighbor\edoc{} member variables~{\nwtagstyle{}\subpageref{NW2MZpIA-4N5YZL-1}}\RA{}
  \LA{}\code{}NearestNeighbor\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-3yym9S-1}}\RA{}
\}
\nwnotused{NearestNeighbor.java}\nwendcode{}\nwbegindocs{2}\nwdocspar

\section{Preamble}
\label{NearestNeighbor: preamble}


First we'll tell Java which package to put our class.

\nwenddocs{}\nwbegincode{3}\sublabel{NW2MZpIA-2sgckr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-1}}}\moddef{NearestNeighbor.java preamble~{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-QNBZk-1}}\nwprevnextdefs{\relax}{NW2MZpIA-2sgckr-2}\nwenddeflinemarkup
package com.github.jargors.client;
\nwalsodefined{\\{NW2MZpIA-2sgckr-2}}\nwused{\\{NW2MZpIA-QNBZk-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

Next we'll import Jargo {\Tt{}sim\nwendquote} components and some standard Java utilities.
The $+\equiv$ symbol after the angle brackets means we're adding to an existing
chunk.

\nwenddocs{}\nwbegincode{5}\sublabel{NW2MZpIA-2sgckr-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-2}}}\moddef{NearestNeighbor.java preamble~{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-QNBZk-1}}\nwprevnextdefs{NW2MZpIA-2sgckr-1}{\relax}\nwenddeflinemarkup
import com.github.jargors.sim.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
\nwused{\\{NW2MZpIA-QNBZk-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

\section{Member Variables}
\label{client-nearest: member-variables}

Now we'll define the member variables. This implementation uses two filters to
narrow down the nearest vehicle. We'll set their thresholds as member
variables. For each vehicle, integer {\Tt{}MAX{\_}DELTA\nwendquote} gives the maximum seconds
from the vehicle's last update for the vehicle to be considered a candidate.
Integer {\Tt{}MAX{\_}RANGE\nwendquote} gives the maximum proximity, in meters, from the
vehicle's last-known location. We'll also initialize a {\Tt{}locations\nwendquote} map for
storing vehicle locations.

\nwenddocs{}\nwbegincode{7}\sublabel{NW2MZpIA-4N5YZL-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-4N5YZL-1}}}\moddef{\code{}NearestNeighbor\edoc{} member variables~{\nwtagstyle{}\subpageref{NW2MZpIA-4N5YZL-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-QNBZk-1}}\nwenddeflinemarkup
final int MAX_DELTA = 300;  // seconds from last vehicle location update
final int MAX_RANGE = 600;  // meters from last vehicle position
final ConcurrentHashMap<Integer, int[]> locations =
  new ConcurrentHashMap<Integer, int[]>();
\nwused{\\{NW2MZpIA-QNBZk-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

\section{Chunks}
\label{NearestNeighbor: chunks}

Before writing the methods, we'll divide the functionality into easily
understood code chunks. The first chunk gets the current simulation world time.
This time is used to check how long ago was the last positional update for a
vehicle, to ask a vehicle what is its remaining schedule from this time
forward, and to compute future routes. Jargo routes have both time and vertex
components.

\subsection{Get Current Time}

The base {\Tt{}Client\nwendquote} class has a {\Tt{}Communicator\nwendquote} member object called
{\Tt{}communicator\nwendquote}. This object has methods for reading and writing the
simulation state. See the Jargo User Manual for more details.

\nwenddocs{}\nwbegincode{9}\sublabel{NW2MZpIA-2qkQZx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2qkQZx-1}}}\moddef{Get current time~{\nwtagstyle{}\subpageref{NW2MZpIA-2qkQZx-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
final int now = this.communicator.retrieveClock();
\LA{}Debug: get current time~{\nwtagstyle{}\subpageref{NW2MZpIA-xqgdv-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

\subsection{Initialize Candidates Container}

For each incoming request, we'll initialize an empty map of candidate vehicles
called {\Tt{}candidates\nwendquote}. The map key will be the vehicle's identifier and the
value will be distance to its last-known location.

\nwenddocs{}\nwbegincode{11}\sublabel{NW2MZpIA-3doegf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3doegf-1}}}\moddef{Initialize candidates container~{\nwtagstyle{}\subpageref{NW2MZpIA-3doegf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
final Map<Integer, Integer> candidates = new HashMap<Integer, Integer>();
\LA{}Debug: initialize candidates container~{\nwtagstyle{}\subpageref{NW2MZpIA-3LGRX7-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

\subsection{Apply Delta and Range Filters}

We'll apply the delta and range filters to narrow down the candidates. The
{\Tt{}locations\nwendquote} map maps vehicle identifiers to last-known location waypoints. A
Jargo waypoint is a $(t,v)$ pair. The $t$ component is a time and the $v$
component is a road network vertex. The stored last-known location waypoints
indicate the time and location of the last update.

The base {\Tt{}Client\nwendquote} class has a {\Tt{}Tools\nwendquote} member object called {\Tt{}tools\nwendquote} with
some convenience methods. Here we will use {\Tt{}tools\nwendquote} to compute Haversine.  See
the Jargo User Manual for more details.

\nwenddocs{}\nwbegincode{13}\sublabel{NW2MZpIA-1hztkR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1hztkR-1}}}\moddef{Apply delta and range filters~{\nwtagstyle{}\subpageref{NW2MZpIA-1hztkR-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
for (final Integer sid : locations.keySet()) \{
  final int t = locations.get(sid)[0];
  final int v = locations.get(sid)[1];

  final boolean in_delta = (t >= now - MAX_DELTA);
  \LA{}Debug: delta filter~{\nwtagstyle{}\subpageref{NW2MZpIA-2I20iB-1}}\RA{}
  if (!in_delta)
    continue;

  final int range = this.tools.computeHaversine(v, r[4]);
  final boolean in_range = (range <= MAX_RANGE);
  \LA{}Debug: range filter~{\nwtagstyle{}\subpageref{NW2MZpIA-4aukgD-1}}\RA{}
  if (!in_range)
    continue;

  candidates.put(sid, range);
  \LA{}Debug: put candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-1Lo26M-1}}\RA{}
\}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

\subsection{Find Minimum-Range Candidate}

To find the minimum-range candidate, we'll iterate over the candidates while
keeping the one with smaller range.

\nwenddocs{}\nwbegincode{15}\sublabel{NW2MZpIA-2TDXjw-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2TDXjw-1}}}\moddef{Find minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-2TDXjw-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
Entry<Integer, Integer> min = null;
for (final Entry<Integer, Integer> entry : candidates.entrySet()) \{
  if (min == null || min.getValue() > entry.getValue()) \{
    min = entry;
    \LA{}Debug: find minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3aXcFM-1}}\RA{}
  \}
\}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

\subsection{Submit Minimum-Range Candidate}

After we've found the minimum-range candidate, we'll use {\Tt{}Communicator\nwendquote}'s
{\Tt{}updateServerService\nwendquote}(5) method to submit the assignment into the Jargo
simulator. This method mimics the functionality of a service provider sending a
job update to a ridesharing vehicle. To update the job, the vehicle needs to
know the new schedule and the new route. The below chunk will compute these two
things. It's the most complicated chunk, so we'll divide it into several
sub-chunks.

To begin, we'll only submit something if a minimum-range candidate {\Tt{}min\nwendquote} was
found.

\nwenddocs{}\nwbegincode{17}\sublabel{NW2MZpIA-3sZXk2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\moddef{Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwprevnextdefs{\relax}{NW2MZpIA-3sZXk2-2}\nwenddeflinemarkup
if (min != null) \{
\nwalsodefined{\\{NW2MZpIA-3sZXk2-2}\\{NW2MZpIA-3sZXk2-3}\\{NW2MZpIA-3sZXk2-4}\\{NW2MZpIA-3sZXk2-5}\\{NW2MZpIA-3sZXk2-6}\\{NW2MZpIA-3sZXk2-7}}\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

If so, then we'll perform the following steps.

\begin{enumerate}

\item First we'll get {\Tt{}min\nwendquote}'s remaining schedule, count the number of
pick-up and drop-off events in the schedule, and use the number to initialize
a new schedule.

\nwenddocs{}\nwbegincode{19}\sublabel{NW2MZpIA-3sZXk2-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-2}}}\moddef{Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwprevnextdefs{NW2MZpIA-3sZXk2-1}{NW2MZpIA-3sZXk2-3}\nwenddeflinemarkup
  \LA{}Get remaining schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-471Pa7-1}}\RA{}
  \LA{}Get number of events~{\nwtagstyle{}\subpageref{NW2MZpIA-3D9vfA-1}}\RA{}
  \LA{}Initialize new schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-3B4gix-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{20}%
%
\item Next we'll populate the new schedule with vertices and labels. In a Jargo
schedule, each customer pick-up or drop-off event is labeled with a request
identifier to indicate which customer is getting picked up or dropped off.
As we're using the prepend-to-front scheduling strategy, we'll
put the request's pick-up and drop-off to the front of the new schedule.

\nwenddocs{}\nwbegincode{21}\sublabel{NW2MZpIA-3sZXk2-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-3}}}\moddef{Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwprevnextdefs{NW2MZpIA-3sZXk2-2}{NW2MZpIA-3sZXk2-4}\nwenddeflinemarkup
  \LA{}Prepend request vertices~{\nwtagstyle{}\subpageref{NW2MZpIA-1cghJy-1}}\RA{}
  \LA{}Set initial labels~{\nwtagstyle{}\subpageref{NW2MZpIA-1geA7a-1}}\RA{}
  \LA{}Set remaining vertices and labels~{\nwtagstyle{}\subpageref{NW2MZpIA-4F29O2-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{22}%
%
\item Then we'll compute the shortest paths through the pick-up and drop-off
events in sequence in order to get the new route. First we'll compute the first
``leg'' of the route, from {\Tt{}min\nwendquote}'s last-known location to the request's
pick-up location. We'll record this leg, along with the length of the leg and
the duration of the leg.

\nwenddocs{}\nwbegincode{23}\sublabel{NW2MZpIA-3sZXk2-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-4}}}\moddef{Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwprevnextdefs{NW2MZpIA-3sZXk2-3}{NW2MZpIA-3sZXk2-5}\nwenddeflinemarkup
  \LA{}Initialize legs container~{\nwtagstyle{}\subpageref{NW2MZpIA-2qHHby-1}}\RA{}
  \LA{}Set first leg~{\nwtagstyle{}\subpageref{NW2MZpIA-K9R8L-1}}\RA{}
  \LA{}Initialize route length and time~{\nwtagstyle{}\subpageref{NW2MZpIA-23lui7-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{24}%
%
\item We'll then compute the remaining legs of the route. Once we've got all
the legs, we can go set the time components of the new schedule. The
times correspond to when each leg begins and ends.

\nwenddocs{}\nwbegincode{25}\sublabel{NW2MZpIA-3sZXk2-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-5}}}\moddef{Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwprevnextdefs{NW2MZpIA-3sZXk2-4}{NW2MZpIA-3sZXk2-6}\nwenddeflinemarkup
  \LA{}Set remaining legs~{\nwtagstyle{}\subpageref{NW2MZpIA-h4XZK-1}}\RA{}
  \LA{}Set schedule times~{\nwtagstyle{}\subpageref{NW2MZpIA-2bjij9-1}}\RA{}
  \LA{}Set vehicle end time~{\nwtagstyle{}\subpageref{NW2MZpIA-18NavW-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{26}%
%
\item We'll join all the schedule components and route legs into single
flattened arrays for submission.

\nwenddocs{}\nwbegincode{27}\sublabel{NW2MZpIA-3sZXk2-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-6}}}\moddef{Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwprevnextdefs{NW2MZpIA-3sZXk2-5}{NW2MZpIA-3sZXk2-7}\nwenddeflinemarkup
  \LA{}Join schedule components~{\nwtagstyle{}\subpageref{NW2MZpIA-4cHUFD-1}}\RA{}
  \LA{}Join route components~{\nwtagstyle{}\subpageref{NW2MZpIA-2lA6Dh-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{28}%
%
\item Finally, we'll submit our work.

\nwenddocs{}\nwbegincode{29}\sublabel{NW2MZpIA-3sZXk2-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-7}}}\moddef{Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwprevnextdefs{NW2MZpIA-3sZXk2-6}{\relax}\nwenddeflinemarkup
  \LA{}Submit~{\nwtagstyle{}\subpageref{NW2MZpIA-2gYtpS-1}}\RA{}
\}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{30}\nwdocspar
\end{enumerate}

Now here are the details.

\subsubsection{Get Remaining Schedule}

We'll ask {\Tt{}Communicator\nwendquote} for {\Tt{}min\nwendquote}'s remaining schedule. Here, {\Tt{}min\nwendquote} is
actually a map entry of {\Tt{}candidates\nwendquote}, so we'll use {\Tt{}getKey\nwendquote}(0) to extract
the candidate's identifier. We'll store the remaining schedule into
variable {\Tt{}brem\nwendquote}.

\nwenddocs{}\nwbegincode{31}\sublabel{NW2MZpIA-471Pa7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-471Pa7-1}}}\moddef{Get remaining schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-471Pa7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-2}}\nwenddeflinemarkup
final int sid = min.getKey();
final int[] brem = this.communicator.queryServerScheduleRemaining(sid, now);
\LA{}Debug: get remaining schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-2RxwyC-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-2}}\nwendcode{}\nwbegindocs{32}\nwdocspar

\subsubsection{Get Number of Events}

The returned schedule is a flattened 4-tuple array. The $i$th element is an
event's time; the $(i+1)$th element is the event's location vertex; the
$(i+2)$th element is the event's server label or 0 if it's not a server event;
and the $(i+3)$th element is the event's request label or 0 if it's not a
request event. The total number of events is the length of the schedule divided
by four. The number of events that will be in the new schedule is this number
plus two, one for the new pick-up and one for the new drop-off. Variable
{\Tt{}p\nwendquote} will store the number of events in the new schedule.

\nwenddocs{}\nwbegincode{33}\sublabel{NW2MZpIA-3D9vfA-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3D9vfA-1}}}\moddef{Get number of events~{\nwtagstyle{}\subpageref{NW2MZpIA-3D9vfA-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-2}}\nwenddeflinemarkup
final int m = brem.length/4;
final int p = m + 2;
\LA{}Debug: get number of events~{\nwtagstyle{}\subpageref{NW2MZpIA-1TMdCp-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-2}}\nwendcode{}\nwbegindocs{34}\nwdocspar

\subsubsection{Initialize New Schedule}

We'll initialize the new schedule {\Tt{}bnew\nwendquote} and also initialize its individual
components. The new-schedule parameter to {\Tt{}updateServerService\nwendquote}(5) expects
the new schedule to be a flattened 3-tuple array. The $i$th element is a time,
the $(i+1)$th element is a vertex, and the $(i+2)th$ element is a server or
request label. We'll create arrays to store each of these three components.
Later, we'll join the arrays into {\Tt{}bnew\nwendquote}. Recall that {\Tt{}p\nwendquote} is the number
of events in the new schedule.

\nwenddocs{}\nwbegincode{35}\sublabel{NW2MZpIA-3B4gix-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3B4gix-1}}}\moddef{Initialize new schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-3B4gix-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-2}}\nwenddeflinemarkup
final int[] bnew = new int[3*p];
final int[] bnew_t = new int[p];
final int[] bnew_v = new int[p];
final int[] bnew_l = new int[p];
\LA{}Debug: initialize new schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-GmK8M-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-2}}\nwendcode{}\nwbegindocs{36}\nwdocspar

\subsubsection{Prepend Request Vertices}

As we're using the prepend-to-front scheduling strategy, we can add the request
pick-up and drop-off location vertices to {\Tt{}bnew{\_}v\nwendquote} right off the bat. The
request is passed as argument {\Tt{}r\nwendquote} to {\Tt{}handleRequest\nwendquote}(1) as an array. The
4th and 5th elements of the {\Tt{}r\nwendquote} array are the request pick-up and drop-off
location vertices, respectively.

\nwenddocs{}\nwbegincode{37}\sublabel{NW2MZpIA-1cghJy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1cghJy-1}}}\moddef{Prepend request vertices~{\nwtagstyle{}\subpageref{NW2MZpIA-1cghJy-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-3}}\nwenddeflinemarkup
bnew_v[0] = r[4];
bnew_v[1] = r[5];
\LA{}Debug: prepend request vertices~{\nwtagstyle{}\subpageref{NW2MZpIA-2XKZtm-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-3}}\nwendcode{}\nwbegindocs{38}\nwdocspar

\subsubsection{Set Initial Labels}

We can also label them with the request identifier. The 0th element of the
{\Tt{}r\nwendquote} array is the identifier.

\nwenddocs{}\nwbegincode{39}\sublabel{NW2MZpIA-1geA7a-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1geA7a-1}}}\moddef{Set initial labels~{\nwtagstyle{}\subpageref{NW2MZpIA-1geA7a-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-3}}\nwenddeflinemarkup
bnew_l[0] = r[0];
bnew_l[1] = r[0];
\LA{}Debug: set initial labels~{\nwtagstyle{}\subpageref{NW2MZpIA-1sURxT-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-3}}\nwendcode{}\nwbegindocs{40}\nwdocspar

\subsubsection{Set Remaining Vertices and Labels}

Now we'll loop over and add vertices and labels from {\Tt{}brem\nwendquote} events into
{\Tt{}bnew{\_}v\nwendquote} and {\Tt{}bnew{\_}l\nwendquote}. We can't add time components yet because we
don't know the new event times

\nwenddocs{}\nwbegincode{41}\sublabel{NW2MZpIA-4F29O2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-4F29O2-1}}}\moddef{Set remaining vertices and labels~{\nwtagstyle{}\subpageref{NW2MZpIA-4F29O2-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-3}}\nwenddeflinemarkup
for (int i = 0; i < m; i++) \{
  final int bv = brem[(i + 1)];
  final int ls = brem[(i + 2)];
  final int lr = brem[(i + 3)];
  bnew_v[(i + 2)] = bv;
  bnew_l[(i + 2)] = (ls == 0 ? lr : ls);
  \LA{}Debug: set schedule vertex and label~{\nwtagstyle{}\subpageref{NW2MZpIA-1lkGjK-1}}\RA{}
\}
\nwused{\\{NW2MZpIA-3sZXk2-3}}\nwendcode{}\nwbegindocs{42}\nwdocspar

\subsubsection{Initialize Legs Container}

We'll compute each leg of the route through the new schedule. We'll store
each leg into the {\Tt{}legs\nwendquote} multi-array.

\nwenddocs{}\nwbegincode{43}\sublabel{NW2MZpIA-2qHHby-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2qHHby-1}}}\moddef{Initialize legs container~{\nwtagstyle{}\subpageref{NW2MZpIA-2qHHby-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-4}}\nwenddeflinemarkup
final int[][] legs = new int[p][];
int[] leg = null;
\LA{}Debug: initialize legs container~{\nwtagstyle{}\subpageref{NW2MZpIA-3R3yVH-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-4}}\nwendcode{}\nwbegindocs{44}\nwdocspar

\subsubsection{Set First Leg}

The first leg goes from {\Tt{}min\nwendquote}'s last-known location to the request pick-up
location. The {\Tt{}tools\nwendquote} object can be used to compute the shortest-path route
that makes up the leg.

The {\Tt{}computeRoute\nwendquote}(3) methods takes the route start location, route end
location, and departure time from start as its three arguments. For the
departure time, we'll use the current time. That way, the arrival time at
{\Tt{}r[4]\nwendquote} is guaranteed to be sometime in the future.  If we used {\Tt{}min\nwendquote}'s last
update time, this arrival time could have already passed if the distance from
{\Tt{}min\nwendquote} to {\Tt{}r[4]\nwendquote} is very short!

When we go to submit the new route, Jargo searches for the first waypoint of
the new route in the vehicle's existing route in order to know where to start
splicing in the new route. The location of this waypoint in the existing route
is called the ``branch point''. As we've used {\Tt{}now\nwendquote} as the departure time of
the first leg, the first waypoint will differ from {\Tt{}min\nwendquote}'s last-known
location! We have to manually reset the time of the first waypoint to be the
time of the last-known location so that Jargo can find the branch point. Recall
that the last-known location is stored in the {\Tt{}locations\nwendquote} map, and that the
time component is the 0th element of the map value.

Once we're done, we'll store the leg in the {\Tt{}legs\nwendquote} multi-array.

\nwenddocs{}\nwbegincode{45}\sublabel{NW2MZpIA-K9R8L-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-K9R8L-1}}}\moddef{Set first leg~{\nwtagstyle{}\subpageref{NW2MZpIA-K9R8L-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-4}}\nwenddeflinemarkup
leg = this.tools.computeRoute(locations.get(sid)[1], r[4], now);
leg[0] = locations.get(sid)[0];
legs[0] = leg;
\LA{}Debug: set first leg~{\nwtagstyle{}\subpageref{NW2MZpIA-1F8aiy-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-4}}\nwendcode{}\nwbegindocs{46}\nwdocspar

\subsubsection{Initialize Route Length and Time}

We'll keep a running sum {\Tt{}n\nwendquote} of the leg lengths so that we can initialize the
new route to the correct size. We'll also accumulate the arrival times {\Tt{}t\nwendquote} at
the end of each leg so that we can set the correct departure times for
subsequent legs in calls to {\Tt{}computeRoute\nwendquote}(3).

\nwenddocs{}\nwbegincode{47}\sublabel{NW2MZpIA-23lui7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-23lui7-1}}}\moddef{Initialize route length and time~{\nwtagstyle{}\subpageref{NW2MZpIA-23lui7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-4}}\nwenddeflinemarkup
int n = leg.length;
int t = leg[n - 2];
\LA{}Debug: set route length and time~{\nwtagstyle{}\subpageref{NW2MZpIA-3WOc2v-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-4}}\nwendcode{}\nwbegindocs{48}\nwdocspar

\subsubsection{Set Remaining Legs}

Now we'll iterate over the remaining vertices in the new schedule and compute
the legs as we go. When we update {\Tt{}n\nwendquote}, we subtract 2 from it because we don't
want to double count the leg endpoints. The endpoint of one leg is the starting
point of the next leg.

\nwenddocs{}\nwbegincode{49}\sublabel{NW2MZpIA-h4XZK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-h4XZK-1}}}\moddef{Set remaining legs~{\nwtagstyle{}\subpageref{NW2MZpIA-h4XZK-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-5}}\nwenddeflinemarkup
for (int i = 1; i < p; i++) \{
  final int u = bnew_v[(i - 1)];
  final int v = bnew_v[(i - 0)];
  leg = this.tools.computeRoute(u, v, t);
  legs[i] = leg;
  \LA{}Debug: set remaining legs~{\nwtagstyle{}\subpageref{NW2MZpIA-Zbf0J-1}}\RA{}

  n += (leg.length - 2);
  t = leg[leg.length - 2];
  \LA{}Debug: set route length and time~{\nwtagstyle{}\subpageref{NW2MZpIA-3WOc2v-1}}\RA{}
\}
\nwused{\\{NW2MZpIA-3sZXk2-5}}\nwendcode{}\nwbegindocs{50}\nwdocspar

\subsubsection{Set Schedule Times}

After all the legs have been computed, we can go to update the schedule event
times. We'll put in all the departure times for all the events. Remember that
each leg is the route between two events, so we'll get just the first element
of each leg.

\nwenddocs{}\nwbegincode{51}\sublabel{NW2MZpIA-2bjij9-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2bjij9-1}}}\moddef{Set schedule times~{\nwtagstyle{}\subpageref{NW2MZpIA-2bjij9-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-5}}\nwenddeflinemarkup
for (int i = 1; i < legs.length; i++) \{
  bnew_t[(i - 1)] = legs[i][0];
  \LA{}Debug: set schedule time~{\nwtagstyle{}\subpageref{NW2MZpIA-1EJRY4-1}}\RA{}
\}
\nwused{\\{NW2MZpIA-3sZXk2-5}}\nwendcode{}\nwbegindocs{52}\nwdocspar

\subsubsection{Set Vehicle End Time}

Now we'll get the arrival time of the last leg, in other words the time of
the last event of the last leg. This event corresponds to the server's
own arrival.

\nwenddocs{}\nwbegincode{53}\sublabel{NW2MZpIA-18NavW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-18NavW-1}}}\moddef{Set vehicle end time~{\nwtagstyle{}\subpageref{NW2MZpIA-18NavW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-5}}\nwenddeflinemarkup
bnew_t[(p - 1)] = t;
\LA{}Debug: set vehicle end time~{\nwtagstyle{}\subpageref{NW2MZpIA-3ZHBo5-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-5}}\nwendcode{}\nwbegindocs{54}\nwdocspar

\subsubsection{Join Schedule Components}

We'll simply iterate through the schedule component arrays to join them
into {\Tt{}bnew\nwendquote}.

\nwenddocs{}\nwbegincode{55}\sublabel{NW2MZpIA-4cHUFD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-4cHUFD-1}}}\moddef{Join schedule components~{\nwtagstyle{}\subpageref{NW2MZpIA-4cHUFD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-6}}\nwenddeflinemarkup
for (int i = 0; i < p; i++) \{
  bnew[(3*i + 0)] = bnew_t[i];
  bnew[(3*i + 1)] = bnew_v[i];
  bnew[(3*i + 2)] = bnew_l[i];
  \LA{}Debug: join schedule components~{\nwtagstyle{}\subpageref{NW2MZpIA-qM9ER-1}}\RA{}
\}
\nwused{\\{NW2MZpIA-3sZXk2-6}}\nwendcode{}\nwbegindocs{56}\nwdocspar

\subsubsection{Join Route Components}

Simlarly, we'll join all the legs together to form the new route
{\Tt{}wnew\nwendquote}. We'll use {\Tt{}n\nwendquote} here to size the new route. To avoid doubling
up the events, we'll skip the last event of each leg, unless it is the last
leg.

\nwenddocs{}\nwbegincode{57}\sublabel{NW2MZpIA-2lA6Dh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2lA6Dh-1}}}\moddef{Join route components~{\nwtagstyle{}\subpageref{NW2MZpIA-2lA6Dh-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-6}}\nwenddeflinemarkup
final int[] wnew = new int[n];
int k = 0;
for (int i = 0; i < legs.length; i++) \{
  int rend = (legs[i].length - (i == (legs.length - 1) ? 0 : 2));
  for (int j = 0; j < rend; j++) \{
    wnew[k] = legs[i][j];
    \LA{}Debug: join route components~{\nwtagstyle{}\subpageref{NW2MZpIA-J6KjD-1}}\RA{}
    k++;
  \}
\}
\nwused{\\{NW2MZpIA-3sZXk2-6}}\nwendcode{}\nwbegindocs{58}\nwdocspar

\subsubsection{Submit}

Finally, we're ready to submit. The first argument to {\Tt{}updateServerService\nwendquote}(5)
is {\Tt{}min\nwendquote}'s identifier; the next two are the new route and schedule. Following
that is an array containing identifiers of new requests to be serviced.
The last argument is an array containing identifiers of existing requests
that should be removed from the remaining schedule.

\nwenddocs{}\nwbegincode{59}\sublabel{NW2MZpIA-2gYtpS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2gYtpS-1}}}\moddef{Submit~{\nwtagstyle{}\subpageref{NW2MZpIA-2gYtpS-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-7}}\nwenddeflinemarkup
this.communicator.updateServerService(sid, wnew, bnew,
    new int[] \{ r[0] \}, new int[] \{ \});
\LA{}Debug: submit~{\nwtagstyle{}\subpageref{NW2MZpIA-2e4BPs-1}}\RA{}
\nwused{\\{NW2MZpIA-3sZXk2-7}}\nwendcode{}\nwbegindocs{60}\nwdocspar


\section{Methods}
\label{client-nearest: methods}

\subsection{\texttt{handleRequest}(1)}

Now we can write the body of {\Tt{}handleRequest\nwendquote}(1).  The entire method is
wrapped in try/catch because some method calls can throw exceptions. If an
exception is caught, it gets bubbled up to Jargo via {\Tt{}ClientException\nwendquote}.

\nwenddocs{}\nwbegincode{61}\sublabel{NW2MZpIA-16KpI3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-16KpI3-1}}}\moddef{NearestNeighbor: handleRequest(1)~{\nwtagstyle{}\subpageref{NW2MZpIA-16KpI3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-3yym9S-1}}\nwenddeflinemarkup
void handleRequest(int[] r) throws ClientException, ClientFatalException \{
  \LA{}Debug: handle request~{\nwtagstyle{}\subpageref{NW2MZpIA-33A3UY-1}}\RA{}
  try \{
    \LA{}Get current time~{\nwtagstyle{}\subpageref{NW2MZpIA-2qkQZx-1}}\RA{}
    \LA{}Initialize candidates container~{\nwtagstyle{}\subpageref{NW2MZpIA-3doegf-1}}\RA{}
    \LA{}Apply delta and range filters~{\nwtagstyle{}\subpageref{NW2MZpIA-1hztkR-1}}\RA{}
    \LA{}Find minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-2TDXjw-1}}\RA{}
    \LA{}Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}\RA{}
  \} catch (Exception e) \{
    throw new ClientException(e);
  \}
\}
\nwused{\\{NW3eY1Ju-3yym9S-1}}\nwendcode{}\nwbegindocs{62}\nwdocspar

\subsection{\texttt{handleServerLocation}(1)}

Jargo automatically calls {\Tt{}handleServerLocation\nwendquote}(1) for each server with
a position update. We will take the update and store it into our {\Tt{}locations\nwendquote}
array.

\nwenddocs{}\nwbegincode{63}\sublabel{NW2MZpIA-fLFsG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-fLFsG-1}}}\moddef{NearestNeighbor: handleServerLocation(1)~{\nwtagstyle{}\subpageref{NW2MZpIA-fLFsG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-3yym9S-1}}\nwenddeflinemarkup
void handleServerLocation(int[] s) \{
  this.locations.put(s[0], new int[] \{ s[1], s[2] \});
  \LA{}Debug: put server location~{\nwtagstyle{}\subpageref{NW2MZpIA-hcsfv-1}}\RA{}
\}
\nwused{\\{NW3eY1Ju-3yym9S-1}}\nwendcode{}\nwbegindocs{64}\nwdocspar

\section{Debug}

Debugging can be turned on by passing the {\Tt{}-Djargors.client.debug=true\nwendquote}
runtime flag to the JVM when a Jargo simulation is started. If this flag is
true, the the {\Tt{}DEBUG\nwendquote} member variable is true. The following sections print
some helpful messages if debugging is turned on.

\subsection{Debug: Handle Request}

\nwenddocs{}\nwbegincode{65}\sublabel{NW2MZpIA-33A3UY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-33A3UY-1}}}\moddef{Debug: handle request~{\nwtagstyle{}\subpageref{NW2MZpIA-33A3UY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got request=\{ id=%d, q=%d, e=%d, l=%d, o=%d, d=%d, b=%d \}\\n",
      r[0], r[1], r[2], r[3], r[4], r[5], r[6]);
\}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{66}\nwdocspar

\subsection{Debug: Get Current Time}

\nwenddocs{}\nwbegincode{67}\sublabel{NW2MZpIA-xqgdv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-xqgdv-1}}}\moddef{Debug: get current time~{\nwtagstyle{}\subpageref{NW2MZpIA-xqgdv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-2qkQZx-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got now=%d\\n", now);
\}
\nwused{\\{NW2MZpIA-2qkQZx-1}}\nwendcode{}\nwbegindocs{68}\nwdocspar

\subsection{Debug: Initialize Candidates Container}

\nwenddocs{}\nwbegincode{69}\sublabel{NW2MZpIA-3LGRX7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3LGRX7-1}}}\moddef{Debug: initialize candidates container~{\nwtagstyle{}\subpageref{NW2MZpIA-3LGRX7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3doegf-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("init candidates[]=\{ \}\\n");
\}
\nwused{\\{NW2MZpIA-3doegf-1}}\nwendcode{}\nwbegindocs{70}\nwdocspar

\subsection{Debug: Delta Filter}

\nwenddocs{}\nwbegincode{71}\sublabel{NW2MZpIA-2I20iB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2I20iB-1}}}\moddef{Debug: delta filter~{\nwtagstyle{}\subpageref{NW2MZpIA-2I20iB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1hztkR-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got %d in_delta=%s\\n", sid, (in_delta ? "true" : "false"));
\}
\nwused{\\{NW2MZpIA-1hztkR-1}}\nwendcode{}\nwbegindocs{72}\nwdocspar

\subsection{Debug: Range Filter}

\nwenddocs{}\nwbegincode{73}\sublabel{NW2MZpIA-4aukgD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-4aukgD-1}}}\moddef{Debug: range filter~{\nwtagstyle{}\subpageref{NW2MZpIA-4aukgD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1hztkR-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got %d in_range=%s\\n", sid, (in_range ? "true" : "false"));
\}
\nwused{\\{NW2MZpIA-1hztkR-1}}\nwendcode{}\nwbegindocs{74}\nwdocspar

\subsection{Debug: Put Candidate}

\nwenddocs{}\nwbegincode{75}\sublabel{NW2MZpIA-1Lo26M-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1Lo26M-1}}}\moddef{Debug: put candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-1Lo26M-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1hztkR-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("put candidates[], key=%d, val=%d\\n", sid, range);
\}
\nwused{\\{NW2MZpIA-1hztkR-1}}\nwendcode{}\nwbegindocs{76}\nwdocspar

\subsection{Debug: Find Minimum-Range Candidate}

\nwenddocs{}\nwbegincode{77}\sublabel{NW2MZpIA-3aXcFM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3aXcFM-1}}}\moddef{Debug: find minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3aXcFM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-2TDXjw-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set min=\{ %d, %d \}\\n", min.getKey(), min.getValue());
\}
\nwused{\\{NW2MZpIA-2TDXjw-1}}\nwendcode{}\nwbegindocs{78}\nwdocspar

\subsection{Debug: Get Remaining Schedule}

\nwenddocs{}\nwbegincode{79}\sublabel{NW2MZpIA-2RxwyC-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2RxwyC-1}}}\moddef{Debug: get remaining schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-2RxwyC-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-471Pa7-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got brem: \\n");
  for (int i = 0; i < (brem.length - 3); i+=4) \{
    System.out.printf("  \{ t=%d, v=%d, ls=%d, lr=%d \}\\n",
        brem[i], brem[i+1], brem[i+2], brem[i+3]);
  \}
\}
\nwused{\\{NW2MZpIA-471Pa7-1}}\nwendcode{}\nwbegindocs{80}\nwdocspar

\subsection{Debug: Get Number of Events}

\nwenddocs{}\nwbegincode{81}\sublabel{NW2MZpIA-1TMdCp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1TMdCp-1}}}\moddef{Debug: get number of events~{\nwtagstyle{}\subpageref{NW2MZpIA-1TMdCp-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3D9vfA-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got m=%d\\n", m);
  System.out.printf("got p=%d\\n", p);
\}
\nwused{\\{NW2MZpIA-3D9vfA-1}}\nwendcode{}\nwbegindocs{82}\nwdocspar

\subsection{Debug: Initialize New Schedule}

\nwenddocs{}\nwbegincode{83}\sublabel{NW2MZpIA-GmK8M-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-GmK8M-1}}}\moddef{Debug: initialize new schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-GmK8M-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3B4gix-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("init bnew=\{ \}\\n");
  System.out.printf("init bnew_t=\{ \}\\n");
  System.out.printf("init bnew_v=\{ \}\\n");
  System.out.printf("init bnew_l=\{ \}\\n");
\}
\nwused{\\{NW2MZpIA-3B4gix-1}}\nwendcode{}\nwbegindocs{84}\nwdocspar

\subsection{Debug: Prepend Request Vertices}

\nwenddocs{}\nwbegincode{85}\sublabel{NW2MZpIA-2XKZtm-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2XKZtm-1}}}\moddef{Debug: prepend request vertices~{\nwtagstyle{}\subpageref{NW2MZpIA-2XKZtm-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1cghJy-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_v[0]=%d\\n", bnew_v[0]);
  System.out.printf("set bnew_v[1]=%d\\n", bnew_v[1]);
\}
\nwused{\\{NW2MZpIA-1cghJy-1}}\nwendcode{}\nwbegindocs{86}\nwdocspar

\subsection{Debug: Set Initial Labels}

\nwenddocs{}\nwbegincode{87}\sublabel{NW2MZpIA-1sURxT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1sURxT-1}}}\moddef{Debug: set initial labels~{\nwtagstyle{}\subpageref{NW2MZpIA-1sURxT-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1geA7a-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_l[0]=%d\\n", bnew_l[0]);
  System.out.printf("set bnew_l[1]=%d\\n", bnew_l[1]);
\}
\nwused{\\{NW2MZpIA-1geA7a-1}}\nwendcode{}\nwbegindocs{88}\nwdocspar

\subsection{Debug: Set Schedule Vertex and Label}

\nwenddocs{}\nwbegincode{89}\sublabel{NW2MZpIA-1lkGjK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1lkGjK-1}}}\moddef{Debug: set schedule vertex and label~{\nwtagstyle{}\subpageref{NW2MZpIA-1lkGjK-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-4F29O2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_v[%d]=%d\\n", (i + 2), bnew_v[(i + 2)]);
  System.out.printf("set bnew_l[%d]=%d\\n", (i + 2), bnew_l[(i + 2)]);
\}
\nwused{\\{NW2MZpIA-4F29O2-1}}\nwendcode{}\nwbegindocs{90}\nwdocspar

\subsection{Debug: Set Schedule Time}

\nwenddocs{}\nwbegincode{91}\sublabel{NW2MZpIA-1EJRY4-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1EJRY4-1}}}\moddef{Debug: set schedule time~{\nwtagstyle{}\subpageref{NW2MZpIA-1EJRY4-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-2bjij9-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_t[%d]=%d\\n", (i - 1), bnew_t[(i - 1)]);
\}
\nwused{\\{NW2MZpIA-2bjij9-1}}\nwendcode{}\nwbegindocs{92}\nwdocspar

\subsection{Debug: Set Vehicle End Time}

\nwenddocs{}\nwbegincode{93}\sublabel{NW2MZpIA-3ZHBo5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3ZHBo5-1}}}\moddef{Debug: set vehicle end time~{\nwtagstyle{}\subpageref{NW2MZpIA-3ZHBo5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-18NavW-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_t[%d]=%d\\n", (p - 1), bnew_t[(p - 1)]);
\}
\nwused{\\{NW2MZpIA-18NavW-1}}\nwendcode{}\nwbegindocs{94}\nwdocspar

\subsection{Debug: Join Schedule Components}

\nwenddocs{}\nwbegincode{95}\sublabel{NW2MZpIA-qM9ER-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-qM9ER-1}}}\moddef{Debug: join schedule components~{\nwtagstyle{}\subpageref{NW2MZpIA-qM9ER-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-4cHUFD-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew[%d..%d]=\{ t=%d, v=%d, l=%d \}\\n",
      (3*i), (3*i + 2), bnew[(3*i + 0)], bnew[(3*i + 1)], bnew[(3*i + 2)]);
\}
\nwused{\\{NW2MZpIA-4cHUFD-1}}\nwendcode{}\nwbegindocs{96}\nwdocspar

\subsection{Debug: Initialize Legs Container}

\nwenddocs{}\nwbegincode{97}\sublabel{NW2MZpIA-3R3yVH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3R3yVH-1}}}\moddef{Debug: initialize legs container~{\nwtagstyle{}\subpageref{NW2MZpIA-3R3yVH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-2qHHby-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("init legs=\{ \}\\n");
\}
\nwused{\\{NW2MZpIA-2qHHby-1}}\nwendcode{}\nwbegindocs{98}\nwdocspar

\subsection{Debug: Set First Leg}

\nwenddocs{}\nwbegincode{99}\sublabel{NW2MZpIA-1F8aiy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1F8aiy-1}}}\moddef{Debug: set first leg~{\nwtagstyle{}\subpageref{NW2MZpIA-1F8aiy-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-K9R8L-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set legs[0]=\{ %d, %d, ..., %d, %d  \}\\n",
      legs[0][0], legs[0][1], legs[0][legs[0].length - 2], legs[0][legs[0].length - 1]);
\}
\nwused{\\{NW2MZpIA-K9R8L-1}}\nwendcode{}\nwbegindocs{100}\nwdocspar

\subsection{Debug: Set Remaining Legs}

\nwenddocs{}\nwbegincode{101}\sublabel{NW2MZpIA-Zbf0J-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-Zbf0J-1}}}\moddef{Debug: set remaining legs~{\nwtagstyle{}\subpageref{NW2MZpIA-Zbf0J-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-h4XZK-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set legs[%d]=\{ %d, %d, ..., %d, %d  \}\\n", i,
      legs[i][0], legs[i][1], legs[i][legs[i].length - 2], legs[i][legs[i].length - 1]);
\}
\nwused{\\{NW2MZpIA-h4XZK-1}}\nwendcode{}\nwbegindocs{102}\nwdocspar

\subsection{Debug: Set Route Length and Time}

\nwenddocs{}\nwbegincode{103}\sublabel{NW2MZpIA-3WOc2v-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3WOc2v-1}}}\moddef{Debug: set route length and time~{\nwtagstyle{}\subpageref{NW2MZpIA-3WOc2v-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-23lui7-1}\\{NW2MZpIA-h4XZK-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set n=%d\\n", n);
  System.out.printf("set t=%d\\n", t);
\}
\nwused{\\{NW2MZpIA-23lui7-1}\\{NW2MZpIA-h4XZK-1}}\nwendcode{}\nwbegindocs{104}\nwdocspar

\subsection{Debug: Join Route Components}

\nwenddocs{}\nwbegincode{105}\sublabel{NW2MZpIA-J6KjD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-J6KjD-1}}}\moddef{Debug: join route components~{\nwtagstyle{}\subpageref{NW2MZpIA-J6KjD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-2lA6Dh-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set wnew[%d]=%d\\n", k, wnew[k]);
\}
\nwused{\\{NW2MZpIA-2lA6Dh-1}}\nwendcode{}\nwbegindocs{106}\nwdocspar

\subsection{Debug: Submit}

\nwenddocs{}\nwbegincode{107}\sublabel{NW2MZpIA-2e4BPs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2e4BPs-1}}}\moddef{Debug: submit~{\nwtagstyle{}\subpageref{NW2MZpIA-2e4BPs-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-2gYtpS-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("submit:\\n");
  System.out.printf("  server=%d\\n", sid);
  System.out.printf("  wnew=\{ %d, %d, ..., %d, %d \}\\n",
      wnew[0], wnew[1], wnew[wnew.length - 2], wnew[wnew.length - 1]);
  System.out.printf("  bnew=\{ %d, %d, %d, ..., %d, %d, %d \}\\n",
      bnew[0], bnew[1], bnew[2],
      bnew[bnew.length - 3], bnew[bnew.length - 2], bnew[bnew.length - 1]);
  System.out.printf("  radd=\{ %d \}\\n", r[0]);
  System.out.printf("  rsub=\{ \}\\n");
\}
\nwused{\\{NW2MZpIA-2gYtpS-1}}\nwendcode{}\nwbegindocs{108}\nwdocspar

\subsection{Debug: Put Server Location}

\nwenddocs{}\nwbegincode{109}\sublabel{NW2MZpIA-hcsfv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-hcsfv-1}}}\moddef{Debug: put server location~{\nwtagstyle{}\subpageref{NW2MZpIA-hcsfv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-fLFsG-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("put locations[%d]=[ %d, %d ]\\n", s[0], s[1], s[2]);
\}
\nwused{\\{NW2MZpIA-fLFsG-1}}\nwendcode{}\nwbegindocs{110}\nwdocspar

\section{Reference Code}

Here is the full NearestNeighbor.java code, with debug sections removed.

{
\small
\begin{verbatim}
package com.github.jargors.client;
import com.github.jargors.sim.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
public class NearestNeighbor extends Client {
  final int MAX_DELTA = 300;  // seconds from last vehicle location update
  final int MAX_RANGE = 600;  // meters from last vehicle position
  final ConcurrentHashMap<Integer, int[]> locations =
    new ConcurrentHashMap<Integer, int[]>();
  protected void handleRequest(int[] r) throws ClientException, ClientFatalException {
    try {
      final int now = this.communicator.retrieveClock();
      final Map<Integer, Integer> candidates = new HashMap<Integer, Integer>();
      for (final Integer sid : locations.keySet()) {
        final int t = locations.get(sid)[0];
        final int v = locations.get(sid)[1];

        final boolean in_delta = (t >= now - MAX_DELTA);
        if (!in_delta)
          continue;

        final int range = this.tools.computeHaversine(v, r[4]);
        final boolean in_range = (range <= MAX_RANGE);
        if (!in_range)
          continue;

        candidates.put(sid, range);
      }
      Entry<Integer, Integer> min = null;
      for (final Entry<Integer, Integer> entry : candidates.entrySet()) {
        if (min == null || min.getValue() > entry.getValue()) {
          min = entry;
        }
      }
      if (min != null) {
        final int sid = min.getKey();
        final int[] brem = this.communicator.queryServerScheduleRemaining(sid, now);
        final int m = brem.length/4;
        final int p = m + 2;
        final int[] bnew = new int[3*p];
        final int[] bnew_t = new int[p];
        final int[] bnew_v = new int[p];
        final int[] bnew_l = new int[p];
        bnew_v[0] = r[4];
        bnew_v[1] = r[5];
        bnew_l[0] = r[0];
        bnew_l[1] = r[0];
        for (int i = 0; i < m; i++) {
          final int bv = brem[(i + 1)];
          final int ls = brem[(i + 2)];
          final int lr = brem[(i + 3)];
          bnew_v[(i + 2)] = bv;
          bnew_l[(i + 2)] = (ls == 0 ? lr : ls);
        }
        final int[][] legs = new int[p][];
        int[] leg = null;
        leg = this.tools.computeRoute(locations.get(sid)[1], r[4], now);
        leg[0] = locations.get(sid)[0];
        legs[0] = leg;
        int n = leg.length;
        int t = leg[n - 2];
        for (int i = 1; i < p; i++) {
          final int u = bnew_v[(i - 1)];
          final int v = bnew_v[(i - 0)];
          leg = this.tools.computeRoute(u, v, t);
          legs[i] = leg;

          n += (leg.length - 2);
          t = leg[leg.length - 2];
        }
        for (int i = 1; i < legs.length; i++) {
          bnew_t[(i - 1)] = legs[i][0];
        }
        bnew_t[(p - 1)] = t;
        for (int i = 0; i < p; i++) {
          bnew[(3*i + 0)] = bnew_t[i];
          bnew[(3*i + 1)] = bnew_v[i];
          bnew[(3*i + 2)] = bnew_l[i];
        }
        final int[] wnew = new int[n];
        int k = 0;
        for (int i = 0; i < legs.length; i++) {
          int rend = (legs[i].length - (i == (legs.length - 1) ? 0 : 2));
          for (int j = 0; j < rend; j++) {
            wnew[k] = legs[i][j];
            k++;
          }
        }
        this.communicator.updateServerService(sid, wnew, bnew,
            new int[] { r[0] }, new int[] { });
      }
    } catch (Exception e) {
      throw new ClientException(e);
    }
  }
  protected void handleServerLocation(int[] s) {
    this.locations.put(s[0], new int[] { s[1], s[2] });
  }
}
\end{verbatim}
}

\nwenddocs{}\nwfilename{src/client-greedy.nw}\nwbegindocs{0}\chapter{Client: GreedyInsertion}
\label{client-greedy}

\nwenddocs{}\nwbegincode{1}\sublabel{NWkwPRG-1Tuf6f-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-1Tuf6f-1}}}\moddef{GreedyInsertion.java~{\nwtagstyle{}\subpageref{NWkwPRG-1Tuf6f-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}GreedyInsertion.java preamble~{\nwtagstyle{}\subpageref{NWkwPRG-1neuor-1}}\RA{}
public class GreedyInsertion extends Client \{
  \LA{}\code{}GreedyInsertion\edoc{} member variables~{\nwtagstyle{}\subpageref{NWkwPRG-jESV1-1}}\RA{}
  \LA{}\code{}GreedyInsertion\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-1}}\RA{}
\}
\nwnotused{GreedyInsertion.java}\nwendcode{}\nwbegindocs{2}\nwdocspar

\section{Preamble}
\nwenddocs{}\nwbegincode{3}\sublabel{NWkwPRG-1neuor-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-1neuor-1}}}\moddef{GreedyInsertion.java preamble~{\nwtagstyle{}\subpageref{NWkwPRG-1neuor-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-1Tuf6f-1}}\nwenddeflinemarkup
package com.github.jargors.client;
import com.github.jargors.sim.*;
import java.sql.SQLException;
\nwused{\\{NWkwPRG-1Tuf6f-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

\section{Member Variables}
\nwenddocs{}\nwbegincode{5}\sublabel{NWkwPRG-jESV1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-jESV1-1}}}\moddef{\code{}GreedyInsertion\edoc{} member variables~{\nwtagstyle{}\subpageref{NWkwPRG-jESV1-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-1Tuf6f-1}}\nwenddeflinemarkup
final int PICKUP_THRESHOLD = 600;  // meters
final int MAX_SCHEDULE_LENGTH = 8;
int[] locations = new int[] \{ \};
int count_rejections = 0;
\nwused{\\{NWkwPRG-1Tuf6f-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

\section{Chunks}

\subsection{Initialize global vars}
\nwenddocs{}\nwbegincode{7}\sublabel{NWkwPRG-jOToH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-jOToH-1}}}\moddef{Initialize global vars~{\nwtagstyle{}\subpageref{NWkwPRG-jOToH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (DEBUG) \{
  tools.Print("Extract request \{ rid="+r[0]+", rq="+r[1]+", ro="+r[4]+", rd="+r[5]+" \}");
\}
int     opt_k       = -1;
int     opt_c       = Integer.MAX_VALUE;
int[]   opt_b       = new int[] \{ \};
int[][] opt_cache_t = new int[][] \{ \};
int[][] opt_cache_v = new int[][] \{ \};
if (DEBUG) \{
  tools.Print("Reset opt_k=-1, opt_c=Integer.MAX_VALUE, opt_b=\{\}, opt_cache_t=\{\}, opt_cache_v=\{\}");
\}
final int   T = communicator.retrieveClock();
final int[] L = locations.clone();
final int[] C = tools.filterByHaversine(r[4], L, PICKUP_THRESHOLD);
if (DEBUG) \{
  tools.Print("Initialize T="+T+"; C.length="+C.length);
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

\subsection{Initialize server vars}
\nwenddocs{}\nwbegincode{9}\sublabel{NWkwPRG-3y7kuU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-3y7kuU-1}}}\moddef{Initialize server vars~{\nwtagstyle{}\subpageref{NWkwPRG-3y7kuU-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
final int sid = L[(k_cand + 0)];
final int st  = L[(k_cand + 1)];
final int sv  = L[(k_cand + 2)];
if (DEBUG) \{
  tools.Print("Extract server \{ sid="+sid+", st="+st+", sv="+sv+" \}");
\}
int     s_k       = -1;
int     s_c       = Integer.MAX_VALUE;
int[]   s_b       = new int[] \{ \};
int[][] s_cache_t = new int[][] \{ \};
int[][] s_cache_v = new int[][] \{ \};
if (DEBUG) \{
  tools.Print("Reset s_k=-1, s_c=Integer.MAX_VALUE, s_b=\{\}, s_cache_t=\{\}, s_cache_v=\{\}");
\}
final int[] y = communicator.queryServerScheduleRemaining(sid, T);
final int   n = (y.length/4);
final int   z = communicator.queryServerDistanceRemaining(sid, T)[0];
if (DEBUG) \{
  tools.Print("Initialize y.length="+y.length+"; n="+n+"; z="+z);
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

\subsection{Case 1: server is idle or heading towards own destination}
\nwenddocs{}\nwbegincode{11}\sublabel{NWkwPRG-4dVkBS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-4dVkBS-1}}}\moddef{Case 1: server is idle or heading towards own destination~{\nwtagstyle{}\subpageref{NWkwPRG-4dVkBS-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (n == 1) \{
  if (DEBUG) \{
    tools.Print("Detected n=1");
  \}
  // Beware! Important note! Jargo cannot handle the case where a customer
  // appears at the same vertex that a server is idling at! The reason is
  // because the route would be recorded as
  //   (t1, v)
  //   (t2, v)
  // due to preserving history, (t1, v) cannot be changed; the customer appears
  // at t2; a new waypoint (t2, v) must be recorded in the route in order to be
  // referenceable by Table PD, causing the self-referencing edge (v, v)! This
  // edge violates a Table E constraint.
  //
  // As a workaround, we skip the server if it is idling and happens
  // to be at the request origin.
  if (sv == r[4]) \{
    continue;
  \}

  int[] b = new int[12];
  b[0] = st;
  b[1] = sv;
  b[2] = sid;
  b[4] = r[4];
  b[5] = r[0];
  b[7] = r[5];
  b[8] = r[0];
  b[10] = y[1];
  b[11] = sid;
  if (DEBUG) \{
    tools.Print("Set b[0]="+b[0]);
    tools.Print("Set b[1]="+b[1]);
    tools.Print("Set b[2]="+b[2]);
    tools.Print("Set b[4]="+b[4]);
    tools.Print("Set b[5]="+b[5]);
    tools.Print("Set b[7]="+b[7]);
    tools.Print("Set b[8]="+b[8]);
    tools.Print("Set b[10]="+b[10]);
    tools.Print("Set b[11]="+b[11]);
  \}
  int[][] cache_t = new int[3][];
  int[][] cache_v = new int[3][];
  int c = computeCost(b, cache_t, cache_v, s_c, z, r[2]);
  if (DEBUG) \{
    tools.Print("computeCost returned c="+c);
  \}
  if (c != -1) \{
    \LA{}Accept single solution~{\nwtagstyle{}\subpageref{NWkwPRG-47ILqi-1}}\RA{}
  \}
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

\subsection{Case 2: server is heading towards a customer}
\nwenddocs{}\nwbegincode{13}\sublabel{NWkwPRG-22IadP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-22IadP-1}}}\moddef{Case 2: server is heading towards a customer~{\nwtagstyle{}\subpageref{NWkwPRG-22IadP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (n > 1 && n < MAX_SCHEDULE_LENGTH) \{
  if (DEBUG) \{
    tools.Print("Detected n > 1");
  \}
  // Beware! Important note! Jargo cannot handle the case where a customer
  // appears at the same vertex that a server was last seen! In other words,
  // ro cannot equal sv! The reason is that during schedule update, we
  // delete from CQ starting from st onward before re-inserting the new schedule.
  // If there are existing labels on st in CQ, then we would be inserting a
  // second entry on st, causing a constraint violation. If we delete the
  // existing labels, we would have to first query for them and then re-add them.
  // This could be a future fix.
  //
  // As a workaround, we skip the server if it's last-seen vertex happens
  // to be at the request origin.
  if (sv == r[4]) \{
    continue;
  \}

  for (int i = 0; i < n; i++) \{
    for (int j = i; j < n; j++) \{
      boolean capacity_ok = true;
      if (DEBUG) \{
        tools.Print("Set i="+i+", j="+j+", capacity_ok=true");
      \}
      \LA{}Compute sequence~{\nwtagstyle{}\subpageref{NWkwPRG-3KjiZY-1}}\RA{}
      if (capacity_ok) \{
        int[][] cache_t = new int[(b.length/3 - 1)][];
        int[][] cache_v = new int[(b.length/3 - 1)][];
        int c = computeCost(b, cache_t, cache_v, s_c, z, 0);
        if (DEBUG) \{
          tools.Print("computeCost returned c="+c);
        \}
        if (c != -1) \{
          \LA{}Accept single solution~{\nwtagstyle{}\subpageref{NWkwPRG-47ILqi-1}}\RA{}
        \}
      \}
    \}
  \}
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

\subsection{Compute sequence}
\nwenddocs{}\nwbegincode{15}\sublabel{NWkwPRG-3KjiZY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-3KjiZY-1}}}\moddef{Compute sequence~{\nwtagstyle{}\subpageref{NWkwPRG-3KjiZY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-22IadP-1}}\nwenddeflinemarkup
int[] b = new int[3*(n + 3)];
for (int p = 0; p < (b.length/3); p++) \{
  if (DEBUG) \{
    tools.Print("Set p="+p);
  \}
  \LA{}Check capacity~{\nwtagstyle{}\subpageref{NWkwPRG-27P27q-1}}\RA{}
  if (p == (n + 2)) \{
    b[(3*p + 1)] = y[(4*(p - 3) + 1)];
    b[(3*p + 2)] = y[(4*(p - 3) + 2)];  // server label
  \} else if (p > (j + 2)) \{
    b[(3*p + 1)] = y[(4*(p - 3) + 1)];
    b[(3*p + 2)] = y[(4*(p - 3) + 3)];
  \} else if (p == (j + 2)) \{
    b[(3*p + 1)] = r[5];
    b[(3*p + 2)] = r[0];
  \} else if (p > (i + 1)) \{
    b[(3*p + 1)] = y[(4*(p - 2) + 1)];
    b[(3*p + 2)] = y[(4*(p - 2) + 3)];
  \} else if (p == (i + 1)) \{
    b[(3*p + 1)] = r[4];
    b[(3*p + 2)] = r[0];
  \} else if (p > 0) \{
    b[(3*p + 0)] = y[(4*(p - 1) + 0)];
    b[(3*p + 1)] = y[(4*(p - 1) + 1)];
    b[(3*p + 2)] = y[(4*(p - 1) + 3)];
    if (DEBUG) \{
      tools.Print("Set b["+(3*p + 0)+"]="+b[(3*p + 0)]);
    \}
  \} else \{
    b[(3*p + 0)] = st;
    b[(3*p + 1)] = sv;
    b[(3*p + 2)] = sid;
    if (DEBUG) \{
      tools.Print("Set b["+(3*p + 0)+"]="+b[(3*p + 0)]);
    \}
  \}
  if (DEBUG) \{
    tools.Print("Set b["+(3*p + 1)+"]="+b[(3*p + 1)]);
    tools.Print("Set b["+(3*p + 2)+"]="+b[(3*p + 2)]);
  \}
\}
\nwused{\\{NWkwPRG-22IadP-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

\subsection{Check capacity}
\nwenddocs{}\nwbegincode{17}\sublabel{NWkwPRG-27P27q-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-27P27q-1}}}\moddef{Check capacity~{\nwtagstyle{}\subpageref{NWkwPRG-27P27q-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-3KjiZY-1}}\nwenddeflinemarkup
if (DEBUG) \{
  tools.Print("Check capacity");
\}
if (p >= i && p <= j) \{
  if (DEBUG) \{
    tools.Print("Detected p >= "+i+" && p <= "+j+"; Check capacity");
  \}
  if (r[1] + communicator.queryServerLoadMax(sid, (p == 0 ? st : y[(4*(p - 1))]))[0] > 0) \{
    if (DEBUG) \{
      tools.Print("Detected capacity violation; Break");
    \}
    capacity_ok = false;
    break;
  \}
\}
\nwused{\\{NWkwPRG-3KjiZY-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

\subsection{Accept single solution}
\nwenddocs{}\nwbegincode{19}\sublabel{NWkwPRG-47ILqi-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-47ILqi-1}}}\moddef{Accept single solution~{\nwtagstyle{}\subpageref{NWkwPRG-47ILqi-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-4dVkBS-1}\\{NWkwPRG-22IadP-1}}\nwenddeflinemarkup
if ((c - z) < s_c) \{
  if (DEBUG) \{
    tools.Print("Detected ("+c+" - "+z+")="+(c - z)+" is less than "+s_c);
  \}
  s_k = k_cand;
  s_c = (c - z);
  s_b = b;
  s_cache_t = cache_t;
  s_cache_v = cache_v;
  if (DEBUG) \{
    tools.Print("Replace incumbent single solution, set s_k="+s_k+"; s_c="+s_c+"; s_b.length="+s_b.length);
  \}
  if (s_c < 0) \{
    throw new ClientException("Negative detour");
  \}
\} else \{
  if (DEBUG) \{
    tools.Print("Detected ("+c+" - "+z+")="+(c - z)+" is greater than "+s_c+"; Keep incumbent single solution");
  \}
\}
\nwused{\\{NWkwPRG-4dVkBS-1}\\{NWkwPRG-22IadP-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar

\subsection{Accept server solution}
\nwenddocs{}\nwbegincode{21}\sublabel{NWkwPRG-1EyDWB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-1EyDWB-1}}}\moddef{Accept server solution~{\nwtagstyle{}\subpageref{NWkwPRG-1EyDWB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (s_c < opt_c) \{
  if (DEBUG) \{
    tools.Print("Detected "+s_c+" < "+opt_c);
  \}
  opt_k = s_k;
  opt_c = s_c;
  opt_b = s_b;
  opt_cache_t = s_cache_t;
  opt_cache_v = s_cache_v;
  if (DEBUG) \{
    tools.Print("Replace incumbent server solution, set opt_k="+opt_k+"; opt_c="+opt_c+"; opt_b.length="+s_b.length);
  \}
\} else \{
  if (DEBUG) \{
    tools.Print("Detected "+s_c+" > "+opt_c+"; Keep incumbent server solution");
  \}
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{22}\nwdocspar

\subsection{Submit global solution}
\nwenddocs{}\nwbegincode{23}\sublabel{NWkwPRG-29TDYN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-29TDYN-1}}}\moddef{Submit global solution~{\nwtagstyle{}\subpageref{NWkwPRG-29TDYN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (opt_k != -1) \{
  \LA{}Construct w from cache~{\nwtagstyle{}\subpageref{NWkwPRG-4ACdbX-1}}\RA{}
  int sid = L[opt_k];
  int[] rids = new int[] \{ r[0] \};
  if (DEBUG) \{
    tools.Print("Submit sid="+sid+"; opt_w.length="+opt_w.length
      +"; opt_b.length="+opt_b.length+"; opt_c="+opt_c+"; rids.length="+rids.length);
  \}
  try \{
    // We added the server's current location to b to help us compute cost,
    // but now we remove the location because it's not really a part of the
    // schedule.
    int[] opt_opt_b = new int[(opt_b.length - 3)];
    for (int i = 3; i < opt_b.length; i++) \{
      opt_opt_b[(i - 3)] = opt_b[i];
    \}
    communicator.updateServerService(sid, opt_w, opt_opt_b, rids, new int[] \{ \});
  \} catch (RouteIllegalOverwriteException e) \{
    count_rejections++;
    if (DEBUG) \{
      tools.Print("Submission rejected due to illegal overwrite!");
    \}
  \} catch (TimeWindowException e) \{
    count_rejections++;
    if (DEBUG) \{
      tools.Print("Submission rejected due to time window violation");
      tools.Print(e.toString());
    \}
  \}
\} else \{
  if (DEBUG) \{
    tools.Print("No match found");
  \}
  communicator.forwardReturnRequest(r);
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

\subsection{Construct w from cache}
\nwenddocs{}\nwbegincode{25}\sublabel{NWkwPRG-4ACdbX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-4ACdbX-1}}}\moddef{Construct w from cache~{\nwtagstyle{}\subpageref{NWkwPRG-4ACdbX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-29TDYN-1}}\nwenddeflinemarkup
int w_len = 1;
for (int[] leg : opt_cache_v) \{
  w_len += (leg.length - 1);
\}
w_len *= 2;
if (DEBUG) \{
  tools.Print("Construct w from cache");
  tools.Print("Initialize w.length="+w_len);
\}
int[] opt_w = new int[w_len];
opt_w[0] = opt_cache_t[0][0];
opt_w[1] = opt_cache_v[0][0];
if (DEBUG) \{
  tools.Print("Set opt_w[0]="+opt_w[0]);
  tools.Print("Set opt_w[1]="+opt_w[1]);
\}
int base = 0;
for (int p = 0; p < opt_cache_v.length; p++) \{
  if (p > 0) \{
    base += 2*(opt_cache_v[(p - 1)].length - 1);
  \}
  for (int q = 1; q < opt_cache_v[p].length; q++) \{
    opt_w[(base + 2*q + 0)] = opt_cache_t[p][q];
    opt_w[(base + 2*q + 1)] = opt_cache_v[p][q];
    if (DEBUG) \{
      tools.Print("Set opt_w["+(base + 2*q + 0)+"]="+opt_w[(base + 2*q + 0)]);
      tools.Print("Set opt_w["+(base + 2*q + 1)+"]="+opt_w[(base + 2*q + 1)]);
    \}
  \}
\}
\nwused{\\{NWkwPRG-29TDYN-1}}\nwendcode{}\nwbegindocs{26}\nwdocspar

\subsection{Check feasible cost}
\nwenddocs{}\nwbegincode{27}\sublabel{NWkwPRG-UGv0L-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-UGv0L-1}}}\moddef{Check feasible cost~{\nwtagstyle{}\subpageref{NWkwPRG-UGv0L-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-23iwWy-1}}\nwenddeflinemarkup
if ((c - z) > s_c) \{
  if (DEBUG) \{
    tools.Print("Detected cost infeasible ("+(c - z)+" > "+s_c+"); Return");
  \}
  return -1;
\}
\nwused{\\{NWkwPRG-23iwWy-1}}\nwendcode{}\nwbegindocs{28}\nwdocspar

\subsection{Check feasible time window}
\nwenddocs{}\nwbegincode{29}\sublabel{NWkwPRG-4PssH0-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-4PssH0-1}}}\moddef{Check feasible time window~{\nwtagstyle{}\subpageref{NWkwPRG-4PssH0-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-23iwWy-1}}\nwenddeflinemarkup
int[] u = communicator.queryUser(b[(3*p + 2)]);
if (d < u[2] || d > u[3]) \{
  if (DEBUG) \{
    tools.Print("Detected time infeasible for user "+b[(3*p + 2)]+"; d="+d+"; u[2]="+u[2]+"; u[3]="+u[3]+"; Return");
  \}
  return -1;
\}
\nwused{\\{NWkwPRG-23iwWy-1}}\nwendcode{}\nwbegindocs{30}\nwdocspar


\section{Methods}

\subsection{GreedyInsertion: \texttt{handleRequest}(1)}
\nwenddocs{}\nwbegincode{31}\sublabel{NWkwPRG-2OWvsM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-2OWvsM-1}}}\moddef{GreedyInsertion: handleRequest(1)~{\nwtagstyle{}\subpageref{NWkwPRG-2OWvsM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-2B0O1t-1}}\nwenddeflinemarkup
void handleRequest(int[] r) throws ClientException, ClientFatalException \{
  try \{
    \LA{}Initialize global vars~{\nwtagstyle{}\subpageref{NWkwPRG-jOToH-1}}\RA{}
    for (int k_cand : C) \{
      \LA{}Initialize server vars~{\nwtagstyle{}\subpageref{NWkwPRG-3y7kuU-1}}\RA{}
      \LA{}Case 1: server is idle or heading towards own destination~{\nwtagstyle{}\subpageref{NWkwPRG-4dVkBS-1}}\RA{}
      \LA{}Case 2: server is heading towards a customer~{\nwtagstyle{}\subpageref{NWkwPRG-22IadP-1}}\RA{}
      if (n >= MAX_SCHEDULE_LENGTH) \{
        if (DEBUG) \{
          tools.Print("Detected n >= MAX_SCHEDULE_LENGTH");
        \}
      \}
      \LA{}Accept server solution~{\nwtagstyle{}\subpageref{NWkwPRG-1EyDWB-1}}\RA{}
    \}
    \LA{}Submit global solution~{\nwtagstyle{}\subpageref{NWkwPRG-29TDYN-1}}\RA{}
  \} catch (SQLException e) \{
    throw new ClientException(e);
  \} catch (VertexNotFoundException | EdgeNotFoundException | UserNotFoundException e) \{
    throw new ClientException(e);
  \}
\}
\nwused{\\{NW3eY1Ju-2B0O1t-1}}\nwendcode{}\nwbegindocs{32}\nwdocspar

\subsection{GreedyInsertion: \texttt{endCollectServerLocations}(1)}
\nwenddocs{}\nwbegincode{33}\sublabel{NWkwPRG-1cMqeO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-1cMqeO-1}}}\moddef{GreedyInsertion: endCollectServerLocations(1)~{\nwtagstyle{}\subpageref{NWkwPRG-1cMqeO-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-2B0O1t-1}}\nwenddeflinemarkup
void endCollectServerLocations(int[] src) \{
  locations = src.clone();
\}
\nwused{\\{NW3eY1Ju-2B0O1t-1}}\nwendcode{}\nwbegindocs{34}\nwdocspar

\subsection{GreedyInsertion:\texttt{end}(0)}
\nwenddocs{}\nwbegincode{35}\sublabel{NWkwPRG-222iyz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-222iyz-1}}}\moddef{GreedyInsertion: end(0)~{\nwtagstyle{}\subpageref{NWkwPRG-222iyz-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-2B0O1t-1}}\nwenddeflinemarkup
void end() \{
  tools.Print("Count rejections: "+count_rejections);
\}
\nwused{\\{NW3eY1Ju-2B0O1t-1}}\nwendcode{}\nwbegindocs{36}\nwdocspar

\subsection{GreedyInsertion: \texttt{computeCost}(6)}
\nwenddocs{}\nwbegincode{37}\sublabel{NWkwPRG-23iwWy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-23iwWy-1}}}\moddef{GreedyInsertion: computeCost(6)~{\nwtagstyle{}\subpageref{NWkwPRG-23iwWy-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-2B0O1t-2}}\nwenddeflinemarkup
int computeCost(int[] b, int[][] cache_t, int[][] cache_v, int s_c, int z, int d_init)
throws ClientException, ClientFatalException \{
  try \{
    if (DEBUG) \{
      tools.Print("computeCost called on b.length="+b.length+", s_c="+s_c+", z="+z);
    \}
    int c = 0;
    int d = 0;
    int[] leg = new int[] \{ \};
    int[] ddnu = new int[] \{ \};
    if (DEBUG) \{
      tools.Print("..set c=0");
    \}
    for (int p = 1; p < (b.length/3); p++) \{
      if (DEBUG) \{
        tools.Print("..set p="+p);
      \}
      leg = tools.computeShortestPath(b[(3*(p - 1) + 1)], b[(3*p + 1)]);
      if (DEBUG) \{
        tools.Print("..call computeShortestPath("+b[(3*(p - 1) + 1)]+", "+b[(3*p + 1)]+")");
      \}
      d = b[(3*(p - 1))];
      if (DEBUG) \{
        tools.Print("..set d="+d);
      \}
      cache_t[(p - 1)] = new int[leg.length];
      cache_t[(p - 1)][0] = d;
      if (DEBUG) \{
        tools.Print("..set cache_t["+(p - 1)+"]=new int["+leg.length+"]");
        tools.Print("..set cache_t["+(p - 1)+"][0]="+d);
      \}
      if (p == 1) \{
        d += d_init;
        if (DEBUG) \{
          tools.Print("..add d_init; d="+d);
        \}
      \}
      for (int q = 1; q < leg.length; q++) \{
        if (DEBUG) \{
          tools.Print("....set q="+q);
        \}
        ddnu = communicator.queryEdge(leg[(q - 1)], leg[q]);
        if (DEBUG) \{
          tools.Print("....call queryEdge("+leg[(q - 1)]+", "+leg[q]+")");
        \}
        c += ddnu[0];
        d += tools.computeDuration(ddnu[0], ddnu[1]);
        if (DEBUG) \{
          tools.Print("....set c="+c);
          tools.Print("....set d="+d);
        \}
        cache_t[(p - 1)][q] = d;
        if (DEBUG) \{
          tools.Print("....set cache_t["+(p - 1)+"]["+q+"]="+d);
        \}
      \}
      \LA{}Check feasible cost~{\nwtagstyle{}\subpageref{NWkwPRG-UGv0L-1}}\RA{}
      \LA{}Check feasible time window~{\nwtagstyle{}\subpageref{NWkwPRG-4PssH0-1}}\RA{}
      b[(3*p)] = d;
      if (DEBUG) \{
        tools.Print("..set b["+(3*p)+"]="+d);
      \}
      cache_v[(p - 1)] = leg.clone();
      if (DEBUG) \{
        tools.Print("..set cache_v["+(p - 1)+"]=<leg.length="+leg.length+">");
      \}
    \}
    return c;
  \} catch (SQLException e) \{
    tools.Print("Something very bad happened");
    tools.PrintSQLException(e);
    throw new ClientFatalException();
  \} catch (GtreeNotLoadedException e) \{
    tools.Print("Gtree not loaded, can't continue!");
    throw new ClientFatalException();
  \} catch (GtreeIllegalSourceException e) \{
    throw new ClientException(e);
  \} catch (EdgeNotFoundException | UserNotFoundException e) \{
    throw new ClientException(e);
  \}
\}
\nwused{\\{NW3eY1Ju-2B0O1t-2}}\nwendcode{}\nwbegindocs{38}\nwdocspar

\nwenddocs{}\nwfilename{src/traffic-overview.nw}\nwbegindocs{0}\part{Traffic Functions}
\label{part-traffic}

\chapter{Overview}
\label{traffic-overview}

\nwenddocs{}\nwfilename{src/traffic-broadway.nw}\nwbegindocs{0}\chapter{Traffic: Broadway}

\nwenddocs{}\nwbegincode{1}\sublabel{NW1QgbvE-3asg0V-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW1QgbvE-3asg0V-1}}}\moddef{Broadway.java~{\nwtagstyle{}\subpageref{NW1QgbvE-3asg0V-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
package com.github.jargors.traffic;
import com.github.jargors.sim.*;
import java.util.Map;
public class Broadway extends Traffic \{
  private Map<Integer, Integer> lu_broadway = Map.ofEntries(
    Map.entry(10024,6898),
    Map.entry(10071,7512),
    Map.entry(10109,11306),
    Map.entry(10298,4057),
    Map.entry(10342,9159),
    Map.entry(10378,10775),
    Map.entry(1041,1043),
    Map.entry(1043,5145),
    Map.entry(10506,11594),
    Map.entry(10517,10519),
    Map.entry(10519,3814),
    Map.entry(10565,9347),
    Map.entry(10572,3304),
    Map.entry(10628,6944),
    Map.entry(10671,10672),
    Map.entry(10672,326),
    Map.entry(10690,10691),
    Map.entry(10691,1994),
    Map.entry(10729,11922),
    Map.entry(10775,4882),
    Map.entry(10864,2072),
    Map.entry(10949,7023),
    Map.entry(10966,7019),
    Map.entry(10983,2568),
    Map.entry(11024,3875),
    Map.entry(11066,7349),
    Map.entry(11172,8494),
    Map.entry(11197,1893),
    Map.entry(11306,7781),
    Map.entry(11314,2490),
    Map.entry(11366,1216),
    Map.entry(11398,10342),
    Map.entry(11438,8502),
    Map.entry(11439,11398),
    Map.entry(1155,6168),
    Map.entry(11594,160),
    Map.entry(1162,2350),
    Map.entry(11922,10949),
    Map.entry(11930,7340),
    Map.entry(12,4286),
    Map.entry(12114,1239),
    Map.entry(1216,1218),
    Map.entry(1218,7106),
    Map.entry(1239,1241),
    Map.entry(1241,3383),
    Map.entry(1290,4347),
    Map.entry(1467,1469),
    Map.entry(1469,10628),
    Map.entry(1564,1565),
    Map.entry(1565,4163),
    Map.entry(160,161),
    Map.entry(161,8444),
    Map.entry(1732,1734),
    Map.entry(1734,1564),
    Map.entry(180,181),
    Map.entry(181,4284),
    Map.entry(1821,10671),
    Map.entry(1832,1833),
    Map.entry(1833,10864),
    Map.entry(1854,1855),
    Map.entry(1855,2920),
    Map.entry(1883,6805),
    Map.entry(1893,1894),
    Map.entry(1894,3858),
    Map.entry(1936,1937),
    Map.entry(1937,5830),
    Map.entry(1950,887),
    Map.entry(1994,632),
    Map.entry(2072,2073),
    Map.entry(2073,7294),
    Map.entry(2083,2084),
    Map.entry(2084,6989),
    Map.entry(2118,7558),
    Map.entry(2146,2147),
    Map.entry(2147,3515),
    Map.entry(218,219),
    Map.entry(219,11314),
    Map.entry(2194,2195),
    Map.entry(2195,8923),
    Map.entry(2252,4641),
    Map.entry(226,8293),
    Map.entry(2277,2278),
    Map.entry(2278,9841),
    Map.entry(2316,843),
    Map.entry(2323,2324),
    Map.entry(2324,8683),
    Map.entry(2350,12),
    Map.entry(2393,2394),
    Map.entry(2394,4693),
    Map.entry(2413,2083),
    Map.entry(2417,6),
    Map.entry(2418,2419),
    Map.entry(2419,6973),
    Map.entry(2458,1854),
    Map.entry(2468,2418),
    Map.entry(2490,2492),
    Map.entry(2492,4298),
    Map.entry(2568,2570),
    Map.entry(2570,10024),
    Map.entry(2615,10729),
    Map.entry(2680,1883),
    Map.entry(2750,2751),
    Map.entry(2751,3016),
    Map.entry(2888,12114),
    Map.entry(2920,2888),
    Map.entry(2928,2194),
    Map.entry(3011,3013),
    Map.entry(3013,2417),
    Map.entry(3016,4767),
    Map.entry(3024,9569),
    Map.entry(3107,1467),
    Map.entry(3205,3207),
    Map.entry(3207,9193),
    Map.entry(3213,582),
    Map.entry(323,325),
    Map.entry(325,10109),
    Map.entry(326,327),
    Map.entry(327,3652),
    Map.entry(3299,2468),
    Map.entry(3304,3305),
    Map.entry(3305,5836),
    Map.entry(3383,6221),
    Map.entry(3423,3424),
    Map.entry(3424,6985),
    Map.entry(3432,3434),
    Map.entry(3434,323),
    Map.entry(3471,1936),
    Map.entry(351,353),
    Map.entry(3515,2615),
    Map.entry(353,773),
    Map.entry(355,356),
    Map.entry(3559,7418),
    Map.entry(356,11366),
    Map.entry(3597,3598),
    Map.entry(3598,8635),
    Map.entry(3628,3629),
    Map.entry(3629,3107),
    Map.entry(363,364),
    Map.entry(364,6983),
    Map.entry(3652,9572),
    Map.entry(3670,8411),
    Map.entry(3814,3816),
    Map.entry(3816,7084),
    Map.entry(3858,6061),
    Map.entry(3875,3876),
    Map.entry(3876,2458),
    Map.entry(398,399),
    Map.entry(399,3471),
    Map.entry(4057,2277),
    Map.entry(4149,2316),
    Map.entry(4163,6214),
    Map.entry(4201,4203),
    Map.entry(4203,5670),
    Map.entry(4213,6243),
    Map.entry(4284,5690),
    Map.entry(4286,6625),
    Map.entry(4298,9435),
    Map.entry(4347,4348),
    Map.entry(4348,6066),
    Map.entry(4357,4358),
    Map.entry(4358,6855),
    Map.entry(4414,8229),
    Map.entry(4516,4620),
    Map.entry(4529,1155),
    Map.entry(4535,5625),
    Map.entry(4543,8810),
    Map.entry(4620,3597),
    Map.entry(4641,4881),
    Map.entry(4693,4694),
    Map.entry(4694,5408),
    Map.entry(4742,4743),
    Map.entry(4743,3024),
    Map.entry(4767,4768),
    Map.entry(4768,5748),
    Map.entry(4774,4775),
    Map.entry(4775,5797),
    Map.entry(4881,7348),
    Map.entry(4882,4883),
    Map.entry(4883,4357),
    Map.entry(4927,11930),
    Map.entry(4932,5186),
    Map.entry(5017,7725),
    Map.entry(5024,5861),
    Map.entry(5145,5146),
    Map.entry(5146,525),
    Map.entry(5183,5184),
    Map.entry(5184,218),
    Map.entry(5186,4543),
    Map.entry(525,526),
    Map.entry(526,2118),
    Map.entry(5408,351),
    Map.entry(5481,9498),
    Map.entry(5625,4414),
    Map.entry(5670,11197),
    Map.entry(5690,5691),
    Map.entry(5691,10690),
    Map.entry(5797,4149),
    Map.entry(582,583),
    Map.entry(583,8426),
    Map.entry(5830,355),
    Map.entry(5836,11066),
    Map.entry(5861,5862),
    Map.entry(5862,1950),
    Map.entry(6,8),
    Map.entry(605,606),
    Map.entry(606,4529),
    Map.entry(6061,3628),
    Map.entry(6066,10506),
    Map.entry(6076,1162),
    Map.entry(6130,6131),
    Map.entry(6131,8353),
    Map.entry(6168,7647),
    Map.entry(621,11024),
    Map.entry(6214,3423),
    Map.entry(6221,6222),
    Map.entry(6222,7324),
    Map.entry(6234,2393),
    Map.entry(6243,4774),
    Map.entry(632,6750),
    Map.entry(6625,5024),
    Map.entry(6708,8140),
    Map.entry(6750,6752),
    Map.entry(6752,8339),
    Map.entry(6805,3299),
    Map.entry(6855,6856),
    Map.entry(6856,1041),
    Map.entry(6889,4932),
    Map.entry(6944,11438),
    Map.entry(6973,11439),
    Map.entry(6983,6984),
    Map.entry(6984,8154),
    Map.entry(6985,927),
    Map.entry(6989,3011),
    Map.entry(7019,4742),
    Map.entry(7023,5183),
    Map.entry(7084,10983),
    Map.entry(7086,888),
    Map.entry(7106,7645),
    Map.entry(7217,10298),
    Map.entry(7254,2928),
    Map.entry(7294,7295),
    Map.entry(7295,7524),
    Map.entry(7324,3205),
    Map.entry(7328,7330),
    Map.entry(7330,2750),
    //Map.entry(7339,130),
    Map.entry(7339,7328),
    Map.entry(7340,8109),
    Map.entry(7348,10565),
    Map.entry(7349,3559),
    Map.entry(7418,11172),
    Map.entry(7477,10378),
    Map.entry(7512,7513),
    Map.entry(7513,7254),
    Map.entry(7524,605),
    Map.entry(7558,1832),
    Map.entry(7611,9865),
    Map.entry(7645,7646),
    Map.entry(7646,3213),
    Map.entry(7647,4201),
    Map.entry(7725,7775),
    Map.entry(773,2252),
    Map.entry(7775,9024),
    Map.entry(7781,130),
    Map.entry(7853,7855),
    Map.entry(7855,398),
    Map.entry(8,4535),
    Map.entry(8059,10517),
    Map.entry(8109,2919),
    Map.entry(8140,10966),
    Map.entry(8154,6076),
    Map.entry(8201,8202),
    Map.entry(8202,2680),
    Map.entry(8229,8918),
    Map.entry(8293,2413),
    Map.entry(8335,180),
    Map.entry(8339,2323),
    Map.entry(8353,8354),
    Map.entry(8354,7853),
    Map.entry(8411,6234),
    Map.entry(8426,1821),
    Map.entry(843,845),
    Map.entry(8444,363),
    Map.entry(845,3670),
    Map.entry(8475,5017),
    Map.entry(8494,8495),
    Map.entry(8495,6130),
    Map.entry(8502,2146),
    Map.entry(8635,1290),
    Map.entry(8683,8684),
    Map.entry(8684,10572),
    Map.entry(8810,8812),
    Map.entry(8812,9103),
    Map.entry(887,6708),
    Map.entry(888,889),
    Map.entry(889,226),
    Map.entry(8918,7611),
    Map.entry(8923,6889),
    Map.entry(9024,8059),
    Map.entry(9103,4516),
    Map.entry(9159,5481),
    Map.entry(9193,10071),
    Map.entry(927,929),
    Map.entry(929,8475),
    Map.entry(9347,9348),
    Map.entry(9348,8335),
    Map.entry(9435,3432),
    Map.entry(9498,7217),
    Map.entry(9521,621),
    Map.entry(9569,4927),
    Map.entry(9572,9573),
    Map.entry(9573,9908),
    Map.entry(9841,9521),
    Map.entry(9865,9866),
    Map.entry(9866,1732),
    Map.entry(9908,8201)
  );
  // New Year's Eve in Manhattan: speed on Broadway is at 80% at 11:30 PM, then
  // speed decreases starting from midnight until 1:30 AM to 20% until 5:00 AM.
  // We do (vertex - 1) because edges above are 0-indexed while nodes in Jargo
  // are 1-indexed.
  public double apply(int v1, int v2, long msec) \{
    double per = 1.0;
    if ((lu_broadway.containsKey(v1-1) && lu_broadway.get(v1-1) == v2-1)
     || (lu_broadway.containsKey(v2-1) && lu_broadway.get(v2-1) == v1-1)) \{
      if (msec > 84600_000) \{  // 20% at 11:30 PM
        // per = 1-0.8*(86400_000 - msec)/1800_000;
        per = 0.2;
      \} else if (msec < 5400_000) \{  // 100% at 12:00AM moving to 20% at 1:30 AM
        per = Math.max(0.2, (5400_000 - msec)/5400_000);
      \} else if (msec < 18000_000) \{  // 20% from 1:30 AM to 5:00 AM
        per = 0.2;
      \}
    \}
    return per;
  \}
\}
\nwnotused{Broadway.java}\nwendcode{}\nwbegindocs{2}\nwdocspar

\nwenddocs{}
