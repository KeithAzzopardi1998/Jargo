\part{Client Algorithms}% ===> this file was generated automatically by noweave --- better not edit it
\label{part-client}

\chapter{Overview}
\label{client-overview}

\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

This chapter lists an overview of each of the client algorithms. Go to the page
next to each method name to go directly to the method definition.
Tables~\ref{tab:search-algorithms}~and~\ref{tab:join-algorithms} summarize some
features of the algorithms.

\begin{table}[h]
\begin{center}
\caption{Summary of Search-Based Algorithms}
\label{tab:search-algorithms}
\begin{tabular}{|l|l|l|l|l|}
\hline
Ch. & Algorithm & Selection Predicate & Scheduling Strategy & Routing Strategy \\
\hline
Ch.~\ref{client-nearest} & Nearest Neighbor & Minimum proximity & Prepend to front & Shortest-path \\
Ch.~\ref{client-greedy} & Greedy Insertion & Minimum routing cost & Insertion heuristic & Shortest-path \\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\begin{center}
\caption{Summary of Join-Based Algorithms}
\label{tab:join-algorithms}
\begin{tabular}{|l|l|l|l|l|}
\hline
Ch. & Algorithm & Join Predicate & Scheduling Strategy & Routing Strategy \\
\hline
\end{tabular}
\end{center}
\end{table}

Ridesharing algorithms can be classified as search-based or join-based.
Search-based algorithms use a selection predicate to decide which vehicle
should be assigned to a particular customer. Join-based algorithms aim to group
vehicles and customers together, with each vehicle serving all the customers in
its group. Both algorithms may use various schedule and routing strategies.  A
scheduling strategy is a method of arranging the future pick-ups and drop-offs
that a vehicle is assigned to complete. A routing strategy is a method of
computing the route that a vehicle should follow in order to go to the pick-ups
and drop-offs in the scheduled order.

For search-based algorithms, usually the predicate aims to minimize some sort
of cost. The minimum-proximity predicate finds the vehicle that minimizes
Euclidean or Haversine distance. The minimum-routing-cost predicate aims to
minimize the extra routing distance that becomes necessary due to assignment to
the customer.

For join-based algorithms...

Several scheduling strategies exist. The prepend-to-front strategy
simply arranges the customer's pick-up and drop-off at the front of the
assigned vehicle's schedule. The insertion-heuristic strategy aims to
find the best position to insert the pick-up and drop-off without
rearranging the existing pick-ups and drop-offs in the schedule.

For routing strategies, the most common is shortest-path. This strategy
simply finds the shortest path through all the pick-ups and drop-offs in a
vehicle's schedule.

\section{NearestNeighbor}

The nearest-neighbor algorithm is a search-based algorithm that uses
minimum-proximity as its selection predicate. It can be implemented using two
methods. The {\Tt{}handleRequest\nwendquote}(1) method will search for and assign the
minimum-proximity vehicle to given customer requests. The
{\Tt{}handleServerLocation\nwendquote}(1) method will store new vehicle locations as they are
updated.

\nwfilename{src/client-overview.nw}\nwbegincode{1}\sublabel{NW3eY1Ju-3yym9S-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3eY1Ju-3yym9S-1}}}\moddef{\code{}NearestNeighbor\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-3yym9S-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-QNBZk-1}}\nwenddeflinemarkup
protected \LA{}NearestNeighbor: handleRequest(1)~{\nwtagstyle{}\subpageref{NW2MZpIA-16KpI3-1}}\RA{}
protected \LA{}NearestNeighbor: handleServerLocation(1)~{\nwtagstyle{}\subpageref{NW2MZpIA-fLFsG-1}}\RA{}
\nwused{\\{NW2MZpIA-QNBZk-1}}\nwendcode{}

\nwixlogsorted{c}{{\code{}GreedyInsertion\edoc{} member variables}{NWkwPRG-jESV1-1}{\nwixu{NWkwPRG-1Tuf6f-1}\nwixd{NWkwPRG-jESV1-1}}}%
\nwixlogsorted{c}{{\code{}GreedyInsertion\edoc{} methods}{NW3eY1Ju-2B0O1t-1}{\nwixd{NW3eY1Ju-2B0O1t-1}\nwixd{NW3eY1Ju-2B0O1t-2}\nwixu{NWkwPRG-1Tuf6f-1}}}%
\nwixlogsorted{c}{{\code{}NearestNeighbor\edoc{} member variables}{NW2MZpIA-4N5YZL-1}{\nwixu{NW2MZpIA-QNBZk-1}\nwixd{NW2MZpIA-4N5YZL-1}}}%
\nwixlogsorted{c}{{\code{}NearestNeighbor\edoc{} methods}{NW3eY1Ju-3yym9S-1}{\nwixd{NW3eY1Ju-3yym9S-1}\nwixu{NW2MZpIA-QNBZk-1}}}%
\nwixlogsorted{c}{{Accept server solution}{NWkwPRG-1EyDWB-1}{\nwixd{NWkwPRG-1EyDWB-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Accept single solution}{NWkwPRG-47ILqi-1}{\nwixu{NWkwPRG-4dVkBS-1}\nwixu{NWkwPRG-22IadP-1}\nwixd{NWkwPRG-47ILqi-1}}}%
\nwixlogsorted{c}{{Apply delta, range, and event filters}{NW2MZpIA-1w0JIl-1}{\nwixd{NW2MZpIA-1w0JIl-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{Broadway.java}{NW1QgbvE-3asg0V-1}{\nwixd{NW1QgbvE-3asg0V-1}}}%
\nwixlogsorted{c}{{Case 1: server is idle or heading towards own destination}{NWkwPRG-4dVkBS-1}{\nwixd{NWkwPRG-4dVkBS-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Case 2: server is heading towards a customer}{NWkwPRG-22IadP-1}{\nwixd{NWkwPRG-22IadP-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Check capacity}{NWkwPRG-27P27q-1}{\nwixu{NWkwPRG-3KjiZY-1}\nwixd{NWkwPRG-27P27q-1}}}%
\nwixlogsorted{c}{{Check feasible cost}{NWkwPRG-UGv0L-1}{\nwixd{NWkwPRG-UGv0L-1}\nwixu{NWkwPRG-23iwWy-1}}}%
\nwixlogsorted{c}{{Check feasible time window}{NWkwPRG-4PssH0-1}{\nwixd{NWkwPRG-4PssH0-1}\nwixu{NWkwPRG-23iwWy-1}}}%
\nwixlogsorted{c}{{Compute sequence}{NWkwPRG-3KjiZY-1}{\nwixu{NWkwPRG-22IadP-1}\nwixd{NWkwPRG-3KjiZY-1}}}%
\nwixlogsorted{c}{{Construct w from cache}{NWkwPRG-4ACdbX-1}{\nwixu{NWkwPRG-29TDYN-1}\nwixd{NWkwPRG-4ACdbX-1}}}%
\nwixlogsorted{c}{{Debug: delta filter}{NW2MZpIA-2I20iB-1}{\nwixu{NW2MZpIA-1w0JIl-1}\nwixd{NW2MZpIA-2I20iB-1}}}%
\nwixlogsorted{c}{{Debug: event filter}{NW2MZpIA-4OxIMR-1}{\nwixu{NW2MZpIA-1w0JIl-1}\nwixd{NW2MZpIA-4OxIMR-1}}}%
\nwixlogsorted{c}{{Debug: find minimum-range candidate}{NW2MZpIA-3aXcFM-1}{\nwixu{NW2MZpIA-2TDXjw-1}\nwixd{NW2MZpIA-3aXcFM-1}}}%
\nwixlogsorted{c}{{Debug: get current time}{NW2MZpIA-xqgdv-1}{\nwixu{NW2MZpIA-2qkQZx-1}\nwixd{NW2MZpIA-xqgdv-1}}}%
\nwixlogsorted{c}{{Debug: get number of events}{NW2MZpIA-1TMdCp-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-1TMdCp-1}}}%
\nwixlogsorted{c}{{Debug: get old schedule}{NW2MZpIA-3sG0PQ-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-3sG0PQ-1}}}%
\nwixlogsorted{c}{{Debug: handle request}{NW2MZpIA-33A3UY-1}{\nwixu{NW2MZpIA-16KpI3-1}\nwixd{NW2MZpIA-33A3UY-1}}}%
\nwixlogsorted{c}{{Debug: initialize candidates container}{NW2MZpIA-3LGRX7-1}{\nwixu{NW2MZpIA-3doegf-1}\nwixd{NW2MZpIA-3LGRX7-1}}}%
\nwixlogsorted{c}{{Debug: initialize legs container}{NW2MZpIA-3R3yVH-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-3R3yVH-1}}}%
\nwixlogsorted{c}{{Debug: initialize new schedule}{NW2MZpIA-GmK8M-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-GmK8M-1}}}%
\nwixlogsorted{c}{{Debug: join route components}{NW2MZpIA-J6KjD-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-J6KjD-1}}}%
\nwixlogsorted{c}{{Debug: join schedule components}{NW2MZpIA-qM9ER-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-qM9ER-1}}}%
\nwixlogsorted{c}{{Debug: put candidate}{NW2MZpIA-1Lo26M-1}{\nwixu{NW2MZpIA-1w0JIl-1}\nwixd{NW2MZpIA-1Lo26M-1}}}%
\nwixlogsorted{c}{{Debug: put server location}{NW2MZpIA-hcsfv-1}{\nwixu{NW2MZpIA-fLFsG-1}\nwixd{NW2MZpIA-hcsfv-1}}}%
\nwixlogsorted{c}{{Debug: range filter}{NW2MZpIA-4aukgD-1}{\nwixu{NW2MZpIA-1w0JIl-1}\nwixd{NW2MZpIA-4aukgD-1}}}%
\nwixlogsorted{c}{{Debug: set first leg}{NW2MZpIA-1F8aiy-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-1F8aiy-1}}}%
\nwixlogsorted{c}{{Debug: set initial labels}{NW2MZpIA-1sURxT-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-1sURxT-1}}}%
\nwixlogsorted{c}{{Debug: set initial vertices}{NW2MZpIA-1iZHLf-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-1iZHLf-1}}}%
\nwixlogsorted{c}{{Debug: set remaining legs}{NW2MZpIA-Zbf0J-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-Zbf0J-1}}}%
\nwixlogsorted{c}{{Debug: set route length and time}{NW2MZpIA-3WOc2v-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-3WOc2v-1}}}%
\nwixlogsorted{c}{{Debug: set schedule time}{NW2MZpIA-1EJRY4-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-1EJRY4-1}}}%
\nwixlogsorted{c}{{Debug: set schedule vertex and label}{NW2MZpIA-1lkGjK-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-1lkGjK-1}}}%
\nwixlogsorted{c}{{Debug: set vehicle end time}{NW2MZpIA-3ZHBo5-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-3ZHBo5-1}}}%
\nwixlogsorted{c}{{Debug: submit}{NW2MZpIA-2e4BPs-1}{\nwixu{NW2MZpIA-3sZXk2-1}\nwixd{NW2MZpIA-2e4BPs-1}}}%
\nwixlogsorted{c}{{Find minimum-range candidate}{NW2MZpIA-2TDXjw-1}{\nwixd{NW2MZpIA-2TDXjw-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{Get current time}{NW2MZpIA-2qkQZx-1}{\nwixd{NW2MZpIA-2qkQZx-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{GreedyInsertion.java}{NWkwPRG-1Tuf6f-1}{\nwixd{NWkwPRG-1Tuf6f-1}}}%
\nwixlogsorted{c}{{GreedyInsertion.java preamble}{NWkwPRG-1neuor-1}{\nwixu{NWkwPRG-1Tuf6f-1}\nwixd{NWkwPRG-1neuor-1}}}%
\nwixlogsorted{c}{{GreedyInsertion: computeCost(6)}{NWkwPRG-23iwWy-1}{\nwixu{NW3eY1Ju-2B0O1t-2}\nwixd{NWkwPRG-23iwWy-1}}}%
\nwixlogsorted{c}{{GreedyInsertion: end(0)}{NWkwPRG-222iyz-1}{\nwixu{NW3eY1Ju-2B0O1t-1}\nwixd{NWkwPRG-222iyz-1}}}%
\nwixlogsorted{c}{{GreedyInsertion: endCollectServerLocations(1)}{NWkwPRG-1cMqeO-1}{\nwixu{NW3eY1Ju-2B0O1t-1}\nwixd{NWkwPRG-1cMqeO-1}}}%
\nwixlogsorted{c}{{GreedyInsertion: handleRequest(1)}{NWkwPRG-2OWvsM-1}{\nwixu{NW3eY1Ju-2B0O1t-1}\nwixd{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Initialize candidates container}{NW2MZpIA-3doegf-1}{\nwixd{NW2MZpIA-3doegf-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{Initialize global vars}{NWkwPRG-jOToH-1}{\nwixd{NWkwPRG-jOToH-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Initialize server vars}{NWkwPRG-3y7kuU-1}{\nwixd{NWkwPRG-3y7kuU-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{NearestNeighbor.java}{NW2MZpIA-QNBZk-1}{\nwixd{NW2MZpIA-QNBZk-1}}}%
\nwixlogsorted{c}{{NearestNeighbor.java preamble}{NW2MZpIA-2sgckr-1}{\nwixu{NW2MZpIA-QNBZk-1}\nwixd{NW2MZpIA-2sgckr-1}\nwixd{NW2MZpIA-2sgckr-2}}}%
\nwixlogsorted{c}{{NearestNeighbor: handleRequest(1)}{NW2MZpIA-16KpI3-1}{\nwixu{NW3eY1Ju-3yym9S-1}\nwixd{NW2MZpIA-16KpI3-1}}}%
\nwixlogsorted{c}{{NearestNeighbor: handleServerLocation(1)}{NW2MZpIA-fLFsG-1}{\nwixu{NW3eY1Ju-3yym9S-1}\nwixd{NW2MZpIA-fLFsG-1}}}%
\nwixlogsorted{c}{{Submit global solution}{NWkwPRG-29TDYN-1}{\nwixd{NWkwPRG-29TDYN-1}\nwixu{NWkwPRG-2OWvsM-1}}}%
\nwixlogsorted{c}{{Submit minimum-range candidate}{NW2MZpIA-3sZXk2-1}{\nwixd{NW2MZpIA-3sZXk2-1}\nwixu{NW2MZpIA-16KpI3-1}}}%
\nwbegindocs{2}\nwdocspar

\section{GreedyInsertion}

The greedy-insertion algorithm...

\nwenddocs{}\nwbegincode{3}\sublabel{NW3eY1Ju-2B0O1t-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-1}}}\moddef{\code{}GreedyInsertion\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-1Tuf6f-1}}\nwprevnextdefs{\relax}{NW3eY1Ju-2B0O1t-2}\nwenddeflinemarkup
protected \LA{}GreedyInsertion: handleRequest(1)~{\nwtagstyle{}\subpageref{NWkwPRG-2OWvsM-1}}\RA{}
protected \LA{}GreedyInsertion: endCollectServerLocations(1)~{\nwtagstyle{}\subpageref{NWkwPRG-1cMqeO-1}}\RA{}
protected \LA{}GreedyInsertion: end(0)~{\nwtagstyle{}\subpageref{NWkwPRG-222iyz-1}}\RA{}
\nwalsodefined{\\{NW3eY1Ju-2B0O1t-2}}\nwused{\\{NWkwPRG-1Tuf6f-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

\nwenddocs{}\nwbegincode{5}\sublabel{NW3eY1Ju-2B0O1t-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-2}}}\moddef{\code{}GreedyInsertion\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-1Tuf6f-1}}\nwprevnextdefs{NW3eY1Ju-2B0O1t-1}{\relax}\nwenddeflinemarkup
private \LA{}GreedyInsertion: computeCost(6)~{\nwtagstyle{}\subpageref{NWkwPRG-23iwWy-1}}\RA{}
\nwused{\\{NWkwPRG-1Tuf6f-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

\nwenddocs{}\nwfilename{src/client-nearest.nw}\nwbegindocs{0}\chapter{Client: NearestNeighbor}
\label{client-nearest}

The nearest-neighbor algorithm aims to find the closest vehicle for a given
customer request and assigns that vehicle to the request. This example uses the
prepend-to-front scheduling strategy and the shortest-path routing strategy.

This example implements a ``naive'' algorithm. It doesn't check the vehicle
capacity or any time-window constraints when it submits assignments. If the
vehicle that it submits doesn't have enough capacity to serve the customer,
then Jargo automatically rejects the submission, just as a real-world driver
might skip the new assignment. If a time-window violation occurs, Jargo will
record the violation. Jargo treats time windows as soft constraints as they are
difficult to guarantee to traffic.

\nwenddocs{}\nwbegincode{1}\sublabel{NW2MZpIA-QNBZk-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-QNBZk-1}}}\moddef{NearestNeighbor.java~{\nwtagstyle{}\subpageref{NW2MZpIA-QNBZk-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}NearestNeighbor.java preamble~{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-1}}\RA{}
public class NearestNeighbor extends Client \{
  \LA{}\code{}NearestNeighbor\edoc{} member variables~{\nwtagstyle{}\subpageref{NW2MZpIA-4N5YZL-1}}\RA{}
  \LA{}\code{}NearestNeighbor\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-3yym9S-1}}\RA{}
\}
\nwnotused{NearestNeighbor.java}\nwendcode{}\nwbegindocs{2}\nwdocspar

\section{Preamble}
\label{NearestNeighbor: preamble}

All example algorithms belong to the {\Tt{}com.github.jargors.client\nwendquote} package.

\nwenddocs{}\nwbegincode{3}\sublabel{NW2MZpIA-2sgckr-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-1}}}\moddef{NearestNeighbor.java preamble~{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-QNBZk-1}}\nwprevnextdefs{\relax}{NW2MZpIA-2sgckr-2}\nwenddeflinemarkup
package com.github.jargors.client;
\nwalsodefined{\\{NW2MZpIA-2sgckr-2}}\nwused{\\{NW2MZpIA-QNBZk-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

We import Jargo {\Tt{}sim\nwendquote} components and some standard Java utilities.

\nwenddocs{}\nwbegincode{5}\sublabel{NW2MZpIA-2sgckr-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-2}}}\moddef{NearestNeighbor.java preamble~{\nwtagstyle{}\subpageref{NW2MZpIA-2sgckr-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-QNBZk-1}}\nwprevnextdefs{NW2MZpIA-2sgckr-1}{\relax}\nwenddeflinemarkup
import com.github.jargors.sim.*;
import java.util.Map;
import java.util.Map.Entry;
import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;
\nwused{\\{NW2MZpIA-QNBZk-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

\section{Member Variables}
\label{client-nearest: member-variables}

This example uses three filters to quickly narrow down the nearest vehicle.
The thresholds for these filters are defined in the member variables. A map
called {\Tt{}locations\nwendquote} is initialized. It will be used to store vehicle locations
as the information becomes available.

\nwenddocs{}\nwbegincode{7}\sublabel{NW2MZpIA-4N5YZL-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-4N5YZL-1}}}\moddef{\code{}NearestNeighbor\edoc{} member variables~{\nwtagstyle{}\subpageref{NW2MZpIA-4N5YZL-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-QNBZk-1}}\nwenddeflinemarkup
final int MAX_DELTA = 300;  // seconds from last vehicle location update
final int MAX_RANGE = 600;  // meters from last vehicle position
final int MAX_EVENT = 8;    // remaining pick-up and drop-off events
final ConcurrentHashMap<Integer, int[]> locations =
  new ConcurrentHashMap<Integer, int[]>();
\nwused{\\{NW2MZpIA-QNBZk-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

\section{Chunks}
\label{NearestNeighbor: chunks}

The current time is used to check how long ago was the last positional update
for vehicles, to ask vehicles what their remaining schedules are from this time
forward, and to compute a new route with specified time components.

\subsection{Get Current Time}

\nwenddocs{}\nwbegincode{9}\sublabel{NW2MZpIA-2qkQZx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2qkQZx-1}}}\moddef{Get current time~{\nwtagstyle{}\subpageref{NW2MZpIA-2qkQZx-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
final int now = this.communicator.retrieveClock();
\LA{}Debug: get current time~{\nwtagstyle{}\subpageref{NW2MZpIA-xqgdv-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

\subsection{Initialize Candidates Container}

Each request is associated with a set of candidate vehicles. We will store
these candidates in a hash map called {\Tt{}candidates\nwendquote}. The key to the map will
be the vehicle identifier and the values will be distance to last-known
locations.

\nwenddocs{}\nwbegincode{11}\sublabel{NW2MZpIA-3doegf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3doegf-1}}}\moddef{Initialize candidates container~{\nwtagstyle{}\subpageref{NW2MZpIA-3doegf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
final Map<Integer, Integer> candidates = new HashMap<Integer, Integer>();
\LA{}Debug: initialize candidates container~{\nwtagstyle{}\subpageref{NW2MZpIA-3LGRX7-1}}\RA{}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

\subsection{Apply Delta, Range, and Event Filters}

We get the candidates by filtering the set of all vehicles based on last-update
time, range, and schedule length.

\nwenddocs{}\nwbegincode{13}\sublabel{NW2MZpIA-1w0JIl-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1w0JIl-1}}}\moddef{Apply delta, range, and event filters~{\nwtagstyle{}\subpageref{NW2MZpIA-1w0JIl-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
for (final Integer sid : locations.keySet()) \{
  final Integer t = locations.get(sid)[0];
  final Integer v = locations.get(sid)[1];

  final boolean in_delta = (t >= now - MAX_DELTA);
  \LA{}Debug: delta filter~{\nwtagstyle{}\subpageref{NW2MZpIA-2I20iB-1}}\RA{}
  if (!in_delta)
    continue;

  final int range = this.tools.computeHaversine(v, r[4]);
  final boolean in_range = (range <= MAX_RANGE);
  \LA{}Debug: range filter~{\nwtagstyle{}\subpageref{NW2MZpIA-4aukgD-1}}\RA{}
  if (!in_range)
    continue;

  final int event =
    this.communicator.queryServerScheduleRemaining(sid, now).length/4;
  final boolean in_event = (event <= MAX_EVENT);
  \LA{}Debug: event filter~{\nwtagstyle{}\subpageref{NW2MZpIA-4OxIMR-1}}\RA{}
  if (!in_event)
    continue;

  candidates.put(sid, range);
  \LA{}Debug: put candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-1Lo26M-1}}\RA{}
\}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

\subsection{Find Minimum-Range Candidate}

Iterate over the candidates to find the minimum-range candidate.

\nwenddocs{}\nwbegincode{15}\sublabel{NW2MZpIA-2TDXjw-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2TDXjw-1}}}\moddef{Find minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-2TDXjw-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
Entry<Integer, Integer> min = null;
for (final Entry<Integer, Integer> entry : candidates.entrySet()) \{
  if (min == null || min.getValue() > entry.getValue()) \{
    min = entry;
    \LA{}Debug: find minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3aXcFM-1}}\RA{}
  \}
\}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

\subsection{Submit Minimum-Range Candidate}

To submit the minimum-range candidate as the assiged vehicle, compute a new
schedule for the vehicle that includes the request's pick-up and drop-off
locations, and also compute a new route that passes through these locations.
Schedules and routes (and customers and vehicles) are simple integer arrays
in Jargo. The following code reads from the existing schedule array,
populates the new schedule array, and computes the new route array.
The array formats are...

\nwenddocs{}\nwbegincode{17}\sublabel{NW2MZpIA-3sZXk2-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\moddef{Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
if (min != null) \{
  // Get the old schedule
  final int sid = min.getKey();
  final int[] bold = this.communicator.queryServerScheduleRemaining(sid, now);
  \LA{}Debug: get old schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-3sG0PQ-1}}\RA{}

  // m=number of events; p=new number of events
  final int m = bold.length/4;
  final int p = m + 2;
  \LA{}Debug: get number of events~{\nwtagstyle{}\subpageref{NW2MZpIA-1TMdCp-1}}\RA{}

  // bnew contains the new schedule
  final int[] bnew = new int[3*p];
  final int[] bnew_t = new int[p];
  final int[] bnew_v = new int[p];
  final int[] bnew_l = new int[p];
  \LA{}Debug: initialize new schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-GmK8M-1}}\RA{}

  // set the first, second vertices
  bnew_v[0] = r[4];
  bnew_v[1] = r[5];
  \LA{}Debug: set initial vertices~{\nwtagstyle{}\subpageref{NW2MZpIA-1iZHLf-1}}\RA{}

  // and label them
  bnew_l[0] = r[0];
  bnew_l[1] = r[0];
  \LA{}Debug: set initial labels~{\nwtagstyle{}\subpageref{NW2MZpIA-1sURxT-1}}\RA{}

  // set the remaining vertices and labels
  for (int i = 0; i < m; i++) \{
    final int bv = bold[(i + 1)];
    final int ls = bold[(i + 2)];
    final int lr = bold[(i + 3)];
    bnew_v[(i + 2)] = bv;
    bnew_l[(i + 2)] = (ls == 0 ? lr : ls);
    \LA{}Debug: set schedule vertex and label~{\nwtagstyle{}\subpageref{NW2MZpIA-1lkGjK-1}}\RA{}
  \}

  // to get the times and route, create a 'legs' container
  final int[][] legs = new int[p][];
  int[] leg = null;
  \LA{}Debug: initialize legs container~{\nwtagstyle{}\subpageref{NW2MZpIA-3R3yVH-1}}\RA{}

  // get the first leg, from last-known location to request origin
  leg = this.tools.computeRoute(locations.get(sid)[1], r[4], now);
  legs[0] = leg;
  \LA{}Debug: set first leg~{\nwtagstyle{}\subpageref{NW2MZpIA-1F8aiy-1}}\RA{}

  // get the current route length and time after first leg
  int n = leg.length;
  int t = leg[n - 2];
  \LA{}Debug: set route length and time~{\nwtagstyle{}\subpageref{NW2MZpIA-3WOc2v-1}}\RA{}

  // get the remaining legs while updating the route length n
  for (int i = 1; i < p; i++) \{
    final int u = bnew_v[(i - 1)];
    final int v = bnew_v[(i - 0)];
    leg = this.tools.computeRoute(u, v, t);
    legs[i] = leg;
    \LA{}Debug: set remaining legs~{\nwtagstyle{}\subpageref{NW2MZpIA-Zbf0J-1}}\RA{}

    n += leg.length;
    t = leg[leg.length - 2];
    \LA{}Debug: set route length and time~{\nwtagstyle{}\subpageref{NW2MZpIA-3WOc2v-1}}\RA{}
  \}

  // set the times in bnew
  for (int i = 1; i < legs.length; i++) \{
    bnew_t[(i - 1)] = legs[i][0];
    \LA{}Debug: set schedule time~{\nwtagstyle{}\subpageref{NW2MZpIA-1EJRY4-1}}\RA{}
  \}

  // set the vehicle end time
  bnew_t[(p - 1)] = t;
  \LA{}Debug: set vehicle end time~{\nwtagstyle{}\subpageref{NW2MZpIA-3ZHBo5-1}}\RA{}

  // join the bnew components
  for (int i = 0; i < p; i++) \{
    bnew[(i + 0)] = bnew_t[i];
    bnew[(i + 1)] = bnew_v[i];
    bnew[(i + 2)] = bnew_l[i];
    \LA{}Debug: join schedule components~{\nwtagstyle{}\subpageref{NW2MZpIA-qM9ER-1}}\RA{}
  \}

  // join the legs into the new route
  final int[] wnew = new int[n];
  int k = 0;
  for (int i = 0; i < legs.length; i++) \{
    for (int j = 0; j < legs[i].length; j++) \{
      wnew[k] = legs[i][j];
      \LA{}Debug: join route components~{\nwtagstyle{}\subpageref{NW2MZpIA-J6KjD-1}}\RA{}
      k++;
    \}
  \}

  // submit
  this.communicator.updateServerService(sid, wnew, bnew,
      new int[] \{ r[0] \}, new int[] \{ \});
  \LA{}Debug: submit~{\nwtagstyle{}\subpageref{NW2MZpIA-2e4BPs-1}}\RA{}
\}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

\section{Methods}
\label{client-nearest: methods}

\subsection{\texttt{handleRequest}(1)}

Now we can write the body of {\Tt{}handleRequest\nwendquote}(1).  The entire method is
wrapped in try/catch because some method calls can throw exceptions. If an
exception is caught, it gets bubbled up to Jargo via {\Tt{}ClientException\nwendquote}. This
exception does not end the simulation, but {\Tt{}ClientFatalException\nwendquote} will.

\nwenddocs{}\nwbegincode{19}\sublabel{NW2MZpIA-16KpI3-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-16KpI3-1}}}\moddef{NearestNeighbor: handleRequest(1)~{\nwtagstyle{}\subpageref{NW2MZpIA-16KpI3-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-3yym9S-1}}\nwenddeflinemarkup
void handleRequest(int[] r) throws ClientException, ClientFatalException \{
  \LA{}Debug: handle request~{\nwtagstyle{}\subpageref{NW2MZpIA-33A3UY-1}}\RA{}
  try \{
    \LA{}Get current time~{\nwtagstyle{}\subpageref{NW2MZpIA-2qkQZx-1}}\RA{}
    \LA{}Initialize candidates container~{\nwtagstyle{}\subpageref{NW2MZpIA-3doegf-1}}\RA{}
    \LA{}Apply delta, range, and event filters~{\nwtagstyle{}\subpageref{NW2MZpIA-1w0JIl-1}}\RA{}
    \LA{}Find minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-2TDXjw-1}}\RA{}
    \LA{}Submit minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3sZXk2-1}}\RA{}
  \} catch (Exception e) \{
    throw new ClientException(e);
  \}
\}
\nwused{\\{NW3eY1Ju-3yym9S-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar

\subsection{\texttt{handleServerLocation}(1)}

Jargo automatically calls {\Tt{}handleServerLocation\nwendquote}(1) for each server with
a position update. We will take the update and store it into our {\Tt{}locations\nwendquote}
array.

\nwenddocs{}\nwbegincode{21}\sublabel{NW2MZpIA-fLFsG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-fLFsG-1}}}\moddef{NearestNeighbor: handleServerLocation(1)~{\nwtagstyle{}\subpageref{NW2MZpIA-fLFsG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-3yym9S-1}}\nwenddeflinemarkup
void handleServerLocation(int[] s) \{
  this.locations.put(s[0], new int[] \{ s[1], s[2] \});
  \LA{}Debug: put server location~{\nwtagstyle{}\subpageref{NW2MZpIA-hcsfv-1}}\RA{}
\}
\nwused{\\{NW3eY1Ju-3yym9S-1}}\nwendcode{}\nwbegindocs{22}\nwdocspar

\section{Debug}

Debugging can be turned on by passing the {\Tt{}-Djargors.client.debug=true\nwendquote}
runtime flag to the JVM when a Jargo simulation is started. If this flag is
true, the the {\Tt{}DEBUG\nwendquote} member variable is true. The following sections print
some helpful messages if debugging is turned on.

\subsection{Debug: Handle Request}

\nwenddocs{}\nwbegincode{23}\sublabel{NW2MZpIA-33A3UY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-33A3UY-1}}}\moddef{Debug: handle request~{\nwtagstyle{}\subpageref{NW2MZpIA-33A3UY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-16KpI3-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got request=\{ id=%d, q=%d, e=%d, l=%d, o=%d, d=%d, b=%d \}\\n",
      r[0], r[1], r[2], r[3], r[4], r[5], r[6]);
\}
\nwused{\\{NW2MZpIA-16KpI3-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

\subsection{Debug: Get Current Time}

\nwenddocs{}\nwbegincode{25}\sublabel{NW2MZpIA-xqgdv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-xqgdv-1}}}\moddef{Debug: get current time~{\nwtagstyle{}\subpageref{NW2MZpIA-xqgdv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-2qkQZx-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got now=%d\\n", now);
\}
\nwused{\\{NW2MZpIA-2qkQZx-1}}\nwendcode{}\nwbegindocs{26}\nwdocspar

\subsection{Debug: Initialize Candidates Container}

\nwenddocs{}\nwbegincode{27}\sublabel{NW2MZpIA-3LGRX7-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3LGRX7-1}}}\moddef{Debug: initialize candidates container~{\nwtagstyle{}\subpageref{NW2MZpIA-3LGRX7-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3doegf-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("init candidates[]=\{ \}\\n");
\}
\nwused{\\{NW2MZpIA-3doegf-1}}\nwendcode{}\nwbegindocs{28}\nwdocspar

\subsection{Debug: Delta Filter}

\nwenddocs{}\nwbegincode{29}\sublabel{NW2MZpIA-2I20iB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2I20iB-1}}}\moddef{Debug: delta filter~{\nwtagstyle{}\subpageref{NW2MZpIA-2I20iB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1w0JIl-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got %d in_delta=%s\\n", sid, (in_delta ? "true" : "false"));
\}
\nwused{\\{NW2MZpIA-1w0JIl-1}}\nwendcode{}\nwbegindocs{30}\nwdocspar

\subsection{Debug: Range Filter}

\nwenddocs{}\nwbegincode{31}\sublabel{NW2MZpIA-4aukgD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-4aukgD-1}}}\moddef{Debug: range filter~{\nwtagstyle{}\subpageref{NW2MZpIA-4aukgD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1w0JIl-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got %d in_range=%s\\n", sid, (in_range ? "true" : "false"));
\}
\nwused{\\{NW2MZpIA-1w0JIl-1}}\nwendcode{}\nwbegindocs{32}\nwdocspar

\subsection{Debug: Event Filter}

\nwenddocs{}\nwbegincode{33}\sublabel{NW2MZpIA-4OxIMR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-4OxIMR-1}}}\moddef{Debug: event filter~{\nwtagstyle{}\subpageref{NW2MZpIA-4OxIMR-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1w0JIl-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got %d in_event=%s\\n", sid, (in_event ? "true" : "false"));
\}
\nwused{\\{NW2MZpIA-1w0JIl-1}}\nwendcode{}\nwbegindocs{34}\nwdocspar

\subsection{Debug: Put Candidate}

\nwenddocs{}\nwbegincode{35}\sublabel{NW2MZpIA-1Lo26M-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1Lo26M-1}}}\moddef{Debug: put candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-1Lo26M-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-1w0JIl-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("put candidates[], key=%d, val=%d\\n", sid, range);
\}
\nwused{\\{NW2MZpIA-1w0JIl-1}}\nwendcode{}\nwbegindocs{36}\nwdocspar

\subsection{Debug: Find Minimum-Range Candidate}

\nwenddocs{}\nwbegincode{37}\sublabel{NW2MZpIA-3aXcFM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3aXcFM-1}}}\moddef{Debug: find minimum-range candidate~{\nwtagstyle{}\subpageref{NW2MZpIA-3aXcFM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-2TDXjw-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set min=\{ %d, %d \}\\n", min.getKey(), min.getValue());
\}
\nwused{\\{NW2MZpIA-2TDXjw-1}}\nwendcode{}\nwbegindocs{38}\nwdocspar

\subsection{Debug: Get Old Schedule}

\nwenddocs{}\nwbegincode{39}\sublabel{NW2MZpIA-3sG0PQ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3sG0PQ-1}}}\moddef{Debug: get old schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-3sG0PQ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got bold: \\n");
  for (int i : bold) \{
    System.out.printf("  %d\\n", i);
  \}
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{40}\nwdocspar

\subsection{Debug: Get Number of Events}

\nwenddocs{}\nwbegincode{41}\sublabel{NW2MZpIA-1TMdCp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1TMdCp-1}}}\moddef{Debug: get number of events~{\nwtagstyle{}\subpageref{NW2MZpIA-1TMdCp-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("got m=%d\\n", m);
  System.out.printf("got p=%d\\n", p);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{42}\nwdocspar

\subsection{Debug: Initialize New Schedule}

\nwenddocs{}\nwbegincode{43}\sublabel{NW2MZpIA-GmK8M-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-GmK8M-1}}}\moddef{Debug: initialize new schedule~{\nwtagstyle{}\subpageref{NW2MZpIA-GmK8M-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("init bnew=\{ \}\\n");
  System.out.printf("init bnew_t=\{ \}\\n");
  System.out.printf("init bnew_v=\{ \}\\n");
  System.out.printf("init bnew_l=\{ \}\\n");
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{44}\nwdocspar

\subsection{Debug: Set Initial Vertices}

\nwenddocs{}\nwbegincode{45}\sublabel{NW2MZpIA-1iZHLf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1iZHLf-1}}}\moddef{Debug: set initial vertices~{\nwtagstyle{}\subpageref{NW2MZpIA-1iZHLf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_v[0]=%d\\n", bnew_v[0]);
  System.out.printf("set bnew_v[1]=%d\\n", bnew_v[1]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{46}\nwdocspar

\subsection{Debug: Set Initial Labels}

\nwenddocs{}\nwbegincode{47}\sublabel{NW2MZpIA-1sURxT-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1sURxT-1}}}\moddef{Debug: set initial labels~{\nwtagstyle{}\subpageref{NW2MZpIA-1sURxT-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_l[0]=%d\\n", bnew_l[0]);
  System.out.printf("set bnew_l[1]=%d\\n", bnew_l[1]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{48}\nwdocspar

\subsection{Debug: Set Schedule Vertex and Label}

\nwenddocs{}\nwbegincode{49}\sublabel{NW2MZpIA-1lkGjK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1lkGjK-1}}}\moddef{Debug: set schedule vertex and label~{\nwtagstyle{}\subpageref{NW2MZpIA-1lkGjK-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_v[%d]=%d\\n", (i + 2), bnew_v[(i + 2)]);
  System.out.printf("set bnew_l[%d]=%d\\n", (i + 2), bnew_l[(i + 2)]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{50}\nwdocspar

\subsection{Debug: Set Schedule Time}

\nwenddocs{}\nwbegincode{51}\sublabel{NW2MZpIA-1EJRY4-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1EJRY4-1}}}\moddef{Debug: set schedule time~{\nwtagstyle{}\subpageref{NW2MZpIA-1EJRY4-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_t[%d]=%d\\n", (i - 1), bnew_t[(i - 1)]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{52}\nwdocspar

\subsection{Debug: Set Vehicle End Time}

\nwenddocs{}\nwbegincode{53}\sublabel{NW2MZpIA-3ZHBo5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3ZHBo5-1}}}\moddef{Debug: set vehicle end time~{\nwtagstyle{}\subpageref{NW2MZpIA-3ZHBo5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew_t[%d]=%d\\n", (p - 1), bnew_t[(p - 1)]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{54}\nwdocspar

\subsection{Debug: Join Schedule Components}

\nwenddocs{}\nwbegincode{55}\sublabel{NW2MZpIA-qM9ER-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-qM9ER-1}}}\moddef{Debug: join schedule components~{\nwtagstyle{}\subpageref{NW2MZpIA-qM9ER-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set bnew[%d]=%d\\n", (i + 0), bnew[(i + 0)]);
  System.out.printf("set bnew[%d]=%d\\n", (i + 1), bnew[(i + 1)]);
  System.out.printf("set bnew[%d]=%d\\n", (i + 2), bnew[(i + 2)]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{56}\nwdocspar

\subsection{Debug: Initialize Legs Container}

\nwenddocs{}\nwbegincode{57}\sublabel{NW2MZpIA-3R3yVH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3R3yVH-1}}}\moddef{Debug: initialize legs container~{\nwtagstyle{}\subpageref{NW2MZpIA-3R3yVH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("init legs=\{ \}\\n");
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{58}\nwdocspar

\subsection{Debug: Set First Leg}

\nwenddocs{}\nwbegincode{59}\sublabel{NW2MZpIA-1F8aiy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-1F8aiy-1}}}\moddef{Debug: set first leg~{\nwtagstyle{}\subpageref{NW2MZpIA-1F8aiy-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set legs[0]=\{ %d, %d, ..., %d, %d  \}\\n",
      legs[0][0], legs[0][1], legs[0][legs[0].length - 2], legs[0][legs[0].length - 1]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{60}\nwdocspar

\subsection{Debug: Set Remaining Legs}

\nwenddocs{}\nwbegincode{61}\sublabel{NW2MZpIA-Zbf0J-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-Zbf0J-1}}}\moddef{Debug: set remaining legs~{\nwtagstyle{}\subpageref{NW2MZpIA-Zbf0J-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set legs[%d]=\{ %d, %d, ..., %d, %d  \}\\n", i,
      legs[i][0], legs[i][1], legs[i][legs[i].length - 2], legs[i][legs[i].length - 1]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{62}\nwdocspar

\subsection{Debug: Set Route Length and Time}

\nwenddocs{}\nwbegincode{63}\sublabel{NW2MZpIA-3WOc2v-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-3WOc2v-1}}}\moddef{Debug: set route length and time~{\nwtagstyle{}\subpageref{NW2MZpIA-3WOc2v-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set n=%d\\n", n);
  System.out.printf("set t=%d\\n", t);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{64}\nwdocspar

\subsection{Debug: Join Route Components}

\nwenddocs{}\nwbegincode{65}\sublabel{NW2MZpIA-J6KjD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-J6KjD-1}}}\moddef{Debug: join route components~{\nwtagstyle{}\subpageref{NW2MZpIA-J6KjD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("set wnew[%d]=%d\\n", k, wnew[k]);
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{66}\nwdocspar

\subsection{Debug: Submit}

\nwenddocs{}\nwbegincode{67}\sublabel{NW2MZpIA-2e4BPs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-2e4BPs-1}}}\moddef{Debug: submit~{\nwtagstyle{}\subpageref{NW2MZpIA-2e4BPs-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-3sZXk2-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("submit:\\n");
  System.out.printf("  server=%d\\n", sid);
  System.out.printf("  wnew=\{ %d, %d, ..., %d, %d \}\\n",
      wnew[0], wnew[1], wnew[wnew.length - 2], wnew[wnew.length - 1]);
  System.out.printf("  bnew=\{ %d, %d, %d, ..., %d, %d, %d \}\\n",
      bnew[0], bnew[1], bnew[2],
      bnew[bnew.length - 3], bnew[bnew.length - 2], bnew[bnew.length - 1]);
  System.out.printf("  radd=\{ %d \}\\n", r[0]);
  System.out.printf("  rsub=\{ \}\\n");
\}
\nwused{\\{NW2MZpIA-3sZXk2-1}}\nwendcode{}\nwbegindocs{68}\nwdocspar

\subsection{Debug: Put Server Location}

\nwenddocs{}\nwbegincode{69}\sublabel{NW2MZpIA-hcsfv-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW2MZpIA-hcsfv-1}}}\moddef{Debug: put server location~{\nwtagstyle{}\subpageref{NW2MZpIA-hcsfv-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW2MZpIA-fLFsG-1}}\nwenddeflinemarkup
if (DEBUG) \{
  System.out.printf("put locations[], key=%d, val=[ %d, %d ]\\n", s[1], s[2]);
\}
\nwused{\\{NW2MZpIA-fLFsG-1}}\nwendcode{}\nwbegindocs{70}\nwdocspar

\nwenddocs{}\nwfilename{src/client-greedy.nw}\nwbegindocs{0}\chapter{Client: GreedyInsertion}
\label{client-greedy}

\nwenddocs{}\nwbegincode{1}\sublabel{NWkwPRG-1Tuf6f-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-1Tuf6f-1}}}\moddef{GreedyInsertion.java~{\nwtagstyle{}\subpageref{NWkwPRG-1Tuf6f-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}GreedyInsertion.java preamble~{\nwtagstyle{}\subpageref{NWkwPRG-1neuor-1}}\RA{}
public class GreedyInsertion extends Client \{
  \LA{}\code{}GreedyInsertion\edoc{} member variables~{\nwtagstyle{}\subpageref{NWkwPRG-jESV1-1}}\RA{}
  \LA{}\code{}GreedyInsertion\edoc{} methods~{\nwtagstyle{}\subpageref{NW3eY1Ju-2B0O1t-1}}\RA{}
\}
\nwnotused{GreedyInsertion.java}\nwendcode{}\nwbegindocs{2}\nwdocspar

\section{Preamble}
\nwenddocs{}\nwbegincode{3}\sublabel{NWkwPRG-1neuor-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-1neuor-1}}}\moddef{GreedyInsertion.java preamble~{\nwtagstyle{}\subpageref{NWkwPRG-1neuor-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-1Tuf6f-1}}\nwenddeflinemarkup
package com.github.jargors.client;
import com.github.jargors.sim.*;
import java.sql.SQLException;
\nwused{\\{NWkwPRG-1Tuf6f-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar

\section{Member Variables}
\nwenddocs{}\nwbegincode{5}\sublabel{NWkwPRG-jESV1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-jESV1-1}}}\moddef{\code{}GreedyInsertion\edoc{} member variables~{\nwtagstyle{}\subpageref{NWkwPRG-jESV1-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-1Tuf6f-1}}\nwenddeflinemarkup
final int PICKUP_THRESHOLD = 600;  // meters
final int MAX_SCHEDULE_LENGTH = 8;
int[] locations = new int[] \{ \};
int count_rejections = 0;
\nwused{\\{NWkwPRG-1Tuf6f-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar

\section{Chunks}

\subsection{Initialize global vars}
\nwenddocs{}\nwbegincode{7}\sublabel{NWkwPRG-jOToH-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-jOToH-1}}}\moddef{Initialize global vars~{\nwtagstyle{}\subpageref{NWkwPRG-jOToH-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (DEBUG) \{
  tools.Print("Extract request \{ rid="+r[0]+", rq="+r[1]+", ro="+r[4]+", rd="+r[5]+" \}");
\}
int     opt_k       = -1;
int     opt_c       = Integer.MAX_VALUE;
int[]   opt_b       = new int[] \{ \};
int[][] opt_cache_t = new int[][] \{ \};
int[][] opt_cache_v = new int[][] \{ \};
if (DEBUG) \{
  tools.Print("Reset opt_k=-1, opt_c=Integer.MAX_VALUE, opt_b=\{\}, opt_cache_t=\{\}, opt_cache_v=\{\}");
\}
final int   T = communicator.retrieveClock();
final int[] L = locations.clone();
final int[] C = tools.filterByHaversine(r[4], L, PICKUP_THRESHOLD);
if (DEBUG) \{
  tools.Print("Initialize T="+T+"; C.length="+C.length);
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar

\subsection{Initialize server vars}
\nwenddocs{}\nwbegincode{9}\sublabel{NWkwPRG-3y7kuU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-3y7kuU-1}}}\moddef{Initialize server vars~{\nwtagstyle{}\subpageref{NWkwPRG-3y7kuU-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
final int sid = L[(k_cand + 0)];
final int st  = L[(k_cand + 1)];
final int sv  = L[(k_cand + 2)];
if (DEBUG) \{
  tools.Print("Extract server \{ sid="+sid+", st="+st+", sv="+sv+" \}");
\}
int     s_k       = -1;
int     s_c       = Integer.MAX_VALUE;
int[]   s_b       = new int[] \{ \};
int[][] s_cache_t = new int[][] \{ \};
int[][] s_cache_v = new int[][] \{ \};
if (DEBUG) \{
  tools.Print("Reset s_k=-1, s_c=Integer.MAX_VALUE, s_b=\{\}, s_cache_t=\{\}, s_cache_v=\{\}");
\}
final int[] y = communicator.queryServerScheduleRemaining(sid, T);
final int   n = (y.length/4);
final int   z = communicator.queryServerDistanceRemaining(sid, T)[0];
if (DEBUG) \{
  tools.Print("Initialize y.length="+y.length+"; n="+n+"; z="+z);
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar

\subsection{Case 1: server is idle or heading towards own destination}
\nwenddocs{}\nwbegincode{11}\sublabel{NWkwPRG-4dVkBS-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-4dVkBS-1}}}\moddef{Case 1: server is idle or heading towards own destination~{\nwtagstyle{}\subpageref{NWkwPRG-4dVkBS-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (n == 1) \{
  if (DEBUG) \{
    tools.Print("Detected n=1");
  \}
  // Beware! Important note! Jargo cannot handle the case where a customer
  // appears at the same vertex that a server is idling at! The reason is
  // because the route would be recorded as
  //   (t1, v)
  //   (t2, v)
  // due to preserving history, (t1, v) cannot be changed; the customer appears
  // at t2; a new waypoint (t2, v) must be recorded in the route in order to be
  // referenceable by Table PD, causing the self-referencing edge (v, v)! This
  // edge violates a Table E constraint.
  //
  // As a workaround, we skip the server if it is idling and happens
  // to be at the request origin.
  if (sv == r[4]) \{
    continue;
  \}

  int[] b = new int[12];
  b[0] = st;
  b[1] = sv;
  b[2] = sid;
  b[4] = r[4];
  b[5] = r[0];
  b[7] = r[5];
  b[8] = r[0];
  b[10] = y[1];
  b[11] = sid;
  if (DEBUG) \{
    tools.Print("Set b[0]="+b[0]);
    tools.Print("Set b[1]="+b[1]);
    tools.Print("Set b[2]="+b[2]);
    tools.Print("Set b[4]="+b[4]);
    tools.Print("Set b[5]="+b[5]);
    tools.Print("Set b[7]="+b[7]);
    tools.Print("Set b[8]="+b[8]);
    tools.Print("Set b[10]="+b[10]);
    tools.Print("Set b[11]="+b[11]);
  \}
  int[][] cache_t = new int[3][];
  int[][] cache_v = new int[3][];
  int c = computeCost(b, cache_t, cache_v, s_c, z, r[2]);
  if (DEBUG) \{
    tools.Print("computeCost returned c="+c);
  \}
  if (c != -1) \{
    \LA{}Accept single solution~{\nwtagstyle{}\subpageref{NWkwPRG-47ILqi-1}}\RA{}
  \}
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar

\subsection{Case 2: server is heading towards a customer}
\nwenddocs{}\nwbegincode{13}\sublabel{NWkwPRG-22IadP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-22IadP-1}}}\moddef{Case 2: server is heading towards a customer~{\nwtagstyle{}\subpageref{NWkwPRG-22IadP-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (n > 1 && n < MAX_SCHEDULE_LENGTH) \{
  if (DEBUG) \{
    tools.Print("Detected n > 1");
  \}
  // Beware! Important note! Jargo cannot handle the case where a customer
  // appears at the same vertex that a server was last seen! In other words,
  // ro cannot equal sv! The reason is that during schedule update, we
  // delete from CQ starting from st onward before re-inserting the new schedule.
  // If there are existing labels on st in CQ, then we would be inserting a
  // second entry on st, causing a constraint violation. If we delete the
  // existing labels, we would have to first query for them and then re-add them.
  // This could be a future fix.
  //
  // As a workaround, we skip the server if it's last-seen vertex happens
  // to be at the request origin.
  if (sv == r[4]) \{
    continue;
  \}

  for (int i = 0; i < n; i++) \{
    for (int j = i; j < n; j++) \{
      boolean capacity_ok = true;
      if (DEBUG) \{
        tools.Print("Set i="+i+", j="+j+", capacity_ok=true");
      \}
      \LA{}Compute sequence~{\nwtagstyle{}\subpageref{NWkwPRG-3KjiZY-1}}\RA{}
      if (capacity_ok) \{
        int[][] cache_t = new int[(b.length/3 - 1)][];
        int[][] cache_v = new int[(b.length/3 - 1)][];
        int c = computeCost(b, cache_t, cache_v, s_c, z, 0);
        if (DEBUG) \{
          tools.Print("computeCost returned c="+c);
        \}
        if (c != -1) \{
          \LA{}Accept single solution~{\nwtagstyle{}\subpageref{NWkwPRG-47ILqi-1}}\RA{}
        \}
      \}
    \}
  \}
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar

\subsection{Compute sequence}
\nwenddocs{}\nwbegincode{15}\sublabel{NWkwPRG-3KjiZY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-3KjiZY-1}}}\moddef{Compute sequence~{\nwtagstyle{}\subpageref{NWkwPRG-3KjiZY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-22IadP-1}}\nwenddeflinemarkup
int[] b = new int[3*(n + 3)];
for (int p = 0; p < (b.length/3); p++) \{
  if (DEBUG) \{
    tools.Print("Set p="+p);
  \}
  \LA{}Check capacity~{\nwtagstyle{}\subpageref{NWkwPRG-27P27q-1}}\RA{}
  if (p == (n + 2)) \{
    b[(3*p + 1)] = y[(4*(p - 3) + 1)];
    b[(3*p + 2)] = y[(4*(p - 3) + 2)];  // server label
  \} else if (p > (j + 2)) \{
    b[(3*p + 1)] = y[(4*(p - 3) + 1)];
    b[(3*p + 2)] = y[(4*(p - 3) + 3)];
  \} else if (p == (j + 2)) \{
    b[(3*p + 1)] = r[5];
    b[(3*p + 2)] = r[0];
  \} else if (p > (i + 1)) \{
    b[(3*p + 1)] = y[(4*(p - 2) + 1)];
    b[(3*p + 2)] = y[(4*(p - 2) + 3)];
  \} else if (p == (i + 1)) \{
    b[(3*p + 1)] = r[4];
    b[(3*p + 2)] = r[0];
  \} else if (p > 0) \{
    b[(3*p + 0)] = y[(4*(p - 1) + 0)];
    b[(3*p + 1)] = y[(4*(p - 1) + 1)];
    b[(3*p + 2)] = y[(4*(p - 1) + 3)];
    if (DEBUG) \{
      tools.Print("Set b["+(3*p + 0)+"]="+b[(3*p + 0)]);
    \}
  \} else \{
    b[(3*p + 0)] = st;
    b[(3*p + 1)] = sv;
    b[(3*p + 2)] = sid;
    if (DEBUG) \{
      tools.Print("Set b["+(3*p + 0)+"]="+b[(3*p + 0)]);
    \}
  \}
  if (DEBUG) \{
    tools.Print("Set b["+(3*p + 1)+"]="+b[(3*p + 1)]);
    tools.Print("Set b["+(3*p + 2)+"]="+b[(3*p + 2)]);
  \}
\}
\nwused{\\{NWkwPRG-22IadP-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

\subsection{Check capacity}
\nwenddocs{}\nwbegincode{17}\sublabel{NWkwPRG-27P27q-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-27P27q-1}}}\moddef{Check capacity~{\nwtagstyle{}\subpageref{NWkwPRG-27P27q-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-3KjiZY-1}}\nwenddeflinemarkup
if (DEBUG) \{
  tools.Print("Check capacity");
\}
if (p >= i && p <= j) \{
  if (DEBUG) \{
    tools.Print("Detected p >= "+i+" && p <= "+j+"; Check capacity");
  \}
  if (r[1] + communicator.queryServerLoadMax(sid, (p == 0 ? st : y[(4*(p - 1))]))[0] > 0) \{
    if (DEBUG) \{
      tools.Print("Detected capacity violation; Break");
    \}
    capacity_ok = false;
    break;
  \}
\}
\nwused{\\{NWkwPRG-3KjiZY-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

\subsection{Accept single solution}
\nwenddocs{}\nwbegincode{19}\sublabel{NWkwPRG-47ILqi-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-47ILqi-1}}}\moddef{Accept single solution~{\nwtagstyle{}\subpageref{NWkwPRG-47ILqi-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-4dVkBS-1}\\{NWkwPRG-22IadP-1}}\nwenddeflinemarkup
if ((c - z) < s_c) \{
  if (DEBUG) \{
    tools.Print("Detected ("+c+" - "+z+")="+(c - z)+" is less than "+s_c);
  \}
  s_k = k_cand;
  s_c = (c - z);
  s_b = b;
  s_cache_t = cache_t;
  s_cache_v = cache_v;
  if (DEBUG) \{
    tools.Print("Replace incumbent single solution, set s_k="+s_k+"; s_c="+s_c+"; s_b.length="+s_b.length);
  \}
  if (s_c < 0) \{
    throw new ClientException("Negative detour");
  \}
\} else \{
  if (DEBUG) \{
    tools.Print("Detected ("+c+" - "+z+")="+(c - z)+" is greater than "+s_c+"; Keep incumbent single solution");
  \}
\}
\nwused{\\{NWkwPRG-4dVkBS-1}\\{NWkwPRG-22IadP-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar

\subsection{Accept server solution}
\nwenddocs{}\nwbegincode{21}\sublabel{NWkwPRG-1EyDWB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-1EyDWB-1}}}\moddef{Accept server solution~{\nwtagstyle{}\subpageref{NWkwPRG-1EyDWB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (s_c < opt_c) \{
  if (DEBUG) \{
    tools.Print("Detected "+s_c+" < "+opt_c);
  \}
  opt_k = s_k;
  opt_c = s_c;
  opt_b = s_b;
  opt_cache_t = s_cache_t;
  opt_cache_v = s_cache_v;
  if (DEBUG) \{
    tools.Print("Replace incumbent server solution, set opt_k="+opt_k+"; opt_c="+opt_c+"; opt_b.length="+s_b.length);
  \}
\} else \{
  if (DEBUG) \{
    tools.Print("Detected "+s_c+" > "+opt_c+"; Keep incumbent server solution");
  \}
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{22}\nwdocspar

\subsection{Submit global solution}
\nwenddocs{}\nwbegincode{23}\sublabel{NWkwPRG-29TDYN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-29TDYN-1}}}\moddef{Submit global solution~{\nwtagstyle{}\subpageref{NWkwPRG-29TDYN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-2OWvsM-1}}\nwenddeflinemarkup
if (opt_k != -1) \{
  \LA{}Construct w from cache~{\nwtagstyle{}\subpageref{NWkwPRG-4ACdbX-1}}\RA{}
  int sid = L[opt_k];
  int[] rids = new int[] \{ r[0] \};
  if (DEBUG) \{
    tools.Print("Submit sid="+sid+"; opt_w.length="+opt_w.length
      +"; opt_b.length="+opt_b.length+"; opt_c="+opt_c+"; rids.length="+rids.length);
  \}
  try \{
    // We added the server's current location to b to help us compute cost,
    // but now we remove the location because it's not really a part of the
    // schedule.
    int[] opt_opt_b = new int[(opt_b.length - 3)];
    for (int i = 3; i < opt_b.length; i++) \{
      opt_opt_b[(i - 3)] = opt_b[i];
    \}
    communicator.updateServerService(sid, opt_w, opt_opt_b, rids, new int[] \{ \});
  \} catch (RouteIllegalOverwriteException e) \{
    count_rejections++;
    if (DEBUG) \{
      tools.Print("Submission rejected due to illegal overwrite!");
    \}
  \} catch (TimeWindowException e) \{
    count_rejections++;
    if (DEBUG) \{
      tools.Print("Submission rejected due to time window violation");
      tools.Print(e.toString());
    \}
  \}
\} else \{
  if (DEBUG) \{
    tools.Print("No match found");
  \}
  communicator.forwardReturnRequest(r);
\}
\nwused{\\{NWkwPRG-2OWvsM-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

\subsection{Construct w from cache}
\nwenddocs{}\nwbegincode{25}\sublabel{NWkwPRG-4ACdbX-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-4ACdbX-1}}}\moddef{Construct w from cache~{\nwtagstyle{}\subpageref{NWkwPRG-4ACdbX-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-29TDYN-1}}\nwenddeflinemarkup
int w_len = 1;
for (int[] leg : opt_cache_v) \{
  w_len += (leg.length - 1);
\}
w_len *= 2;
if (DEBUG) \{
  tools.Print("Construct w from cache");
  tools.Print("Initialize w.length="+w_len);
\}
int[] opt_w = new int[w_len];
opt_w[0] = opt_cache_t[0][0];
opt_w[1] = opt_cache_v[0][0];
if (DEBUG) \{
  tools.Print("Set opt_w[0]="+opt_w[0]);
  tools.Print("Set opt_w[1]="+opt_w[1]);
\}
int base = 0;
for (int p = 0; p < opt_cache_v.length; p++) \{
  if (p > 0) \{
    base += 2*(opt_cache_v[(p - 1)].length - 1);
  \}
  for (int q = 1; q < opt_cache_v[p].length; q++) \{
    opt_w[(base + 2*q + 0)] = opt_cache_t[p][q];
    opt_w[(base + 2*q + 1)] = opt_cache_v[p][q];
    if (DEBUG) \{
      tools.Print("Set opt_w["+(base + 2*q + 0)+"]="+opt_w[(base + 2*q + 0)]);
      tools.Print("Set opt_w["+(base + 2*q + 1)+"]="+opt_w[(base + 2*q + 1)]);
    \}
  \}
\}
\nwused{\\{NWkwPRG-29TDYN-1}}\nwendcode{}\nwbegindocs{26}\nwdocspar

\subsection{Check feasible cost}
\nwenddocs{}\nwbegincode{27}\sublabel{NWkwPRG-UGv0L-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-UGv0L-1}}}\moddef{Check feasible cost~{\nwtagstyle{}\subpageref{NWkwPRG-UGv0L-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-23iwWy-1}}\nwenddeflinemarkup
if ((c - z) > s_c) \{
  if (DEBUG) \{
    tools.Print("Detected cost infeasible ("+(c - z)+" > "+s_c+"); Return");
  \}
  return -1;
\}
\nwused{\\{NWkwPRG-23iwWy-1}}\nwendcode{}\nwbegindocs{28}\nwdocspar

\subsection{Check feasible time window}
\nwenddocs{}\nwbegincode{29}\sublabel{NWkwPRG-4PssH0-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-4PssH0-1}}}\moddef{Check feasible time window~{\nwtagstyle{}\subpageref{NWkwPRG-4PssH0-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NWkwPRG-23iwWy-1}}\nwenddeflinemarkup
int[] u = communicator.queryUser(b[(3*p + 2)]);
if (d < u[2] || d > u[3]) \{
  if (DEBUG) \{
    tools.Print("Detected time infeasible for user "+b[(3*p + 2)]+"; d="+d+"; u[2]="+u[2]+"; u[3]="+u[3]+"; Return");
  \}
  return -1;
\}
\nwused{\\{NWkwPRG-23iwWy-1}}\nwendcode{}\nwbegindocs{30}\nwdocspar


\section{Methods}

\subsection{GreedyInsertion: \texttt{handleRequest}(1)}
\nwenddocs{}\nwbegincode{31}\sublabel{NWkwPRG-2OWvsM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-2OWvsM-1}}}\moddef{GreedyInsertion: handleRequest(1)~{\nwtagstyle{}\subpageref{NWkwPRG-2OWvsM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-2B0O1t-1}}\nwenddeflinemarkup
void handleRequest(int[] r) throws ClientException, ClientFatalException \{
  try \{
    \LA{}Initialize global vars~{\nwtagstyle{}\subpageref{NWkwPRG-jOToH-1}}\RA{}
    for (int k_cand : C) \{
      \LA{}Initialize server vars~{\nwtagstyle{}\subpageref{NWkwPRG-3y7kuU-1}}\RA{}
      \LA{}Case 1: server is idle or heading towards own destination~{\nwtagstyle{}\subpageref{NWkwPRG-4dVkBS-1}}\RA{}
      \LA{}Case 2: server is heading towards a customer~{\nwtagstyle{}\subpageref{NWkwPRG-22IadP-1}}\RA{}
      if (n >= MAX_SCHEDULE_LENGTH) \{
        if (DEBUG) \{
          tools.Print("Detected n >= MAX_SCHEDULE_LENGTH");
        \}
      \}
      \LA{}Accept server solution~{\nwtagstyle{}\subpageref{NWkwPRG-1EyDWB-1}}\RA{}
    \}
    \LA{}Submit global solution~{\nwtagstyle{}\subpageref{NWkwPRG-29TDYN-1}}\RA{}
  \} catch (SQLException e) \{
    throw new ClientException(e);
  \} catch (VertexNotFoundException | EdgeNotFoundException | UserNotFoundException e) \{
    throw new ClientException(e);
  \}
\}
\nwused{\\{NW3eY1Ju-2B0O1t-1}}\nwendcode{}\nwbegindocs{32}\nwdocspar

\subsection{GreedyInsertion: \texttt{endCollectServerLocations}(1)}
\nwenddocs{}\nwbegincode{33}\sublabel{NWkwPRG-1cMqeO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-1cMqeO-1}}}\moddef{GreedyInsertion: endCollectServerLocations(1)~{\nwtagstyle{}\subpageref{NWkwPRG-1cMqeO-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-2B0O1t-1}}\nwenddeflinemarkup
void endCollectServerLocations(int[] src) \{
  locations = src.clone();
\}
\nwused{\\{NW3eY1Ju-2B0O1t-1}}\nwendcode{}\nwbegindocs{34}\nwdocspar

\subsection{GreedyInsertion:\texttt{end}(0)}
\nwenddocs{}\nwbegincode{35}\sublabel{NWkwPRG-222iyz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-222iyz-1}}}\moddef{GreedyInsertion: end(0)~{\nwtagstyle{}\subpageref{NWkwPRG-222iyz-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-2B0O1t-1}}\nwenddeflinemarkup
void end() \{
  tools.Print("Count rejections: "+count_rejections);
\}
\nwused{\\{NW3eY1Ju-2B0O1t-1}}\nwendcode{}\nwbegindocs{36}\nwdocspar

\subsection{GreedyInsertion: \texttt{computeCost}(6)}
\nwenddocs{}\nwbegincode{37}\sublabel{NWkwPRG-23iwWy-1}\nwmargintag{{\nwtagstyle{}\subpageref{NWkwPRG-23iwWy-1}}}\moddef{GreedyInsertion: computeCost(6)~{\nwtagstyle{}\subpageref{NWkwPRG-23iwWy-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW3eY1Ju-2B0O1t-2}}\nwenddeflinemarkup
int computeCost(int[] b, int[][] cache_t, int[][] cache_v, int s_c, int z, int d_init)
throws ClientException, ClientFatalException \{
  try \{
    if (DEBUG) \{
      tools.Print("computeCost called on b.length="+b.length+", s_c="+s_c+", z="+z);
    \}
    int c = 0;
    int d = 0;
    int[] leg = new int[] \{ \};
    int[] ddnu = new int[] \{ \};
    if (DEBUG) \{
      tools.Print("..set c=0");
    \}
    for (int p = 1; p < (b.length/3); p++) \{
      if (DEBUG) \{
        tools.Print("..set p="+p);
      \}
      leg = tools.computeShortestPath(b[(3*(p - 1) + 1)], b[(3*p + 1)]);
      if (DEBUG) \{
        tools.Print("..call computeShortestPath("+b[(3*(p - 1) + 1)]+", "+b[(3*p + 1)]+")");
      \}
      d = b[(3*(p - 1))];
      if (DEBUG) \{
        tools.Print("..set d="+d);
      \}
      cache_t[(p - 1)] = new int[leg.length];
      cache_t[(p - 1)][0] = d;
      if (DEBUG) \{
        tools.Print("..set cache_t["+(p - 1)+"]=new int["+leg.length+"]");
        tools.Print("..set cache_t["+(p - 1)+"][0]="+d);
      \}
      if (p == 1) \{
        d += d_init;
        if (DEBUG) \{
          tools.Print("..add d_init; d="+d);
        \}
      \}
      for (int q = 1; q < leg.length; q++) \{
        if (DEBUG) \{
          tools.Print("....set q="+q);
        \}
        ddnu = communicator.queryEdge(leg[(q - 1)], leg[q]);
        if (DEBUG) \{
          tools.Print("....call queryEdge("+leg[(q - 1)]+", "+leg[q]+")");
        \}
        c += ddnu[0];
        d += tools.computeDuration(ddnu[0], ddnu[1]);
        if (DEBUG) \{
          tools.Print("....set c="+c);
          tools.Print("....set d="+d);
        \}
        cache_t[(p - 1)][q] = d;
        if (DEBUG) \{
          tools.Print("....set cache_t["+(p - 1)+"]["+q+"]="+d);
        \}
      \}
      \LA{}Check feasible cost~{\nwtagstyle{}\subpageref{NWkwPRG-UGv0L-1}}\RA{}
      \LA{}Check feasible time window~{\nwtagstyle{}\subpageref{NWkwPRG-4PssH0-1}}\RA{}
      b[(3*p)] = d;
      if (DEBUG) \{
        tools.Print("..set b["+(3*p)+"]="+d);
      \}
      cache_v[(p - 1)] = leg.clone();
      if (DEBUG) \{
        tools.Print("..set cache_v["+(p - 1)+"]=<leg.length="+leg.length+">");
      \}
    \}
    return c;
  \} catch (SQLException e) \{
    tools.Print("Something very bad happened");
    tools.PrintSQLException(e);
    throw new ClientFatalException();
  \} catch (GtreeNotLoadedException e) \{
    tools.Print("Gtree not loaded, can't continue!");
    throw new ClientFatalException();
  \} catch (GtreeIllegalSourceException e) \{
    throw new ClientException(e);
  \} catch (EdgeNotFoundException | UserNotFoundException e) \{
    throw new ClientException(e);
  \}
\}
\nwused{\\{NW3eY1Ju-2B0O1t-2}}\nwendcode{}\nwbegindocs{38}\nwdocspar

\nwenddocs{}\nwfilename{src/traffic-overview.nw}\nwbegindocs{0}\nwenddocs{}\nwfilename{src/traffic-broadway.nw}\nwbegindocs{0}\chapter{Traffic: Broadway}

\nwenddocs{}\nwbegincode{1}\sublabel{NW1QgbvE-3asg0V-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW1QgbvE-3asg0V-1}}}\moddef{Broadway.java~{\nwtagstyle{}\subpageref{NW1QgbvE-3asg0V-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
package com.github.jargors.traffic;
import com.github.jargors.sim.*;
import java.util.Map;
public class Broadway extends Traffic \{
  private Map<Integer, Integer> lu_broadway = Map.ofEntries(
    Map.entry(10024,6898),
    Map.entry(10071,7512),
    Map.entry(10109,11306),
    Map.entry(10298,4057),
    Map.entry(10342,9159),
    Map.entry(10378,10775),
    Map.entry(1041,1043),
    Map.entry(1043,5145),
    Map.entry(10506,11594),
    Map.entry(10517,10519),
    Map.entry(10519,3814),
    Map.entry(10565,9347),
    Map.entry(10572,3304),
    Map.entry(10628,6944),
    Map.entry(10671,10672),
    Map.entry(10672,326),
    Map.entry(10690,10691),
    Map.entry(10691,1994),
    Map.entry(10729,11922),
    Map.entry(10775,4882),
    Map.entry(10864,2072),
    Map.entry(10949,7023),
    Map.entry(10966,7019),
    Map.entry(10983,2568),
    Map.entry(11024,3875),
    Map.entry(11066,7349),
    Map.entry(11172,8494),
    Map.entry(11197,1893),
    Map.entry(11306,7781),
    Map.entry(11314,2490),
    Map.entry(11366,1216),
    Map.entry(11398,10342),
    Map.entry(11438,8502),
    Map.entry(11439,11398),
    Map.entry(1155,6168),
    Map.entry(11594,160),
    Map.entry(1162,2350),
    Map.entry(11922,10949),
    Map.entry(11930,7340),
    Map.entry(12,4286),
    Map.entry(12114,1239),
    Map.entry(1216,1218),
    Map.entry(1218,7106),
    Map.entry(1239,1241),
    Map.entry(1241,3383),
    Map.entry(1290,4347),
    Map.entry(1467,1469),
    Map.entry(1469,10628),
    Map.entry(1564,1565),
    Map.entry(1565,4163),
    Map.entry(160,161),
    Map.entry(161,8444),
    Map.entry(1732,1734),
    Map.entry(1734,1564),
    Map.entry(180,181),
    Map.entry(181,4284),
    Map.entry(1821,10671),
    Map.entry(1832,1833),
    Map.entry(1833,10864),
    Map.entry(1854,1855),
    Map.entry(1855,2920),
    Map.entry(1883,6805),
    Map.entry(1893,1894),
    Map.entry(1894,3858),
    Map.entry(1936,1937),
    Map.entry(1937,5830),
    Map.entry(1950,887),
    Map.entry(1994,632),
    Map.entry(2072,2073),
    Map.entry(2073,7294),
    Map.entry(2083,2084),
    Map.entry(2084,6989),
    Map.entry(2118,7558),
    Map.entry(2146,2147),
    Map.entry(2147,3515),
    Map.entry(218,219),
    Map.entry(219,11314),
    Map.entry(2194,2195),
    Map.entry(2195,8923),
    Map.entry(2252,4641),
    Map.entry(226,8293),
    Map.entry(2277,2278),
    Map.entry(2278,9841),
    Map.entry(2316,843),
    Map.entry(2323,2324),
    Map.entry(2324,8683),
    Map.entry(2350,12),
    Map.entry(2393,2394),
    Map.entry(2394,4693),
    Map.entry(2413,2083),
    Map.entry(2417,6),
    Map.entry(2418,2419),
    Map.entry(2419,6973),
    Map.entry(2458,1854),
    Map.entry(2468,2418),
    Map.entry(2490,2492),
    Map.entry(2492,4298),
    Map.entry(2568,2570),
    Map.entry(2570,10024),
    Map.entry(2615,10729),
    Map.entry(2680,1883),
    Map.entry(2750,2751),
    Map.entry(2751,3016),
    Map.entry(2888,12114),
    Map.entry(2920,2888),
    Map.entry(2928,2194),
    Map.entry(3011,3013),
    Map.entry(3013,2417),
    Map.entry(3016,4767),
    Map.entry(3024,9569),
    Map.entry(3107,1467),
    Map.entry(3205,3207),
    Map.entry(3207,9193),
    Map.entry(3213,582),
    Map.entry(323,325),
    Map.entry(325,10109),
    Map.entry(326,327),
    Map.entry(327,3652),
    Map.entry(3299,2468),
    Map.entry(3304,3305),
    Map.entry(3305,5836),
    Map.entry(3383,6221),
    Map.entry(3423,3424),
    Map.entry(3424,6985),
    Map.entry(3432,3434),
    Map.entry(3434,323),
    Map.entry(3471,1936),
    Map.entry(351,353),
    Map.entry(3515,2615),
    Map.entry(353,773),
    Map.entry(355,356),
    Map.entry(3559,7418),
    Map.entry(356,11366),
    Map.entry(3597,3598),
    Map.entry(3598,8635),
    Map.entry(3628,3629),
    Map.entry(3629,3107),
    Map.entry(363,364),
    Map.entry(364,6983),
    Map.entry(3652,9572),
    Map.entry(3670,8411),
    Map.entry(3814,3816),
    Map.entry(3816,7084),
    Map.entry(3858,6061),
    Map.entry(3875,3876),
    Map.entry(3876,2458),
    Map.entry(398,399),
    Map.entry(399,3471),
    Map.entry(4057,2277),
    Map.entry(4149,2316),
    Map.entry(4163,6214),
    Map.entry(4201,4203),
    Map.entry(4203,5670),
    Map.entry(4213,6243),
    Map.entry(4284,5690),
    Map.entry(4286,6625),
    Map.entry(4298,9435),
    Map.entry(4347,4348),
    Map.entry(4348,6066),
    Map.entry(4357,4358),
    Map.entry(4358,6855),
    Map.entry(4414,8229),
    Map.entry(4516,4620),
    Map.entry(4529,1155),
    Map.entry(4535,5625),
    Map.entry(4543,8810),
    Map.entry(4620,3597),
    Map.entry(4641,4881),
    Map.entry(4693,4694),
    Map.entry(4694,5408),
    Map.entry(4742,4743),
    Map.entry(4743,3024),
    Map.entry(4767,4768),
    Map.entry(4768,5748),
    Map.entry(4774,4775),
    Map.entry(4775,5797),
    Map.entry(4881,7348),
    Map.entry(4882,4883),
    Map.entry(4883,4357),
    Map.entry(4927,11930),
    Map.entry(4932,5186),
    Map.entry(5017,7725),
    Map.entry(5024,5861),
    Map.entry(5145,5146),
    Map.entry(5146,525),
    Map.entry(5183,5184),
    Map.entry(5184,218),
    Map.entry(5186,4543),
    Map.entry(525,526),
    Map.entry(526,2118),
    Map.entry(5408,351),
    Map.entry(5481,9498),
    Map.entry(5625,4414),
    Map.entry(5670,11197),
    Map.entry(5690,5691),
    Map.entry(5691,10690),
    Map.entry(5797,4149),
    Map.entry(582,583),
    Map.entry(583,8426),
    Map.entry(5830,355),
    Map.entry(5836,11066),
    Map.entry(5861,5862),
    Map.entry(5862,1950),
    Map.entry(6,8),
    Map.entry(605,606),
    Map.entry(606,4529),
    Map.entry(6061,3628),
    Map.entry(6066,10506),
    Map.entry(6076,1162),
    Map.entry(6130,6131),
    Map.entry(6131,8353),
    Map.entry(6168,7647),
    Map.entry(621,11024),
    Map.entry(6214,3423),
    Map.entry(6221,6222),
    Map.entry(6222,7324),
    Map.entry(6234,2393),
    Map.entry(6243,4774),
    Map.entry(632,6750),
    Map.entry(6625,5024),
    Map.entry(6708,8140),
    Map.entry(6750,6752),
    Map.entry(6752,8339),
    Map.entry(6805,3299),
    Map.entry(6855,6856),
    Map.entry(6856,1041),
    Map.entry(6889,4932),
    Map.entry(6944,11438),
    Map.entry(6973,11439),
    Map.entry(6983,6984),
    Map.entry(6984,8154),
    Map.entry(6985,927),
    Map.entry(6989,3011),
    Map.entry(7019,4742),
    Map.entry(7023,5183),
    Map.entry(7084,10983),
    Map.entry(7086,888),
    Map.entry(7106,7645),
    Map.entry(7217,10298),
    Map.entry(7254,2928),
    Map.entry(7294,7295),
    Map.entry(7295,7524),
    Map.entry(7324,3205),
    Map.entry(7328,7330),
    Map.entry(7330,2750),
    //Map.entry(7339,130),
    Map.entry(7339,7328),
    Map.entry(7340,8109),
    Map.entry(7348,10565),
    Map.entry(7349,3559),
    Map.entry(7418,11172),
    Map.entry(7477,10378),
    Map.entry(7512,7513),
    Map.entry(7513,7254),
    Map.entry(7524,605),
    Map.entry(7558,1832),
    Map.entry(7611,9865),
    Map.entry(7645,7646),
    Map.entry(7646,3213),
    Map.entry(7647,4201),
    Map.entry(7725,7775),
    Map.entry(773,2252),
    Map.entry(7775,9024),
    Map.entry(7781,130),
    Map.entry(7853,7855),
    Map.entry(7855,398),
    Map.entry(8,4535),
    Map.entry(8059,10517),
    Map.entry(8109,2919),
    Map.entry(8140,10966),
    Map.entry(8154,6076),
    Map.entry(8201,8202),
    Map.entry(8202,2680),
    Map.entry(8229,8918),
    Map.entry(8293,2413),
    Map.entry(8335,180),
    Map.entry(8339,2323),
    Map.entry(8353,8354),
    Map.entry(8354,7853),
    Map.entry(8411,6234),
    Map.entry(8426,1821),
    Map.entry(843,845),
    Map.entry(8444,363),
    Map.entry(845,3670),
    Map.entry(8475,5017),
    Map.entry(8494,8495),
    Map.entry(8495,6130),
    Map.entry(8502,2146),
    Map.entry(8635,1290),
    Map.entry(8683,8684),
    Map.entry(8684,10572),
    Map.entry(8810,8812),
    Map.entry(8812,9103),
    Map.entry(887,6708),
    Map.entry(888,889),
    Map.entry(889,226),
    Map.entry(8918,7611),
    Map.entry(8923,6889),
    Map.entry(9024,8059),
    Map.entry(9103,4516),
    Map.entry(9159,5481),
    Map.entry(9193,10071),
    Map.entry(927,929),
    Map.entry(929,8475),
    Map.entry(9347,9348),
    Map.entry(9348,8335),
    Map.entry(9435,3432),
    Map.entry(9498,7217),
    Map.entry(9521,621),
    Map.entry(9569,4927),
    Map.entry(9572,9573),
    Map.entry(9573,9908),
    Map.entry(9841,9521),
    Map.entry(9865,9866),
    Map.entry(9866,1732),
    Map.entry(9908,8201)
  );
  // New Year's Eve in Manhattan: speed on Broadway is at 80% at 11:30 PM, then
  // speed decreases starting from midnight until 1:30 AM to 20% until 5:00 AM.
  // We do (vertex - 1) because edges above are 0-indexed while nodes in Jargo
  // are 1-indexed.
  public double apply(int v1, int v2, long msec) \{
    double per = 1.0;
    if ((lu_broadway.containsKey(v1-1) && lu_broadway.get(v1-1) == v2-1)
     || (lu_broadway.containsKey(v2-1) && lu_broadway.get(v2-1) == v1-1)) \{
      if (msec > 84600_000) \{  // 20% at 11:30 PM
        // per = 1-0.8*(86400_000 - msec)/1800_000;
        per = 0.2;
      \} else if (msec < 5400_000) \{  // 100% at 12:00AM moving to 20% at 1:30 AM
        per = Math.max(0.2, (5400_000 - msec)/5400_000);
      \} else if (msec < 18000_000) \{  // 20% from 1:30 AM to 5:00 AM
        per = 0.2;
      \}
    \}
    return per;
  \}
\}
\nwnotused{Broadway.java}\nwendcode{}\nwbegindocs{2}\nwdocspar

\nwenddocs{}
